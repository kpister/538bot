��는 phones call Service Blind�, so it should be no surprise
 P-A-4, homework 4, are out
 They went out last Sunday, or yesterday
 They do this upcoming Sunday
 Also, there's a midterm next week
 That's midterm 1
 I have from last semester, and I will write you guys a new one custom for you
 A little guide on Piazza
 This is roughly what it's going to look like
 This is last semester, so it's a little bit outdated
 But loosely speaking, it will be four questions with one extra credit
 There will be a question on type inference, which is what we will be covering this week
 There will be a question on activation records, which is what we covered last week
 There will be a question and a half on Lambda Calculus, and there will be a question that's just like true false about PL so far what we've been talking about
 You do get a cheat sheet
 It's one page front back
 The review session is next Monday that says Tuesday, because last semester was Tuesday, Thursday
 Any questions on midterm? Stuff? Yeah
 It's during class
 It is during class
 Next Wednesday, during class, you have 75 minutes of class
 Show up, ready with a pencil
 You will be writing answers to all of the questions
 You will be writing a little bit of code
 No
 Not really
 Kind of
 Like a little bit of code
 A little bit of code
 Other questions? Yeah
 I will release at least part of last year's exam
 Yeah
 I haven't written this year's exam so I don't know exactly what it's going to look like, but I'll give you some stuff from last year or last semester
 Cool
 If you were able, how many people were able to install? Oh, yeah
 Yeah
 Homework three and homework four answers
 Homework three answers will be posted today or tomorrow
 Homework four answers will be posted like Monday at 12 o'1 a
m
 So as soon as the homework is due, you'll have the answers for that
 Because I know that's kind of crunch time
 Other questions? Okay
 How many people were able to install Haskell before? I sent kind of a last minute P
O
s a post about it
 Okay
 Great
 If you have it, great
 If you don't have it, you need to for this next assignment
 So get it sooner rather than later in case you're on into issues
 If you have Haskell on your computer and you brought your computer, I encourage you to download the intro blank HS file on Canvas
 Because that's what we're going to loosely be going through today as we talk about Haskell
 Before we get to the code itself, though, let's chat for a minute about why we are talking about Haskell
 Show a hands who's written Haskell before, not including P
A
4, because I know some of you have already actually completed it
 There were some grade scopes emissions earlier
 Anybody used it before? No one
 Okay
 We had like two or three last time
 So Haskell in a single sentence is a typed lazy, purely functional language
 These are like the high-level keywords that make it interesting
 So first off, Haskell is statically typed
 What does that mean? What does it mean for a language to be statically typed? Yeah
 All of the type checking is done at compile time
 What does that mean? What does type checking mean? Yeah
 Yeah
 Yeah
 So we say this variable is an integer, this variable is a list
 If we tried to add a list and an integer, Haskell will tell you that's an error
 And importantly, it will tell you it's an error at compile time, which is different than telling you it's an error at runtime
 Okay
 So in Haskell, we say everything has a type
 There are no untiped features or variables or values
 And everything must make sense at compile time
 This is unlike JavaScript or Python where you can kind of change the type as you're going and the runtime will eventually try and figure it out
 Why is it cool to be statically typed? What are the advantages? Yeah
 Yeah
 Yeah
 Definitely
 You're solving problems when you compile your code before you ship your code to production
 That's great
 Why else? Yeah
 Yeah
 All of your type testing is done for you by the compiler
 There's no like check to make sure this is a list before I do something with it
 It is a list
 You've said that it's a list
 Why else? Yeah
 Yeah
 Optimization
 So if the compiler and the runtime know that something is an int and it will always be an int, then it can allocate enough space for an int
 And in Python, if you say something's an int and then you turn around and say it's actually an object, it has to allocate the space for both and doesn't know when it can get rid of what
 So type a static type checking removes a whole class of bugs
 Like we said before you get to production, you find all your bugs early
 So we find them early before they're triggered
 You prevent weird errors as well
 You prevent the whole like adding an object to a list sort of error that JavaScript has or a lack of error that JavaScript has
 And it's easier to optimize
 One of the other things is that you can actually write faster code if your IDE is working with you
 And you say something takes an integer and returns a string
 And you have another function that helps convert integers to strings
 Maybe you're trying to use that function inside of your new function
 Great
 So it's statically statically typed
 Haskell is also functional
 What do we mean by that? What does it mean for a language to be functional? We saw this with JavaScript as well
 Yeah
 First class support for functions
 Definitely
 Yep
 What else? This one we didn't really cover explicitly
 But in general, programs are about expressions rather than executing instructions
 Haskell very much does not go line by line execute one two three four
 It says you have presented an expression a complex expression
 Let me simplify it
 Think about this as a long lambda calculus program
 How can we simplify before we do anything else? Okay
 So it's functional
 What else do we say it's pure? Haskell is pure
 What that means is that expressions don't have side effects
 A side effect is something that happens outside of your program itself
 Printing to screen for example, that's a side effect
 You're affecting the world outside of your program
 Updating a variable
 That's a side effect
 So actually everything is immutable
 Once you set a value, you cannot change it
 What that means is that any time we have an E, the free variables of E will all have the same values
 So if we say x is equal to three, x will be equal to three within a specific scope for all the free variables that are x
 This allows us to do a lot of optimization
 So the point of purity is to make your code fast
 We get to compile it and do a lot of the execution right away at compile time
 Not at runtime
 Okay
 Let's compare to JavaScript
 JavaScript
 Is it typed or is it not typed? Yes? No
 Chat with someone next to you
 Try and convince them
 There was a little bit of a split
 All right
 What do we think typed? Untyped
 That didn't really change anybody's opinion
 No, it's definitely typed
 It's just runtime typed
 If you try and do certain actions to some objects, you can't do it
 There is a typed system
 It's just all done at runtime and it's very loose
 Okay
 So it is typed
 Is it statically typed? Just gave that one away
 How many people say yes? Statically typed
 All right
 This is a good check
 How many people say no? It's not statically typed
 Yes
 It's done at runtime
 That's JavaScript's whole deal
 It says stop doing everything so early
 If it doesn't matter, it doesn't matter
 Just try and ship it
 All right
 Is JavaScript functional? Oh, yeah
 Question
 What's the name for how it's typed when it does? Dynamically typed
 Yeah
 So runtime, dynamic, compile time, static
 That'll come up pretty often
 Those two keyword matches
 What does it mean to me? Dynamically typed
 Yes
 So being dynamically typed means that at runtime, you're going to be doing various typing operations
 So you might be checking to say, is this type equal to this other type? Can we use this type in this spot for this other type? Things of that nature
 Yeah
 Having no type system is pretty rare
 That generally means you're working with bits
 See is typed
 Yeah
 See, see is typed
 It's a statically typed language
 It's a weekly statically typed language
 Because you have to say this is an int x equals four things like that
 But then you can turn things into void pointers and turn them into whatever you want
 So it's weekly typed
 All right
 Functional JavaScript
 What do we say? Yes
 No
 Yes, no
 It is functional, but it's also not functional
 It's got sides of both
 So what about pure? Is JavaScript pure? Yes
 No
 I love when you guys are following along
 Cool
 So in reference to JavaScript, we're kind of aligned on the fact that we have a type system and we're functional, but we're statically typed and we're pure
 So it's a lot more restrictive, but with those restrictions, we get a lot of power
 And Boccas, who looks so cool in his gene jacket, was one of the inventors
 He thinks it's really cool
 You guys must think it's really cool too
 So some of the real reasons we get algebraic laws
 We get to start talking about Haskell as though it's math
 And what that means is that we can think about things in lambda calculus and apply them directly to Haskell
 You will get suggestions from your IDE that say, do you want to do an ADA reduction here? And that's exactly what we learned how to do in lambda calculus
 And it's the same exact idea
 The fact that it's easier to think about is something that's maybe a bit opinionated
 Once you get comfortable with it, it becomes easy to think about
 When you haven't worked with Haskell, it is definitely not easy to think about
 And finally, parallelism, especially with respect to purity, is very easy
 You don't have to worry about things like race conditions if you can't access anything outside of your program
 So you can just run threads as easily as you want to because they aren't going to cause any trouble with each other
 So that's great
 We can also treat your entire program as a parallel expression to the extent that we can decouple the pieces of your program
 So you get very fast execution
 For this purpose, Haskell is actually used in some web servers because that's kind of the very parallelizable workload
 So it's used in production systems
 The last piece of the puzzle for Haskell is that it is lazy
 You guys are very familiar with lazy at this point
 Hopefully, if you've done PA3
 What does it mean for Haskell to be lazy? Yeah
 Yeah, we aren't going to execute functions twice for sure
 We're going to create some sort of function cache
 What else? Do you have an idea? Closures
 Yes, that's covered on the functional side
 That's like high order functional Haskell
 We don't evaluate expressions until we actually need them
 So even if you say call f with the value three, we aren't going to evaluate that expression until something else requests the result of it
 So those are the two pieces of laziness that we aren't evaluating expressions until absolutely necessary
 This is called by name
 And then we will cache the results of our expressions
 This is for every function call
 It's not just the delayed function calls, every function call
 Can we cache results like this in JavaScript? Yeah
 We can build an interface for it, but it would break some of the expected behavior of JavaScript
 Because JavaScript has side effects
 We can update a variable inside of a function call so that the next time we call a function, it gives us a different result
 So we can't generically cache results in JavaScript
 We might be able to build a framework where in some situations we can use this, but it's not something we can implement at the language level
 Questions so far in Haskell? I've thrown a lot of content at you guys
 Yeah
 What is like actual and commercially besides research? Is that like even a thing that's relevant or does it have like one different, like only if we can understand these commercial
 No, yeah
 There are a lot of Haskell teams out in the wild
 So I believe it's meta has a whole division that just does Haskell development and then a lot of startups use it
 It's primarily favored for web dev because of the parallelization where you can say everything is like every request that comes in gets its own thread
 We don't have to worry about scaling that to infinity
 But a lot of it is definitely research
 So it is on both sides there
 I haven't ever personally used it in production
 So I can't speak too much to that side of things, but people do
 You had a question as well? Yeah, so weakly typed and strongly typed, which was not covered here
 It's not tested on
 Is the difference between being able to tell the compiler that it is wrong about a type
 So you create a type and say it's x, it's a string, and then you say no actually now it's something else
 And the compiler lets you do that
 That's a weakly typed language
 Strongly typed languages would say no, that's a string
 You told me it's a string
 Is a string
 Any other questions on Haskell? We're going to keep chatting about it
 Okay
 So why is laziness cool? Some of the reasons are that we can create our own control structures
 So it's very easy to define an if else statement in Haskell where you just give it the two chunks of code to run and it won't run them until you tell it to run the correct one
 We can also create what infinite data structures
 So you can create a list that goes on to infinity and solongs you'll never access the first 10 elements
 You won't get an infinite error
 Yeah, those are two cool laziness features
 Haskell is what's called a committee language
 That means that the language features are determined by a group of people, a group of largely old academic people
 This is from 2005 or something like that
 It's an old photo too
 So these people are even older now
 But why it's interesting that Haskell is a committee language is because when you look at the lifespan of languages and you would look at something that's like kind of the mainstream industry language
 C, C++, JavaScript, Ruby, these languages take off once somebody starts working in it and proves its effectiveness
 Other people start developing in it and it's got network effects that bring in more people because some company adopts it that then turns out more engineers who know it, etc
 So they grow very fast exponentially
 Research languages, on the other hand, tend to be the one PhD student working on the language and then they, it's not actually at graduation that they stop
 They realize halfway through this is a bad idea
 They have to swap and either rewrite and start a new language which will fix all their problems or drop out and do something else
 So research languages don't really get anywhere
 Successful research languages, they convince all their colleagues, they're cohort, they should use the language for whatever random tasks
 Because they survive the full duration of the PhD students tenure
 So they get up to 100 people
 Committee languages never really get anywhere, not even the committee uses them because nobody can agree on what features should be in the language, what features shouldn't be in the language
 And then there's Haskell that sits somewhere in the middle here and it's actually got real adoption and this is an old graph from the source, this was like 2005 or something
 So it has really started to take off and grow where people want to use it despite the traditional trend of committee languages, which is that nobody wants to use them
 So it's a bit of a unique language in that sense
 Okay, from here we're going to take a look at some actual Haskell code
 We didn't do this with JavaScript because JavaScript is pretty similar to other languages that you've seen
 Haskell is not
 Haskell will look quite a bit different than what you're used to
 So I want to guide you through some of the simple things
 But to like preface that I came up with this and spent a little bit too long on the the effort here, but I think traditional education, especially in undergrad, focuses on you are sitting in a lecture
 And then you sometimes ask questions and occasionally you'll think about implementation and then finally you get to coding at the very end and it's kind of the small part of the class
 I think this is totally bogus and it's something more like this
 This that took me a while
 It was really fun
 Coding is like foundational to learning because when you code, you then have to think about how should I implement this thing
 And when you are thinking about how I should implement this thing, you start to ask questions, which then means that you're thinking, which then means that you engage
 So I think it's actually very important that you start coding with Haskell to understand how to use Haskell rather than just having me stand up here and kind of tell you and show you Haskell
 There's a lot more to be learned from actually doing
 So with that, let me show you Haskell and hopefully you guys have code and can follow along
 Yeah, it is not published
 I guarantee it because I just uploaded it
 Oh, no, no, it is
 It says that it is at 206
 Oh, parent folder is probably not published
 That's it
 That's smart
 Yeah, there's also a solutions folder
 You know, if you guys can break into
 Yeah, that's the problem
 Thank you for letting me know
 There was another question
 Same thing
 All right
 Is it now available? HS code is the folder
 There's hopefully intro HS
 The other ones you don't need yet
 So ignore them
 They aren't published for a reason
 Okay
 Now it's our favorite issue of lighting, but I've got it
 Okay
 So how's that font size bigger, smaller? You guys in the back
 A little bit bigger
 A little bit
 Something like that
 Something that's important to know
 This is code
 We are now looking at code
 This is Haskell
 What do you do with a file? What do you do with a Haskell file? So if you were able to install GHC, we can use GHCI, which is the Haskell interpreter
 The Glasgow Haskell compiler interpreter doesn't make too much sense
 But if you type GHCI, you should get into a repo where you can do things like set x equal 4
 And you're writing Haskell
 Awesome
 If we look at value of x, x is 4
 Some of the most important things to know
 Like VIM, you need to know how to exit because control C won't get you there
 Control D actually does
 I didn't know that one
 But colon Q is the idiomatic way to exit
 Great
 We're out
 And then once you are using it, the very common thing that you want to do is to reload
 If you update one of your files, you can reload to reload in the new version
 And you can ask for the type of something with colon T
 The type of x, x is not in scope
 So that's how we access the interpreter
 How do we access a file? It's the same thing
 GHCI of intro
HS
 Today we have a module loaded
 And now we can ask things about what's inside of here
 What is inside of here? What's something that we use? Is there like a add3? That's a thing
 What's the type of add3? It's integer to integer
 Cool
 We can access the values inside of our file
 So now let's look at our file
 We start with a module line just to say what's the deal with this file? Where do we belong? And then prelude is the name of the standard lib
 So if you're used to importing the like C out or I haven't written Java for ever
 So I don't know what you guys import there
 But for definitions, Haskell uses something that looks very similar to every other language
 We use the equal sign to declare symbol bindings
 We say x is equal to 2
 And we call this a variable
 But as I mentioned, Haskell, you can't change anything
 So it's not really variable
 What happens if we do this? We've said x equals 2 at the top
 Actually, this is great
 So two dashes is starting a comment, by the way
 That's what all of these lines are
 If we look at x here, we've said x is equal to 2
 When we print out x, we get the value 2
 And we can look at the type of x here
 It's an integer
 So what happens if we say x is equal to 3? Based on what you know about Haskell so far
 Yeah
 It'll crash
 I mean, it's a bit dramatic for Haskell
 But it's not going to let you run that
 It's going to give you an error
 It's going to say you can't do multiple declarations of x
 X is already defined
 Variables are not variable
 Yeah
 So how did it infer when we ran this? And I say what's the type of x? It says x is an integer
 How did it infer that? That's what next lecture is about
 So we're going to spend the whole time talking about how to do type inference
 Yep
 Okay
 So we can't re-declare variables, but we can use new scopes and in a new scope, redefine a variable
 So we can say let x equal 44 in this expression in this expression or let x equal 44 and z equal x minus 2 in this expression
 So what we've done here is we have shadowed the previous x
 We haven't overwritten it
 We haven't gotten rid of the previous value of x
 We've just shadowed it within this scope
 So what's going to be? Oops
 Yep
 We're good
 What's going to be the value of example zero? 84
 84? Why? Because when you do let x equal 44, it's going to be more the actual query at the top and use that value instead of when you calculate the previous value
 Yeah
 So we're going to look up what's the value of z? z is equal to x minus 2
 x in this scope is 44
 44 minus 2 times 2
 You guys didn't know you were signing up from math class
 And if we look at example zero, indeed we get 84 out
 So one of the weird things about Haskell being pure is that variables are order independent
 Since you can never change the value of a variable, once you regardless of where you set that variable, it will be true throughout the whole program
 So we say a is equal to if y then the character a otherwise b
 And then we define what y is after the fact
 This is kind of neat, but also a terrible way to write code
 Because nobody's reading it that way
 So don't do that, but you can do that
 Haskell lets you do that
 Importantly, as I mentioned in the slides, everything in Haskell is an expression
 And when we evaluate them, we're trying to find what is the value of an expression
 And this is very similar to what we do in lambda calculus, where we can just substitute functions instead of actually executing functions
 You don't execute, you just beta substitute
 Yeah
 So example one equals let
 What is a is a character
 Yeah, is the result of this expression here
 And this expression here evaluates to either a or b the characters a and b
 So if we go look at g h c i of a, it's the character value a
 Right, but it's lazy
 So you had like you put it inside of another scope
 And then you call it
 I don't know
 But like you have like the same
 Like this
 Where we're creating a scope for it
 We can chat after and kind of code around
 But that's what I mean
 Like write Haskell code and see like what happens if I do this? What happens if I do that? That exploration is definitely how you learn
 Yeah
 What do you expect it to be? Yep
 Type of a is a character
 Because it's what's the result of the expression that we just evaluated
 The expression that we just evaluated looks complicated
 It's like an if else
 But at the end of the day
 It's just the letter that is the branch that we took
 That's how we would work out the previous example
 Okay
 We've started talking about types a little bit already
 Every expression in Haskell has a type
 Those types are determined statically and checked statically
 We could have an int val variable, for example, which is an int, an int int
 That's specifically a word sized int
 So on various computers, that's either 64 or 32 bit
 And we could set it to be equal to blah, blah, blah, blah
 We could also use the integer type, which is arbitrarily large
 They have doubles, which are double precision, precision floating point
 Characters that are unicode characters
 Strings, which are just lists of strings or lists of characters
 This is kind of all your standard primitive stuff
 Nothing too fancy going on here
 But notice we aren't actually in many of these cases, actually only in this one case
 We aren't specifying what the type is
 And that's because the compiler is smart enough to figure out what the type is for you
 And that's the process that we'll talk about next week or next class
 For now, the compiler is very smart and can figure these things out
 You got lists of ints, cool, and Booleans, cool
 We use this double colon notation to specify the type
 So we're saying truth is equal to true and is of type Boolean
 We could either do it on one line or two lines
 So we could say truth is of type Boolean
 Truth is equal to true
 Either way
 Yeah, what's going to happen? What would you expect to have happened? Yeah
 Probably an error
 I'm almost certain that's going to be an error
 Yeah, it says you're trying to turn a Boolean into an integer
 So we didn't need to add the type annotations
 For example, we could have deleted that piece there
 Haskells inferring these types
 And you can inspect it with that colon T command that I showed you in GHC
 You do generally want to specify types
 Why might you want to do that? What could be a benefit of telling the compiler the type? Yeah
 Definitely
 So that if you made a mistake and you thought that you were using this type, but actually it was something else, the compiler will tell you
 Yeah
 Code changes your code pointer
 Yeah, code is not static
 Code changes a lot
 And just because you wrote a function that used to take into string, maybe you wanted to change it in the future
 And if you didn't specify it was into string, then maybe you aren't fully covering all the cases that you need to be covering when you change it
 Is it the same as JavaScript? Because in JavaScript, you also don't specify types
 We just say var x equals or let y equal
 Yeah
 Exactly
 So under the hood, Haskell is going to figure out the type
 And it's going to do type checking for you at compile time
 JavaScript is not doing that
 It has a type, but it's not really checking for you
 Okay
 We don't do implicit conversions
 If you try and add an integer and a double, what would you expect to have happen? Type error
 Plus takes integer, integer returns integer or double, double, return, double
 It does not take integer, double, return, what? Well, no
 What is it supposed to return? Is it supposed to return a double? Is it supposed to return an integer? That's unspecified
 So just don't do it
 Don't allow it
 So the compiler will tell you you can't do that
 As a result, we have some arithmetic operators such as plus and times that are overloaded
 So they allow you to use them for integers or doubles or big ints or whatever
 So if we had to type infer on iiad, what would we expect this to be? Yeah
 Int
 What about double add? Double
 How does it, I actually don't know how it represents double
 Let's give that a check
 Of double add? Yeah
 Capital D double
 There you go
 The more you know
 Yeah
 Well, what was ii? It might be that it's an integer
 Yeah, you're right
 That's an integer
 Yep
 What's the type of 33? This 33 here
 Int or integer? Yeah
 Our plus takes integer to integer to integer
 We can't mix and match our types here
 That's something that we will talk about after the midterm, after spring break even
 So that's a little ways
 Okay
 We'll talk about functions and then we're going to take quick break so we don't have to just stare at code all day
 Okay
 We represent functions as arrows
 We think about the left hand side as the input, the right hand side as the result
 So pause will take an integer and it will return a Boolean
 Greater than will take an integer
 It will then take a second integer and it will return a Boolean
 Pause could be implemented as takes x and returns x is greater than zero
 Greater than is a function that takes two parameters lambda x, y
 And it returns x is greater than y
 This probably looks very similar to, oops, that doesn't look similar to anything
 Very similar to lambda calculus
 Just imagine drawing in the little second leg to the lambda and putting a dot instead of the arrow
 And that's the lambda calculus expression
 That's by design
 Haskell-Mirids are lambda calculus nerds
 Notice we defined this function as having input in two very different ways
 One way to do it is to say the function name, then the parameter name is equal to the result
 And then here we're saying the function is equal to a function that takes two parameters and goes to x is greater than y
 How would we rewrite greater than in the same style as the pause function? What would we write? Try and write it yourself if you have your IDE up
 By the way, I highly recommend the VS Code extensions for Haskell
 They're just the simple extensions to use
 They give you great mileage
 I'm using VIM so that you don't see all of the stuff that the Haskell IDE gives you because it gives you a whole lot
 And that kind of ruins the guessing game
 Okay, so how would we rewrite greater than? We can call it greater than prime
 To instead look like the POS function
 The pause function
 So on help me out
 x is one
 Yeah, definitely
 So we can put the two parameters on the left hand side of the equals function to say greater than takes an x parameter and it takes a y parameter and it's equal to x is greater than y
 Cool
 Function application looks just like lambda calculus
 We represent it as just a space between a function name and the input
 So POS or pause 33
 That's calling the function pause on the value 33, which will evaluate to true
 In general, we talk about what do functions mean in a more mathematical sense rather than what they do
 And precisely talking about the type of a function f is from a to b
 That means that for every element a f of x is equal to y where y is of type b
 Or f of x diverges, meaning it doesn't have a good type
 So the last thing about functions right now is that we can take multiple arguments
 We just wrote a function that did that
 We'd say that it's into into into int
 It takes x, y, z
 It's equal to x times y plus c
 And these applications will happen one at a time just like in lambda calculus
 So we pass in one argument to get rid of the x, another argument to get rid of y, another argument to get rid of the z
 Okay, let's take like a two minute break so I can stop talking about coding
 If you guys have questions, feel free to ask
 Otherwise, chat or relax or something
 But just take a minute, take a breath, think about past school
 Okay
 So we have a question for the minister
 Will there be a student extended time or should we take it to the test center? Did you send a letter from the mic? Okay, then I just need send you an email
 I already have it set up
 You just need a code
 I'm going to take it to the test
 Yeah, yeah, I have the code already
 So I'll just send you a thing
 Yeah, so much
 Yeah
 Yeah
 Yeah, so I guess it depends on what you mean like life cycle wise
 Like within one execution of the program, you just can't
 You have to use y or create a new scope where you're saying x in this scope is equal to something else
 Or if you're, if you mean like between running the program, you update the code and say, now it's equal to this
 Yeah, the second time I run the code
 Yeah
 No, but you can create a new list that's equal to your old list with a new value
 And that's like what we did with the map and fold functions in JavaScript where it's like we, we never created or we never appended values
 We would call the function recursively with a new value of the list
 Yeah
 Yeah
 Yeah
 That's the lambda
 Yep
 And that basically just says like takes variable x and y and then goes to the, yep, that's the body of the function
 And then this is the parameters
 Yep
 All right
 Let's get back to Haskell
 So functions can take multiple arguments and applications happen one at a time just like in lambda calculus
 So what that means is that we could have a function add that's x to and y as parameters
 And it returns x plus y a very complicated function
 And then we could say five is equal to the result of add three and two
 Which by the way is equivalent to left parentheses add three close parentheses to so we're left associative with our applications
 Once again, just like lambda calculus
 And then we could create a function that partially applies to the ad function where we say add with the value three
 What's the type of this function? What's the type of add three? If we've only passed in one parameter to our ad function
 What are we going to get? Yeah
 Integer to integer
 Yeah
 So we're taking in one more integer and then we're going to add three to whatever that result is
 What's another way to write add three? I don't actually know what another way
 I don't know what I was thinking there
 Say if I have an idea of what's another way to write add three
 Maybe you could say add three is equal to three plus x
 That's the reasonable thing to say
 That's another way to write add three
 I don't know if that's what I meant when I wrote that question
 By the way, a very common thing to do in Haskell is to actually use the apostrophe as a way to denote a similar variable to something else that you're talking about
 It's a valid character in a name
 That's not a very common feature in the language
 Normally apostrophe is used for other things and is restricted from variable names
 But it's not here
 Yeah
 So


 something like this? Yeah
 Otherwise you don't have add two
 Add three is equal to x
 I think you would need to do a lot of parentheses to make this work
 But yeah, we could do something like that
 That's another way to write add three
 I like it
 It's creative
 So by just like design, all Haskell functions take a single argument at a time
 But you can have a function that returns another function
 So add is a function that takes a single argument, an integer, and it returns a function that takes another argument and returns an integer
 Since function typing is write associative, we don't actually need to have those parentheses
 But you can put them in if they help you
 So add four things, takes in four parameters, x, y, z, w, and it does x plus y plus z plus w plus one
 And then the type of that would be a float to a function that takes a float and returns a function that takes a float and returns a float
 In other languages, you would think about this as a function that takes four parameters
 That's not what Haskell is saying here
 Haskell allows you to pass one parameter at a time on purpose
 Okay, some more types
 We have two pulls that is like parentheses around two values to group them together or two or more values
 So we can create a two pull that's a two pull of an integer and a character
 We can create three of them, integer, character, double, create as many of these as you want
 We could then create a function called fun add that takes a two pull of integers and returns an integer
 This now looks very similar to how other programming languages take multiple arguments in one argument or in one function called
 So you can kind of replicate that if you would like to it would be very non-ideomatic for the language though, but you can do it
 Any questions on this previous part
 All right
 So here what we're saying is add three and five
 Cool
 We can create lists
 We've seen a couple of them already
 So we create my int list double prime, which is a list of one, two, three
 Nothing too crazy there
 We could also construct a list by taking the value one and adding it, pre-pending it to a list of the value two, pre-pended to a list of the value three, pre-pended to an empty list
 So this looks weird
 I feel like cons was one of the most confusing things to read when I started reading Haskell, where what we're saying is start with an empty list, add the value three to the front of it, then add the value two to the front of that, then add the value one to the front of that
 That's what this colon represents
 It takes a value and a list and it adds the value to the front of the list
 It's called cons, c-o-n-s, for construct
 So cons here is taking a list and an integer and a list of integers and it gives you back a list of integers
 Yeah
 Yeah
 What does this program type check? What's the difference between these two fun ads? Yeah, go for it
 Right
 So this fun add on the bottom takes two parameters, an integer and an integer and it returns the sum of them
 This fun add in the middle here or on top takes one parameter which is a tuple of two integers
 So it is slightly different
 Yeah
 All right
 We can concatenate lists with plus plus convenient
 That's just adding them together
 We can create empty lists
 Interestingly, an empty Boolean list is different than an empty character list, which is different than an empty string list
 So even though they might look identical, their type is different and if you tried to compare them, you would get an error
 We don't have, how do you pronounce that word, heterogeneous lists, heterogeneous lists, which is to say you can't have a list of one and two point three
 You can't have a list of one and the letter A, which is a little inconvenient, but you could create a list of two pulls potentially where they have integers and characters in them
 What it amounts to is that we have to be very explicit about the types of the things that we're working with
 Okay
 At this point, we've covered the basics of Haskell
 These are like the building blocks of every programming language that everyone has, you have functions, you have variables, you can add things, whatever
 Nothing so far has been too crazy
 Some of it's a little out there for sure, but none of it's too crazy
 Now we get into the fun stuff of Haskell
 So I want to take a pause before we do for any questions on the stuff that we've covered so far
 Yeah, so what if we didn't specify the type of myMT carlist? What's the type of myMT carlist? Yeah
 Yeah, it is like a null or undefined type in that it's a generic type
 So if we run this, we have to clean up our code
 Where was that one? It's fun add? Is that what it was? MyMT carlist, is that right? So what we get is a list of a generic A, where we're saying it's a list of something, something of type A, I don't know what it is yet
 You haven't told me anything, so I'm going to assume it's generic until you tell me otherwise, until you the programmer say, actually this is a list of characters
 Yeah, so that's what the A means
 You'll see that a couple of times
 Actually a lot
 You'll see that a lot
 Alright, so now we're going to talk about ADTs, abstract data types
 This is similar to the idea of a structure or a class in an object-oriented language, but functional, totally different
 But the same concept, where we might define a pair, where this is a type that we want to store our information in
 We're working with coordinates, for example, and we want to be able to represent something as a pair of coordinates
 So we say it's a data type
 We give it a name, so it's a pair T
 We give it a constructor, the pair C, and then we give it the type of the values that it will store
 So a pair T, the type, will store two integers
 So we're creating a new type, the pair T
 The constructor is called pair C, and then we're going to capture two integer values
 We might create a my pair, which is of type, pair T, and it's equal to the constructor with the two values we want to capture
 This syntax is definitely a little weird to read, and something that students often struggle with as they foresee it, so don't worry too much
 The thing to remember is the constructor is like a separate value on this type, and then everything after the constructor tells you what it actually stores
 So we're actually storing 3, 4
 Another, if we wanted to come up with another type, we could call this the point type
 We could have a Cartesian constructor that takes two doubles, and we could have a polar constructor that takes two doubles
 So now there are two different ways to create a point
 We can either create Cartesian points or polar points, and then we can immediately do that
 We can say point 1 and point 2 are both points
 Point 1 is a Cartesian point with the value 3
3, 2
2, and point 2 is a polar point with the value 0
1 and 3
1
 We can also create just like kind of an enum-like data type color, which can be red, green, blue, and to go violet, and then we can create a value of type color where we say red is equal to red
 My red is equal to red
 What does the polar, and then under Cartesian points? Yeah, what's this symbol here, this or this vertical bar, that's saying this is another way to create a type
 So we have two constructors
 Sometimes you'll see it like this as well
 You have two different paths to take if you want to construct a point
 Two different constructors
 Yeah
 Great question
 How do we access the values inside once we've captured them in this point? So let's write a function that actually uses one of these
 I don't like these examples
 Let's rewrite a function
 So we have point 1
2, and we want to have a get x function
 The goal of this should be that it gets the x value of a Cartesian point
 So what we can do is we know that this takes a point
 We can actually write the type of it to be point to what? What's the return type of get x? Yeah
 Double
 Great
 So get x is going to take a point
 And one of the most powerful things from a programmer's perspective that we can do in Haskell is we can actually break down a complex type into its parts
 And we can say get x is a function that takes a point
 And we can break that point apart and say when it's a Cartesian point, turn it into Cartesian xy return x
 And then otherwise
 I don't know
 What do we want to do with polar points? We would have to decide on something
 But when we take in a Cartesian point, we can break it down into its pieces to access the x in the y value
 And maybe on polar points, it's like our theta, right? Or
 Nope
 Wrong
 Maybe we have a two get x prime of two Cartesian of, well, actually
 This is probably what we would write
 So when we can match on a Cartesian point, we will, and we will extract out the x
 Otherwise, what we will do is call get x recursively on converting the point to a Cartesian point
 However, in order to do that, we need to define two Cartesian, which will be of what type? Based on how we're using it
 Someone shouted out
 It's not polar
 Polars, the constructor here
 What's the type? It's a point to what? Point
 It takes a point, or it turns a point
 But notably, what it will do is it will take a polar, our theta, and it will return a Cartesian, whatever the hell the math is here
 I don't know
 Well, it will run that
 I think it's actually down below
 I think I have the same thing
 Yeah
 Ha ha
 It will return a new Cartesian point of calculate whatever our value of x and y are
 And then we will get back to our original get x, where we call get x with our newly Cartesian point
 Other questions on this piece here
 This is like starting to actually write Haskell now
 We're not just kind of at the baby step stage
 Yeah, so here we didn't define the second line, which means that we only had it defined on polar points
 So what would happen if you gave it a Cartesian point? Well, it would error
 It wouldn't have the way to handle that
 Which means the compiler is actually going to get mad at us if we ignore this line
 We do actually have to have all of our cases covered for handling a point
 We can't just handle the polar and not handle the Cartesian
 This is a little bit of a counterintuitive feature of Haskell
 If we swap the orders of that line, of those two lines, what happens? Previously we've said due to laziness and purity, order doesn't matter
 If we say y equals true at the end of our file, that's the same as saying at the start of the file
 This is actually an exception to that
 When we are writing functions, the order that we define our parameters in, it's kind of like an if- else- else- else- or if- else- else- else- where we're checking this first one, do we pattern match on this first version of the function? If yes, do this
 If no, try the second one
 If we have it in the reverse order, we will always pattern match on that first one and never actually run this second line of code
 Order of your function declarations does matter for pattern matching
 It depends on your linter
 My hunch is it will give you a warning
 Yeah
 All right
 We'll pick back up with more Haskell on Wednesday
 Yeah, what's up? How do we define it as a true vote? Can we just change the type in it? Nope
 Nope
 Well, you could get rid of it like you had to delete that, but you can't change the type
 Or can we change the last of the two of us? Nope
 Nope
 You can't change the length of a list either
 You can create a new list that has a longer length, but you can't like change the length of the list
 So all the properties can change it all
 Right
 No changing anywhere
 What's up? I don't know if you said this already
 It's like a neutral choice or answer
 A little bit about it
 Yeah
 It'll be some multiple choice, some like true false, some free response
 Yep
 Oh, it's very clearly these two lines
 Yep
 What does it, what does this line mean? So what we're saying here is take a point, convert it to Cartesian, and then call get x
 So converting it to Cartesian means we're going to call this function, which is going to check if it's a polar point, and turn it into a Cartesian version of the point, and then call get x on the Cartesian version
 When we call the Cartesian version, when we call get x with a Cartesian point, then we're going to match on this first version, and we're going to be able to extract that x value
 So this one is a one function, right? That's right
 That's one function
 Yeah
 So this is like if it's


 So the one function point, do this first line, else do this second
 And do we need to write these two lines into each other? No, no, you don't
 I don't think so
 Yeah, we could kind of put those wherever we want
 Uh


 So super quick, when is office hours? Right now
 I'm headed over there as we speak
 Okay, it's in the CS building
 Yep
 4224
 4224, right? Yeah, so we could put like


 I think we can do this
 Although


 Let's just


 What? What? Duplicate type 6 integers? Do I already have those? Is it mad because I've already


 Yeah, I've already declared those ones too
 Yeah
 Duplicate
 Duplicate
 Duplicate
 On that one as well, we have to give that a new name
 Okay
 So, no, no, no
 It's mad at us for splitting it up, I think
 So I think


 Yeah
 Yeah, it's mad at


 So you can't split it up as much as you want
 You can


 You have to keep them together a little bit
 Yeah, well
 You