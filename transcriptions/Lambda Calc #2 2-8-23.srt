1
00:00:30,000 --> 00:00:38,620
All right.

2
00:00:38,620 --> 00:00:41,200
Let's get going.

3
00:00:41,200 --> 00:00:51,140
So as I like to do, starting with a little bit of news, is there, like, I sound louder

4
00:00:51,140 --> 00:00:52,140
to myself.

5
00:00:52,140 --> 00:00:53,960
Do I sound louder to you guys?

6
00:00:53,960 --> 00:00:54,960
No?

7
00:00:54,960 --> 00:00:55,960
Maybe that's just me.

8
00:00:55,960 --> 00:00:57,060
All right.

9
00:00:57,060 --> 00:01:04,480
There was an interesting post end of January, so a little bit ago, about Rust in business.

10
00:01:04,480 --> 00:01:09,360
A lot of people ask, like, okay, we're learning these languages, Haskell, Rust, JavaScript

11
00:01:09,360 --> 00:01:11,440
I think is pretty easy to justify.

12
00:01:11,440 --> 00:01:14,680
But do these other languages have an option?

13
00:01:14,680 --> 00:01:17,340
Especially if I'm going to an established company.

14
00:01:17,340 --> 00:01:19,760
And the answer is definitely yes.

15
00:01:19,760 --> 00:01:23,120
So AWS does a lot of Rust.

16
00:01:23,120 --> 00:01:29,520
If you've heard about Lambda, AWS Lambda, that is run entirely on a Rust service called

17
00:01:29,520 --> 00:01:32,080
Firecracker.

18
00:01:32,080 --> 00:01:39,360
Google is using Rust in Android and Chromium, as well as some of their other products.

19
00:01:39,360 --> 00:01:44,760
Huawei is using it for their operating system stuff as well.

20
00:01:44,760 --> 00:01:47,560
Facebook is using Rust for blockchain.

21
00:01:47,560 --> 00:01:50,000
Microsoft is using Rust.

22
00:01:50,000 --> 00:01:54,200
It's just every big company that you know is now using Rust.

23
00:01:54,200 --> 00:02:01,180
They're migrating away from languages like C and C++ and using Rust when they can.

24
00:02:01,180 --> 00:02:06,600
Other kind of also big companies, but maybe less well known, Shopify is huge.

25
00:02:06,600 --> 00:02:11,920
They're using Rust not as a language for their service, but as a language to compile their

26
00:02:11,920 --> 00:02:13,220
other language.

27
00:02:13,220 --> 00:02:15,520
So they use Ruby for everything.

28
00:02:15,520 --> 00:02:20,360
But they need a good Ruby compiler, so they wrote that in Rust.

29
00:02:20,360 --> 00:02:23,640
Then there are, like, a bunch of startups using Rust.

30
00:02:23,640 --> 00:02:24,640
Everybody's using Rust.

31
00:02:24,640 --> 00:02:26,040
Rust all over the place.

32
00:02:26,040 --> 00:02:27,040
Great.

33
00:02:27,040 --> 00:02:28,400
So people are using it.

34
00:02:28,400 --> 00:02:29,720
It's worth learning.

35
00:02:29,720 --> 00:02:33,580
It's also worth learning just because it's fun.

36
00:02:33,580 --> 00:02:38,740
That's the news for the day.

37
00:02:38,740 --> 00:02:39,740
Some notes.

38
00:02:39,740 --> 00:02:40,740
PA2.

39
00:02:40,740 --> 00:02:44,300
There is a deadline extension.

40
00:02:44,300 --> 00:02:46,460
This is just the programming assignment.

41
00:02:46,460 --> 00:02:48,600
Homework is still due at the normal time.

42
00:02:48,600 --> 00:02:50,660
Early deadline is still the same time.

43
00:02:50,660 --> 00:02:55,340
Programming assignment 2 makes use of ideas that we're gonna be talking about next week.

44
00:02:55,340 --> 00:02:57,340
So I'm giving you some more time to do it.

45
00:02:57,340 --> 00:03:03,340
You can probably figure it out, but it'll be easier after Monday's lecture in particular.

46
00:03:03,340 --> 00:03:04,380
Next Monday's lecture.

47
00:03:04,380 --> 00:03:08,380
So one week extension on the hard deadline.

48
00:03:08,380 --> 00:03:10,340
The early deadline is still tomorrow.

49
00:03:10,340 --> 00:03:14,660
So if you want the bonus points, do it this week.

50
00:03:14,660 --> 00:03:17,540
But getting 100% is good.

51
00:03:17,540 --> 00:03:18,540
It's good enough.

52
00:03:18,540 --> 00:03:20,540
So if you want to wait, wait.

53
00:03:20,540 --> 00:03:22,260
Either way is fine.

54
00:03:22,260 --> 00:03:25,340
PA3, though, is still due at the same time.

55
00:03:25,340 --> 00:03:29,060
So we aren't pushing all programming assignments back.

56
00:03:29,060 --> 00:03:30,300
It's just this one assignment.

57
00:03:30,300 --> 00:03:36,180
That means if you don't do PA2 this week, you have to do PA2 and PA3 next week.

58
00:03:36,180 --> 00:03:38,900
PA3 is also JavaScript.

59
00:03:39,460 --> 00:03:41,500
Lastly, programming is hard.

60
00:03:41,500 --> 00:03:44,980
A lot of you might not have worked with JavaScript very much before.

61
00:03:44,980 --> 00:03:48,060
If you're having trouble, come stop by office hours.

62
00:03:48,060 --> 00:03:51,180
Start early so that you know what you're not understanding.

63
00:03:51,180 --> 00:03:52,340
And come ask questions.

64
00:03:52,340 --> 00:03:53,860
We're here to help.

65
00:03:53,860 --> 00:03:59,020
The point of this class is not that I'm trying to teach you how to write perfect JavaScript.

66
00:03:59,020 --> 00:04:01,480
That's the point of the programming assignment.

67
00:04:01,480 --> 00:04:06,140
So I'm not gonna spend lecture time saying here's how we write JavaScript.

68
00:04:06,140 --> 00:04:08,020
That's something that you have to figure out.

69
00:04:08,020 --> 00:04:11,340
And so if you're having a hard time with that, come chat.

70
00:04:11,340 --> 00:04:15,020
Because that's where we can help you.

71
00:04:15,020 --> 00:04:16,020
Those are the notes.

72
00:04:16,020 --> 00:04:17,020
Any other questions...

73
00:04:17,020 --> 00:04:20,980
Or any questions on this stuff?

74
00:04:20,980 --> 00:04:28,380
Before we go to LambdaCalc?

75
00:04:28,380 --> 00:04:30,980
How many people have finished PA2 already?

76
00:04:30,980 --> 00:04:31,980
Okay.

77
00:04:31,980 --> 00:04:32,980
A few.

78
00:04:32,980 --> 00:04:33,980
Not too many.

79
00:04:33,980 --> 00:04:34,980
How many people have started?

80
00:04:34,980 --> 00:04:35,980
Oh, almost everybody.

81
00:04:35,980 --> 00:04:36,980
Great.

82
00:04:36,980 --> 00:04:40,340
Okay.

83
00:04:40,340 --> 00:04:44,580
That's much better than UCSD.

84
00:04:44,580 --> 00:04:46,020
There was a different culture there.

85
00:04:46,020 --> 00:04:47,020
Okay.

86
00:04:47,020 --> 00:04:51,540
So we're going to jump into LambdaCalc again.

87
00:04:51,540 --> 00:04:53,820
We started last time, we looked at syntax.

88
00:04:53,820 --> 00:04:57,420
And we said what does a LambdaCalculus program look like?

89
00:04:57,420 --> 00:05:01,180
And then towards the end of class, we started evaluating those programs.

90
00:05:01,180 --> 00:05:06,580
I want to start right where we left off of saying let's evaluate LambdaCalculus programs.

91
00:05:07,180 --> 00:05:09,620
So we're going to do these three problems.

92
00:05:09,620 --> 00:05:11,380
I believe they're new, right?

93
00:05:11,380 --> 00:05:12,620
We didn't do these three last time.

94
00:05:12,620 --> 00:05:14,140
This is where we ended.

95
00:05:14,140 --> 00:05:15,140
All right.

96
00:05:15,140 --> 00:05:17,660
So take two minutes.

97
00:05:17,660 --> 00:05:20,960
Try and work these out on your own or with somebody next to you.

98
00:05:20,960 --> 00:05:25,660
And then we'll go over them as a class.

99
00:06:25,660 --> 00:06:37,020
All right.

100
00:06:37,020 --> 00:06:41,620
It sounds pretty quiet, so I think that means that you guys are ready to go.

101
00:06:41,620 --> 00:06:44,340
Let's start off with this one.

102
00:06:44,340 --> 00:06:46,460
Who can give me first step?

103
00:06:46,460 --> 00:06:49,460
What do we want to do to start this problem?

104
00:06:49,460 --> 00:06:51,460
Yeah.

105
00:06:52,060 --> 00:06:55,900
Assign 3 to Y.

106
00:06:55,900 --> 00:07:01,500
So we're taking this 3 and we're passing it into the function LambdaY.2.

107
00:07:01,500 --> 00:07:02,620
Y is the parameter.

108
00:07:02,620 --> 00:07:03,940
So we'll have 3.

109
00:07:03,940 --> 00:07:04,940
Sure.

110
00:07:04,940 --> 00:07:20,860
So that's going to look something like LambdaX.2, where Y is equal to 3 of 5, right?

111
00:07:20,860 --> 00:07:21,940
That's what you meant?

112
00:07:21,940 --> 00:07:30,820
So we're going to say Y is equal to 3, and then we get the body of the function returned.

113
00:07:30,820 --> 00:07:32,980
What can we do from here?

114
00:07:32,980 --> 00:07:34,580
Sure.

115
00:07:34,580 --> 00:07:38,500
We can assign 5 to X.

116
00:07:38,500 --> 00:07:41,060
So we do the same process.

117
00:07:41,060 --> 00:07:42,740
Put 5 in for X.

118
00:07:42,820 --> 00:07:59,980
We get 2, where Y is equal to 3 and X is equal to 5.

119
00:07:59,980 --> 00:08:03,380
Any questions on the two steps that we've taken here?

120
00:08:03,380 --> 00:08:06,900
Because we went kind of all at once through it.

121
00:08:06,900 --> 00:08:07,900
Yeah?

122
00:08:07,900 --> 00:08:18,020
Can you explain the order of the Lambda function?

123
00:08:18,020 --> 00:08:19,020
Yeah.

124
00:08:19,020 --> 00:08:21,540
So we took a specific approach here.

125
00:08:21,540 --> 00:08:24,700
We passed 3 in for Y first.

126
00:08:24,700 --> 00:08:29,900
Could we have passed 5 in for X first instead?

127
00:08:29,900 --> 00:08:31,020
I'm seeing a lot of nodding.

128
00:08:31,020 --> 00:08:32,580
Yeah, we could have.

129
00:08:32,580 --> 00:08:38,900
We chose to do 3 goes in for Y, but we could have done it in the other order.

130
00:08:38,900 --> 00:08:44,140
And what would we have gotten if we went that way?

131
00:08:44,140 --> 00:08:45,700
It would have been the same thing.

132
00:08:45,700 --> 00:08:50,780
We would have had different intermediary steps, but we would end up with 2, where Y is 3 and

133
00:08:50,780 --> 00:08:52,700
X is 5.

134
00:08:52,700 --> 00:08:53,940
Yeah.

135
00:08:54,860 --> 00:09:04,180
We'll talk more about order towards the end of class.

136
00:09:04,180 --> 00:09:06,980
Other questions on this part?

137
00:09:06,980 --> 00:09:09,980
All right.

138
00:09:09,980 --> 00:09:19,740
Let's do the other side.

139
00:09:19,740 --> 00:09:20,740
What should we do here?

140
00:09:20,740 --> 00:09:21,740
Yeah?

141
00:09:22,740 --> 00:09:26,740
That second 2, I believe, is a 3 on the 4th.

142
00:09:26,740 --> 00:09:31,740
I believe you.

143
00:09:31,740 --> 00:09:38,740
3 gets passed to the X.

144
00:09:38,740 --> 00:09:43,220
We can look at this whole piece here as a function.

145
00:09:43,220 --> 00:09:47,860
And the 3 is the argument to the outer part of the function, the X.

146
00:09:47,980 --> 00:09:56,780
We get lambda Y dot 2, where X is equal to 3, 5.

147
00:09:56,780 --> 00:10:03,020
What can we do now?

148
00:10:03,020 --> 00:10:04,220
Pass 5 for the Y.

149
00:10:04,220 --> 00:10:13,460
And what we get at the end is we have 2 remaining, and X is equal to 3, Y is 5.

150
00:10:13,460 --> 00:10:15,660
I hate writing 5s.

151
00:10:15,780 --> 00:10:18,100
I don't know why.

152
00:10:18,100 --> 00:10:19,220
OK.

153
00:10:19,220 --> 00:10:22,460
So we get 2, Y is 3, X is 5.

154
00:10:22,460 --> 00:10:24,980
That leaves us with this last question.

155
00:10:24,980 --> 00:10:27,820
Are these two equivalent?

156
00:10:27,820 --> 00:10:29,100
And we can put those up.

157
00:10:35,380 --> 00:10:37,420
Yes?

158
00:10:37,420 --> 00:10:39,580
No?

159
00:10:39,580 --> 00:10:40,300
No.

160
00:10:40,300 --> 00:10:41,820
Why are they not equivalent?

161
00:10:46,340 --> 00:10:50,380
Yeah, the variables are different.

162
00:10:50,380 --> 00:10:52,940
On one side, we had X is 3, Y is 5.

163
00:10:52,940 --> 00:10:55,180
On the other side, Y is 3, X is 5.

164
00:10:55,180 --> 00:10:56,900
Our state is different.

165
00:10:56,900 --> 00:11:02,380
We ended up with the same final expression result, but the state that goes with that

166
00:11:02,380 --> 00:11:04,580
result is different.

167
00:11:04,580 --> 00:11:10,180
This is very similar to in closures, or in JavaScript with closures, where two functions

168
00:11:10,180 --> 00:11:17,180
might look identical, but the state that's going with them is different.

169
00:11:17,180 --> 00:11:21,540
OK.

170
00:11:21,540 --> 00:11:23,000
Let's do another one.

171
00:11:23,000 --> 00:11:24,000
Take a minute.

172
00:11:24,000 --> 00:11:28,180
Do this on your own.

173
00:11:28,180 --> 00:11:34,220
The more of these that you do, the better, more efficient, and easily they will come

174
00:11:34,220 --> 00:11:35,300
to you.

175
00:12:04,220 --> 00:12:29,380
What is state?

176
00:12:29,380 --> 00:12:34,140
What is state?

177
00:12:34,140 --> 00:12:38,300
State is the representation of the environment.

178
00:12:38,300 --> 00:12:51,340
So when we say, like, solve X plus Y, if you don't tell me what X is or what Y is, I can't

179
00:12:51,340 --> 00:12:53,060
solve this problem.

180
00:12:53,060 --> 00:13:01,260
I need some environment, some state, where I say X is 3 and Y is 2 in order to actually

181
00:13:01,260 --> 00:13:10,580
solve for this equation.

182
00:13:10,580 --> 00:13:12,380
That's a way of thinking of it.

183
00:13:12,380 --> 00:13:17,220
You can kind of reframe it as the arguments to the expression.

184
00:13:17,220 --> 00:13:23,940
But think about when you write code and you assign variables to your...

185
00:13:23,940 --> 00:13:29,140
As you're writing code, when you execute, those variables accumulate information over

186
00:13:29,140 --> 00:13:30,140
time.

187
00:13:30,140 --> 00:13:31,140
They update.

188
00:13:31,140 --> 00:13:36,020
That's the state of your program.

189
00:13:36,020 --> 00:13:38,980
Yeah.

190
00:13:38,980 --> 00:13:42,660
OK.

191
00:13:42,660 --> 00:13:46,260
Let's reduce this expression here.

192
00:13:46,260 --> 00:13:55,900
How should we start?

193
00:13:55,900 --> 00:13:56,900
A is 7.

194
00:13:56,900 --> 00:13:57,900
Yeah.

195
00:13:57,900 --> 00:14:02,660
So we'll take this 7 and substitute it in for this parameter A here.

196
00:14:02,660 --> 00:14:13,340
And we'll be left with lambda X dot X plus A of 4, where A is equal to 7.

197
00:14:13,340 --> 00:14:16,220
Great.

198
00:14:16,220 --> 00:14:19,580
What next?

199
00:14:19,580 --> 00:14:20,580
X is 4.

200
00:14:20,580 --> 00:14:22,420
We can pass in this 4 for X.

201
00:14:22,420 --> 00:14:28,660
We'll get X plus A, where our state is A is 7.

202
00:14:28,660 --> 00:14:30,620
And X is 4.

203
00:14:30,620 --> 00:14:31,620
Great.

204
00:14:31,620 --> 00:14:33,580
So when we solve it, we get 11.

205
00:14:33,580 --> 00:14:41,660
When we actually plug in our variables, we get 11.

206
00:14:41,660 --> 00:14:42,660
How did this one go?

207
00:14:42,660 --> 00:14:44,700
Any questions?

208
00:14:44,700 --> 00:14:50,340
Anything arise as you were solving it?

209
00:14:50,340 --> 00:15:04,340
Is it wrong to apply the 4 to the X first, and then 7 to A?

210
00:15:04,340 --> 00:15:10,340
Is it wrong to do 4 goes into X, and then 7 goes into A?

211
00:15:10,340 --> 00:15:11,340
No.

212
00:15:11,340 --> 00:15:12,340
No.

213
00:15:12,340 --> 00:15:13,340
That's totally fine.

214
00:15:13,340 --> 00:15:14,340
That's the way to solve this problem.

215
00:15:14,340 --> 00:15:15,340
Will the 2 always result in the same?

216
00:15:15,340 --> 00:15:16,340
No.

217
00:15:16,340 --> 00:15:17,340
No.

218
00:15:17,340 --> 00:15:18,340
But almost always.

219
00:15:18,340 --> 00:15:19,340
OK.

220
00:15:19,340 --> 00:15:20,340
Yeah.

221
00:15:20,340 --> 00:15:27,300
So 4, you'll be able to recognize when they won't.

222
00:15:27,300 --> 00:15:31,220
So in general, you can always say they will reduce to the same thing.

223
00:15:31,220 --> 00:15:32,220
Yeah.

224
00:15:32,220 --> 00:15:39,380
But we'll cover a case where they don't in the end of class.

225
00:15:39,380 --> 00:15:43,900
So what we could do is we could substitute in the 4 for the X. That's actually the way

226
00:15:43,900 --> 00:15:45,940
I have it in the slides.

227
00:15:45,940 --> 00:15:50,740
7 for the A. Get 11.

228
00:15:50,740 --> 00:15:55,180
All right.

229
00:15:55,180 --> 00:16:18,300
What about this one?

230
00:16:48,300 --> 00:17:01,940
I missed a thing here.

231
00:17:01,940 --> 00:17:03,340
What should we do first here?

232
00:17:03,340 --> 00:17:04,340
Yeah.

233
00:17:04,340 --> 00:17:13,820
Why A plus 5 to the X depends on the date that A, one of the A's to a K.

234
00:17:13,820 --> 00:17:16,060
Let's cover that second part later.

235
00:17:16,060 --> 00:17:17,060
But yes.

236
00:17:17,220 --> 00:17:26,020
We're going to apply A plus 5 to X. So we will, following the same algorithm that we've

237
00:17:26,020 --> 00:17:35,780
been using, X plus A of 7, where X is equal to A plus 5.

238
00:17:35,780 --> 00:17:40,660
All right.

239
00:17:40,660 --> 00:17:43,660
Now what do we do?

240
00:17:44,380 --> 00:17:47,380
A is 7.

241
00:17:47,380 --> 00:17:48,380
All right.

242
00:17:48,380 --> 00:17:55,860
So we get X plus A, where X is equal to A plus 5, and A equals 7.

243
00:17:55,860 --> 00:17:59,540
Now when we try to solve this, we can say, okay, X is equal to A plus 5.

244
00:17:59,540 --> 00:18:03,140
So A plus 5, gosh.

245
00:18:03,140 --> 00:18:05,660
Plus A. A is 7.

246
00:18:05,660 --> 00:18:07,660
So we get 1419.

247
00:18:07,660 --> 00:18:08,660
Yeah.

248
00:18:08,660 --> 00:18:18,300
Yeah, so is there no scope?

249
00:18:18,300 --> 00:18:24,900
This A here is, like, these guys are clearly connected.

250
00:18:24,900 --> 00:18:27,500
But what's the deal with this A?

251
00:18:27,500 --> 00:18:36,820
Is that A the same A as this A?

252
00:18:36,820 --> 00:18:38,700
Does it need to be evaluated first?

253
00:18:38,700 --> 00:18:44,780
Could we have substituted in the 7 first and then maybe avoided this whole headache?

254
00:18:44,780 --> 00:19:01,340
If we solve it the alternative way, and we do lambda X dot A plus A dot 7.

255
00:19:01,340 --> 00:19:15,300
If we plug in 7 first for A, and we get 7 plus X, and then we sub in our A plus 5 for

256
00:19:15,300 --> 00:19:27,860
X, we get a very different answer than what we got before.

257
00:19:27,860 --> 00:19:34,860
Instead of 19, which is what we got last time, this time we get 12 plus A.

258
00:19:34,860 --> 00:19:39,160
Now there was a previous question about, does order matter?

259
00:19:39,160 --> 00:19:42,620
So here we're seeing order made a difference.

260
00:19:42,620 --> 00:19:46,100
And my answer before was that it shouldn't make a difference, except in a very specific

261
00:19:46,100 --> 00:19:47,100
case.

262
00:19:47,100 --> 00:19:48,700
This is not that specific case.

263
00:19:48,700 --> 00:19:51,900
Something went wrong here.

264
00:19:51,900 --> 00:19:56,420
What we wanted to get, what we should get, is 12 plus A.

265
00:19:56,420 --> 00:20:09,300
But in the other method, going the other way, we got 19.

266
00:20:09,300 --> 00:20:13,780
A couple of you have already pointed out, maybe this is a scoping issue.

267
00:20:13,780 --> 00:20:21,860
Maybe it's because we somehow captured the second A in our inner A. And that's the right

268
00:20:21,860 --> 00:20:22,860
intuition.

269
00:20:22,860 --> 00:20:26,100
So let's play that out.

270
00:20:26,100 --> 00:20:29,620
This is...

271
00:20:29,620 --> 00:20:32,780
We kind of already answered that one.

272
00:20:32,780 --> 00:20:38,380
So what we find is that substitution is actually a little bit more complicated than what we

273
00:20:38,380 --> 00:20:39,380
thought.

274
00:20:39,380 --> 00:20:43,420
It's not just that we can take a term as an argument and pass it in.

275
00:20:43,420 --> 00:20:49,460
If we do that, we might end up with this case, where we're passing in A plus 5, and then

276
00:20:49,460 --> 00:20:56,820
somehow it gets lost inside.

277
00:20:56,820 --> 00:21:06,140
We say that in this case, the A has been captured by an inner scope.

278
00:21:06,140 --> 00:21:16,080
And we'll come back to the kind of description of this and the notation in a minute.

279
00:21:16,080 --> 00:21:17,660
Example to do at home.

280
00:21:17,660 --> 00:21:18,660
Example to do at home.

281
00:21:18,860 --> 00:21:26,860
All right.

282
00:21:26,860 --> 00:21:28,580
I like this other one more.

283
00:21:28,580 --> 00:21:29,580
Let's look at this one.

284
00:21:29,580 --> 00:21:34,500
So one way to see this same problem is in JavaScript.

285
00:21:34,500 --> 00:21:38,580
We might have a function that takes a variable X.

286
00:21:38,580 --> 00:21:48,620
And as the first line of that function, we're going to print out the value A plus 5.

287
00:21:48,620 --> 00:21:57,240
What is the value of A at the start of that function, when we're printing A plus 5?

288
00:21:57,240 --> 00:22:14,900
What's the value of A?

289
00:22:14,900 --> 00:22:15,900
Would it work?

290
00:22:15,900 --> 00:22:19,940
All right.

291
00:22:19,940 --> 00:22:20,940
Fair enough.

292
00:22:20,940 --> 00:22:21,940
Yeah.

293
00:22:21,940 --> 00:22:26,260
A is undefined at this point.

294
00:22:26,260 --> 00:22:29,620
Or maybe it is defined, but, you know, it's, like, defined up...

295
00:22:29,620 --> 00:22:31,260
Can you guys see my cursor?

296
00:22:31,260 --> 00:22:32,260
No.

297
00:22:32,260 --> 00:22:33,380
It's, like, defined up top.

298
00:22:33,380 --> 00:22:34,620
So if we said...

299
00:22:34,620 --> 00:22:42,620
If we had a...

300
00:22:42,620 --> 00:22:50,060
If we have somewhere in an outer scope, let A equal something, then we'll use whatever

301
00:22:50,060 --> 00:22:55,860
value that is.

302
00:22:55,860 --> 00:23:03,420
When we then create a new function that takes a parameter A, and we log A plus X, and we're

303
00:23:03,420 --> 00:23:11,100
calling that with the value A plus 5, what are all of these different values of A?

304
00:23:11,100 --> 00:23:14,180
This A here, this A...

305
00:23:14,180 --> 00:23:15,180
What's that A?

306
00:23:15,180 --> 00:23:16,180
Yeah?

307
00:23:16,180 --> 00:23:30,540
This A?

308
00:23:30,540 --> 00:23:31,540
Is that the parameter?

309
00:23:31,540 --> 00:23:35,860
I mean, it's, like, the argument to this function.

310
00:23:35,860 --> 00:23:38,100
Yeah.

311
00:23:38,100 --> 00:23:44,980
Yeah, it's the same A that we were initially doing a console log with.

312
00:23:44,980 --> 00:23:53,140
It's the outer scoped A. Then we have the A as the parameter.

313
00:23:53,140 --> 00:23:55,980
What's the value of that A?

314
00:23:55,980 --> 00:23:57,660
I wish these had line numbers.

315
00:23:57,660 --> 00:23:59,740
On line 4 from the top.

316
00:23:59,740 --> 00:24:00,740
Yeah?

317
00:24:00,740 --> 00:24:03,500
The outer scoped A from 5?

318
00:24:03,500 --> 00:24:04,500
Yeah.

319
00:24:04,500 --> 00:24:08,460
It'll be whatever the result of this expression is.

320
00:24:08,460 --> 00:24:10,380
All right?

321
00:24:10,380 --> 00:24:15,660
And lastly, what is this A?

322
00:24:15,660 --> 00:24:21,020
Yeah.

323
00:24:21,020 --> 00:24:23,020
It's the same A that we just talked about.

324
00:24:23,020 --> 00:24:29,380
The one before the equal sign, which is equal to the value of this A plus 5.

325
00:24:29,380 --> 00:24:36,020
So we have two different A's here, and we don't want to get them mixed up.

326
00:24:36,020 --> 00:24:39,700
This inner A is a different A than the outer A.

327
00:24:40,020 --> 00:24:42,380
The same goes for lambda calculus.

328
00:24:42,380 --> 00:24:51,060
So this function here has its own scope, and this A is equivalent to this A, but not equivalent

329
00:24:51,060 --> 00:24:57,940
to this A. This is an outer scoped A that we don't know what its value is.

330
00:24:57,940 --> 00:25:05,120
This is a defined A. It's a captured A, or bound A.

331
00:25:05,120 --> 00:25:11,320
So we don't want to mix them up.

332
00:25:11,320 --> 00:25:18,580
Here's another way to write that same idea.

333
00:25:18,580 --> 00:25:23,980
The outer function references an A that it doesn't necessarily define itself.

334
00:25:23,980 --> 00:25:25,900
It's from someone else.

335
00:25:25,900 --> 00:25:34,300
But then the inner function captures, or binds, the A as its parameter.

336
00:25:34,300 --> 00:25:37,900
OK.

337
00:25:37,900 --> 00:25:38,900
How can we fix this?

338
00:25:38,900 --> 00:25:39,900
Oh, yeah?

339
00:25:39,900 --> 00:25:46,780
Can't we just use subscripts and be done with it?

340
00:25:46,780 --> 00:25:47,780
How?

341
00:25:47,780 --> 00:25:58,820
Yeah, so give this one A1, that one A1, that one A2.

342
00:25:58,820 --> 00:26:01,340
Yeah, that's a fine idea.

343
00:26:01,340 --> 00:26:05,320
So what happens if we...

344
00:26:05,320 --> 00:26:11,640
I wish that this were actual code instead.

345
00:26:11,640 --> 00:26:18,080
So using the same A1 and A2 to reference A1 and A2.

346
00:26:18,080 --> 00:26:20,080
What happens if we do this?

347
00:26:20,080 --> 00:26:22,880
Is that readable?

348
00:26:22,880 --> 00:26:24,520
Kind of.

349
00:26:24,520 --> 00:26:27,200
That's good enough.

350
00:26:27,200 --> 00:26:31,200
So rename them with subscripts.

351
00:26:31,200 --> 00:26:40,200
What's gonna happen?

352
00:26:40,240 --> 00:26:42,240
Does it solve our problem?

353
00:26:42,240 --> 00:26:50,800
Yeah, in fact, A2 is not defined at all.

354
00:26:50,800 --> 00:26:57,640
We defined A outside, but A2 nobody's talking about.

355
00:26:57,640 --> 00:26:59,260
That's definitely undefined.

356
00:26:59,260 --> 00:27:07,920
So we will still run into a different problem when we rename this A to be A2.

357
00:27:07,920 --> 00:27:09,160
We've done something illegal.

358
00:27:09,160 --> 00:27:13,880
We've changed the name of a variable we don't control.

359
00:27:13,880 --> 00:27:19,000
It's definitely fine to call this one A1, because we control that variable.

360
00:27:19,000 --> 00:27:22,720
We control all the scoped references of it.

361
00:27:22,720 --> 00:27:24,880
This one we don't control.

362
00:27:24,880 --> 00:27:30,220
We can't change the name of.

363
00:27:30,220 --> 00:27:31,220
Which is...

364
00:27:31,220 --> 00:27:36,160
It leads perfectly into how we will fix this problem.

365
00:27:36,160 --> 00:27:40,920
So what we're gonna do is we're going to rename our variables.

366
00:27:40,920 --> 00:27:45,480
But we have to have a rule about which variables we're allowed to rename.

367
00:27:45,480 --> 00:27:49,440
Because we don't want to end up in the situation where we rename a variable that we didn't

368
00:27:49,440 --> 00:27:57,000
control and now we can't reference the variable that we wanted to reference.

369
00:27:57,000 --> 00:27:59,800
So if we have...

370
00:27:59,800 --> 00:28:05,880
This is the same problem that I was showing with JavaScript, but it's just in Haskell

371
00:28:05,880 --> 00:28:07,440
instead.

372
00:28:07,440 --> 00:28:08,440
Which we haven't covered yet.

373
00:28:08,440 --> 00:28:16,600
But the idea is the same, where we say X is equal to A plus 5, and A is 7 in X plus A.

374
00:28:16,600 --> 00:28:21,880
So we can do a renaming, a dumb renaming.

375
00:28:21,880 --> 00:28:24,760
Or a renaming and then the dumb substitution.

376
00:28:24,760 --> 00:28:25,760
Where we say...

377
00:28:25,760 --> 00:28:26,760
Okay.

378
00:28:26,760 --> 00:28:28,560
This A, we control.

379
00:28:28,560 --> 00:28:35,720
We can change that A without changing the outer A.

380
00:28:35,720 --> 00:28:41,640
And then once we do the substitution, we get the expected result.

381
00:28:41,640 --> 00:28:48,620
All right.

382
00:28:48,620 --> 00:28:54,320
So I'm arguing this will work so long as we know what variables we can and which variables

383
00:28:54,320 --> 00:28:59,600
we cannot rename.

384
00:28:59,600 --> 00:29:02,280
The reason we're going to be doing it this way...

385
00:29:02,440 --> 00:29:03,600
Or I guess...

386
00:29:03,600 --> 00:29:06,880
What are we exactly doing?

387
00:29:06,880 --> 00:29:14,880
First of all, we're talking about a variable being bound if the parameter is within the

388
00:29:14,880 --> 00:29:16,480
scope.

389
00:29:16,480 --> 00:29:24,240
So when we talk about this A here, this A is bound to this A parameter.

390
00:29:24,240 --> 00:29:34,720
This X is bound to this X parameter.

391
00:29:34,720 --> 00:29:39,760
Can we always rename bound variables?

392
00:29:39,760 --> 00:29:43,280
Yes?

393
00:29:43,280 --> 00:29:46,960
No?

394
00:29:46,960 --> 00:29:50,960
No?

395
00:29:50,960 --> 00:29:57,080
Like ten people voted.

396
00:29:57,080 --> 00:30:06,480
Think about JavaScript.

397
00:30:06,480 --> 00:30:12,320
Can we always rename X in this function?

398
00:30:12,320 --> 00:30:17,360
Or always rename A1 in the other function?

399
00:30:17,360 --> 00:30:19,360
Yes?

400
00:30:19,360 --> 00:30:21,360
No?

401
00:30:21,360 --> 00:30:22,700
Yes!

402
00:30:22,700 --> 00:30:23,700
We wrote the code.

403
00:30:23,700 --> 00:30:24,880
We get to decide.

404
00:30:24,880 --> 00:30:26,700
The parameter name is up to us.

405
00:30:26,700 --> 00:30:29,880
So we totally can.

406
00:30:29,880 --> 00:30:31,200
These are just placeholders.

407
00:30:31,200 --> 00:30:36,480
It's a parameter name.

408
00:30:36,480 --> 00:30:42,880
So we specifically say that they are equivalent by an alpha rename.

409
00:30:42,880 --> 00:30:44,440
The character is very small there.

410
00:30:44,440 --> 00:30:54,120
That is the Greek alpha symbol.

411
00:30:54,120 --> 00:31:04,080
So we can rename lambdaX.X plus Y to lambdaZ.Z plus Y.

412
00:31:04,080 --> 00:31:09,800
And what we've already started to get at is can we rename everything?

413
00:31:09,800 --> 00:31:13,520
We've seen this in JavaScript that we couldn't.

414
00:31:13,520 --> 00:31:16,100
So what can't we rename?

415
00:31:16,100 --> 00:31:23,120
Can we rename the Y in lambdaX.X plus Y?

416
00:31:23,120 --> 00:31:25,760
No.

417
00:31:25,760 --> 00:31:28,360
We don't know what it's going to be.

418
00:31:28,360 --> 00:31:35,320
Somebody else defined it, and we are just using that value.

419
00:31:35,320 --> 00:31:40,360
And what I'm trying to get at here is that you can change the name of your parameters

420
00:31:40,360 --> 00:31:42,280
and arguments.

421
00:31:42,280 --> 00:31:53,680
You can't change the name of variables in the outer scope.

422
00:31:53,680 --> 00:31:57,800
Any questions on this renaming idea?

423
00:31:57,800 --> 00:31:59,240
Yeah?

424
00:31:59,240 --> 00:32:21,160
Why do we only have access to part of the codebase?

425
00:32:21,160 --> 00:32:23,400
Why can't we change the outer A?

426
00:32:23,400 --> 00:32:24,400
Yeah?

427
00:32:24,400 --> 00:32:46,700
Yeah, so if it's something that's, like, beyond the code, kind of, it's just the string literal

428
00:32:46,700 --> 00:32:49,760
that we need to use there, I think that's a fair reason.

429
00:32:49,760 --> 00:32:51,520
Why else?

430
00:32:51,520 --> 00:32:54,320
Why else might we not have full control?

431
00:32:54,320 --> 00:33:04,400
Yeah, definitely.

432
00:33:04,400 --> 00:33:11,880
So if we were to be using any external library, any external API or other code, we don't necessarily

433
00:33:11,880 --> 00:33:14,400
control that.

434
00:33:14,400 --> 00:33:25,880
How many of you have created a file called, like, time.py or math.py in your projects?

435
00:33:25,880 --> 00:33:27,120
I feel like that's...

436
00:33:27,120 --> 00:33:31,800
I did that when I was, like, first learning how to code and got an error for, like, half

437
00:33:31,800 --> 00:33:37,720
an hour trying to figure out what's going on, and it's just because you've overwritten

438
00:33:37,720 --> 00:33:40,400
the default library for time.

439
00:33:40,400 --> 00:33:43,920
And so Python gets confused, because there's this name conflict.

440
00:33:43,920 --> 00:33:47,400
You used time when they've already defined it.

441
00:33:47,400 --> 00:33:50,440
It's the same exact fundamental problem.

442
00:33:50,440 --> 00:33:56,200
So we operate and write code in very complicated systems.

443
00:33:56,200 --> 00:34:00,960
Whether it's an interpreter or just a large codebase that you don't necessarily get to

444
00:34:00,960 --> 00:34:03,000
control everything.

445
00:34:03,000 --> 00:34:05,220
So this definitely happens.

446
00:34:05,220 --> 00:34:10,960
Where you, like, can't control all of your environment.

447
00:34:10,960 --> 00:34:13,620
Yeah.

448
00:34:13,620 --> 00:34:16,540
Any other questions on renaming?

449
00:34:16,540 --> 00:34:19,820
All right.

450
00:34:19,820 --> 00:34:26,340
We're gonna get a bit more formal, then.

451
00:34:26,340 --> 00:34:28,200
We've covered informal substitution.

452
00:34:28,200 --> 00:34:32,100
We have an idea about, okay, we can, like, substitute these things so long as we rename

453
00:34:32,100 --> 00:34:34,620
some of them sometimes.

454
00:34:34,620 --> 00:34:37,300
Let's do it in a more formal way.

455
00:34:37,300 --> 00:34:40,620
So first of all, what is a free variable?

456
00:34:40,620 --> 00:34:43,580
We've talked about bound variables.

457
00:34:43,580 --> 00:34:46,020
A variable is not bound.

458
00:34:46,020 --> 00:34:47,820
Then it is free.

459
00:34:47,820 --> 00:34:51,500
So any nonbound variable is a free variable.

460
00:34:51,500 --> 00:34:54,980
We had this expression, lambdaX.X plus Y.

461
00:34:54,980 --> 00:34:56,820
X was bound.

462
00:34:56,820 --> 00:34:59,660
Y is free.

463
00:34:59,660 --> 00:35:19,840
I answered the next question there for you.

464
00:35:19,840 --> 00:35:24,020
Let's try and solve for these two equations, though.

465
00:35:24,020 --> 00:35:30,860
So we want to be able to algorithmically find what are the free variables of an expression.

466
00:35:30,860 --> 00:35:36,620
The free variables of the expression X are X.

467
00:35:36,620 --> 00:35:43,220
If all that we have is the variable X, we have just, like, nobody's told us anything

468
00:35:43,220 --> 00:35:44,220
about it.

469
00:35:44,220 --> 00:35:47,680
It is free.

470
00:35:47,680 --> 00:36:09,700
What about the free variables of lambdaX.E. Yeah?

471
00:36:09,700 --> 00:36:13,680
Is it empty?

472
00:36:13,680 --> 00:36:14,680
That's one idea.

473
00:36:14,680 --> 00:36:15,680
Yeah?

474
00:36:15,680 --> 00:36:17,920
Every variable except for X.

475
00:36:17,920 --> 00:36:19,680
Every variable except X.

476
00:36:19,680 --> 00:36:27,640
So the, like, all� what would even every variable look like?

477
00:36:27,640 --> 00:36:30,600
Something like that minus X.

478
00:36:30,600 --> 00:36:40,600
The set of all variables minus X. Yeah?

479
00:36:40,600 --> 00:36:48,920
The free variables of E minus X. Okay?

480
00:36:48,920 --> 00:36:51,040
Any other candidates?

481
00:36:51,040 --> 00:36:53,480
Yeah?

482
00:36:53,480 --> 00:36:59,840
Just E. E here is an expression.

483
00:36:59,840 --> 00:37:00,840
Not a variable.

484
00:37:00,840 --> 00:37:02,080
Just to be clear.

485
00:37:02,080 --> 00:37:04,940
But we can leave it up.

486
00:37:04,940 --> 00:37:10,320
So the expression E. Any other candidates?

487
00:37:10,320 --> 00:37:17,360
So, okay.

488
00:37:17,360 --> 00:37:22,200
Let's think about all of these.

489
00:37:22,200 --> 00:37:26,520
If we have an expression, we can just choose an expression.

490
00:37:26,520 --> 00:37:33,080
So let's use the expression X plus Y. E equals X plus Y.

491
00:37:33,080 --> 00:37:35,480
That's been our running example.

492
00:37:35,480 --> 00:37:48,040
Are the free variables of lambdaX.X plus Y, is that the empty set?

493
00:37:48,040 --> 00:37:51,480
No.

494
00:37:51,480 --> 00:37:55,120
We've said that Y is free.

495
00:37:55,120 --> 00:38:03,200
So we know Y is free, which means the free variables of this expression can't be empty.

496
00:38:03,200 --> 00:38:05,240
So we can't do that one.

497
00:38:05,240 --> 00:38:11,360
What about the set of all variables minus the free variable� or minus X?

498
00:38:11,360 --> 00:38:12,640
We've captured X.

499
00:38:12,640 --> 00:38:13,640
No.

500
00:38:13,640 --> 00:38:14,640
Oh, wait.

501
00:38:14,640 --> 00:38:18,640
We're looking at�

502
00:38:18,640 --> 00:38:26,080
That's okay?

503
00:38:26,080 --> 00:38:28,120
Any ideas on this one?

504
00:38:28,120 --> 00:38:34,480
No, because E might have bound variables.

505
00:38:34,480 --> 00:38:37,080
E might have bound variables.

506
00:38:37,080 --> 00:38:39,480
What if we have a different E?

507
00:38:39,480 --> 00:38:55,200
We could use lambdaZ.Z plus A. Here, Z is bound.

508
00:38:55,200 --> 00:38:59,420
A is free.

509
00:38:59,420 --> 00:39:15,200
So when we have the free variables of lambdaX.lambdaZ.Z plus A, it's not actually all variables minus

510
00:39:15,200 --> 00:39:16,580
X.

511
00:39:16,580 --> 00:39:17,860
We've also captured Z.

512
00:39:17,860 --> 00:39:18,860
Yeah?

513
00:39:18,860 --> 00:39:35,300
Yeah, so Z is bound in here, but it's not bound out here.

514
00:39:35,300 --> 00:39:37,580
Oh, that's fair.

515
00:39:37,580 --> 00:39:38,820
Yeah?

516
00:39:38,820 --> 00:39:51,380
Z, in the context of this whole function, is still free, if it exists.

517
00:39:51,380 --> 00:40:03,820
So this one doesn't actually disprove all variables minus X.

518
00:40:03,820 --> 00:40:07,400
Trying to think what a good example would be.

519
00:40:07,400 --> 00:40:16,320
I think that there actually might not be a great way of showing that this is not true.

520
00:40:16,320 --> 00:40:22,440
What we can look at is then comparing it with this next one.

521
00:40:22,440 --> 00:40:27,880
The free variables of E minus X.

522
00:40:27,880 --> 00:40:30,800
So here, what we would see is...

523
00:40:30,800 --> 00:40:37,720
I'm too low on this, aren't I?

524
00:40:37,720 --> 00:40:43,440
What would be an expression that could show that the free variables of E minus X does

525
00:40:43,440 --> 00:40:46,440
or does not work?

526
00:40:46,440 --> 00:40:48,440
Yeah?

527
00:40:48,440 --> 00:40:50,440
Wait.

528
00:40:50,440 --> 00:40:52,440
No.

529
00:40:52,440 --> 00:40:54,440
Sure.

530
00:40:54,960 --> 00:41:09,800
So if we say E is equal to X plus Y, and we look at the free variables of E, this would

531
00:41:09,800 --> 00:41:17,160
be equal to the set of X and Y.

532
00:41:17,160 --> 00:41:25,120
When we then subtract out X, we will be left with the set Y, which is what we are looking

533
00:41:25,120 --> 00:41:26,840
for.

534
00:41:26,840 --> 00:41:33,300
So this is the answer I have on my slides.

535
00:41:33,300 --> 00:41:40,320
I think this is also somewhat reasonable.

536
00:41:40,320 --> 00:41:44,080
The only thing is they aren't, like, defined there.

537
00:41:44,080 --> 00:41:47,680
Like, Z is not defined in X plus Y.

538
00:41:47,680 --> 00:41:49,900
Or it's not used in X plus Y.

539
00:41:49,900 --> 00:41:51,880
That doesn't mean it's not free in X plus Y.

540
00:41:51,880 --> 00:41:58,720
That one's thrown me for a bit of a loop.

541
00:41:58,720 --> 00:42:06,080
But the simplest set to represent the free variables of lambdaX.E are the free variables

542
00:42:06,080 --> 00:42:10,440
of E minus the variable X.

543
00:42:10,440 --> 00:42:29,880
That we capture the X from within E. Yeah?

544
00:42:29,880 --> 00:42:38,860
So if we have E is X plus Y, the free variables of E, following� actually, I guess we kind

545
00:42:38,860 --> 00:42:39,860
of need this one.

546
00:42:39,860 --> 00:42:47,480
But following this, we can say that X and Y are both free.

547
00:42:47,480 --> 00:42:52,480
Inside of E.

548
00:42:52,480 --> 00:42:56,520
So X is only captured as we move out.

549
00:42:56,520 --> 00:42:58,520
Exactly.

550
00:42:58,520 --> 00:43:00,520
Yeah.

551
00:43:00,520 --> 00:43:08,960
So then we work inwards, out.

552
00:43:08,960 --> 00:43:13,980
You start at the inside and kind of grow out to your expression.

553
00:43:13,980 --> 00:43:18,480
Find what's free and what's not.

554
00:43:18,480 --> 00:43:21,720
All right.

555
00:43:21,720 --> 00:43:45,240
Doing this last one for application.

556
00:43:45,240 --> 00:43:49,640
What are the free variables of E1 applied to E2?

557
00:43:49,640 --> 00:43:55,120
Let's give ourselves some examples to see what it should be.

558
00:43:55,120 --> 00:44:01,940
We could have lambdaX, X plus Y, and Z, for example.

559
00:44:01,940 --> 00:44:06,000
So E1 is lambdaX, X plus Y, E2 is Z.

560
00:44:06,000 --> 00:44:10,400
The free variables of E1 are what?

561
00:44:10,400 --> 00:44:13,360
Y.

562
00:44:13,360 --> 00:44:18,600
So we have FV of E1 equals Y.

563
00:44:18,720 --> 00:44:23,520
What are the free variables of E2?

564
00:44:23,520 --> 00:44:34,960
Z.

565
00:44:34,960 --> 00:44:40,640
And what would we expect to be the free variables of the full expression?

566
00:44:40,640 --> 00:44:42,640
Yeah.

567
00:44:42,640 --> 00:44:54,120
Yeah, we would think they would be Y and Z.

568
00:44:54,120 --> 00:45:01,200
That in this whole part, we don't know what Z is or what Y is.

569
00:45:01,200 --> 00:45:10,840
So we have the free variables is equal to, well, here, it's equal to Y, Z, which means

570
00:45:10,840 --> 00:45:20,720
if we write it out, that it's equal to the free variables of E1 union free variables

571
00:45:20,720 --> 00:45:28,720
of E2.

572
00:45:29,120 --> 00:45:34,920
Yeah.

573
00:45:34,920 --> 00:45:55,400
Oh, oh, yeah, yeah.

574
00:45:55,400 --> 00:45:56,400
Yeah.

575
00:45:56,400 --> 00:46:20,200
What are the

576
00:46:20,200 --> 00:46:32,480
free variables of this full expression?

577
00:46:32,480 --> 00:46:36,580
X and Y.

578
00:46:36,580 --> 00:46:40,280
We have this as our equation.

579
00:46:40,280 --> 00:46:43,700
It's the union of the two sets.

580
00:46:43,700 --> 00:46:46,120
Here we have Y, here we have X.

581
00:46:46,120 --> 00:46:52,960
Even though X is bound over here, in the overall expression, X is still free.

582
00:46:52,960 --> 00:46:57,160
And that's what's going to end up causing us trouble when we try and do substitution,

583
00:46:57,160 --> 00:47:11,080
if we don't do some sort of subscript to say this one's X1.

584
00:47:11,080 --> 00:47:12,080
Other questions?

585
00:47:12,080 --> 00:47:13,080
Right.

586
00:47:13,080 --> 00:47:14,080
That's right.

587
00:47:14,080 --> 00:47:27,440
So here, this X and this X are the same.

588
00:47:27,440 --> 00:47:32,040
This X is different.

589
00:47:32,040 --> 00:47:40,160
Because it's free, yeah.

590
00:47:40,160 --> 00:47:46,540
All right.

591
00:47:46,540 --> 00:47:52,660
So the last bit of formal stuff that we do here is how can we actually define capture

592
00:47:52,660 --> 00:47:54,740
avoiding substitution?

593
00:47:54,740 --> 00:48:03,240
That is to say we don't run into our problem with the solution being 19 from earlier.

594
00:48:03,240 --> 00:48:09,500
What is the value of X where X is equal to E?

595
00:48:09,500 --> 00:48:12,940
Think of yourself as a computer trying to solve these.

596
00:48:12,940 --> 00:48:17,140
Or we have to come up with the rules so that a computer could solve these.

597
00:48:17,140 --> 00:48:20,300
What's the value of X where X is equal to E?

598
00:48:20,300 --> 00:48:23,240
E. I like it.

599
00:48:23,240 --> 00:48:26,280
We just replace X with E. That's totally fine.

600
00:48:26,280 --> 00:48:32,680
What's the value of Y where X is equal to E?

601
00:48:32,680 --> 00:48:35,520
Y if what?

602
00:48:35,520 --> 00:48:37,400
Right.

603
00:48:37,400 --> 00:48:41,000
It will remain Y so long as Y is not X.

604
00:48:41,000 --> 00:48:44,640
If Y were X, then we would use rule one.

605
00:48:44,640 --> 00:48:46,320
All right.

606
00:48:46,320 --> 00:49:04,280
What about E1 applied to E2 where X is equal to E?

607
00:49:04,280 --> 00:49:29,120
Think recursively.

608
00:49:29,120 --> 00:49:57,320
We can also do one on the board just to kind of see what happens.

609
00:49:57,320 --> 00:50:09,440
So, this is E1 applied to E2 where X is equal to 3.

610
00:50:09,440 --> 00:50:15,640
How would we simplify this expression?

611
00:50:15,640 --> 00:50:31,200
Yeah, go for it.

612
00:50:31,200 --> 00:50:32,200
Is it already simplified?

613
00:50:32,200 --> 00:50:33,200
No.

614
00:50:33,200 --> 00:50:37,080
No, there's more we can do.

615
00:50:37,080 --> 00:50:40,080
I want to substitute in this value of X.

616
00:50:40,080 --> 00:50:44,280
How do I do that?

617
00:50:44,280 --> 00:50:47,480
Our current two rules, by the way, are just those.

618
00:50:47,480 --> 00:50:48,480
Yeah?

619
00:50:48,480 --> 00:50:53,920
Is it X where Y equals X?

620
00:50:53,920 --> 00:50:54,920
X where Y equals X.

621
00:50:54,920 --> 00:50:55,920
Ah!

622
00:50:55,920 --> 00:50:59,480
So, you're, like, doing the substitution.

623
00:50:59,480 --> 00:51:02,880
So we could, like, kind of continue evaluating.

624
00:51:02,880 --> 00:51:07,380
But what I want to do, actually, is just clear up our state.

625
00:51:07,380 --> 00:51:10,240
Give all of our Xs the value 3.

626
00:51:10,240 --> 00:51:12,300
That's our goal right now.

627
00:51:12,300 --> 00:51:26,800
How can we do that?

628
00:51:26,800 --> 00:51:30,920
Would it help if you talked to the person next to you?

629
00:51:30,920 --> 00:51:31,920
Give it 30 seconds.

630
00:51:31,920 --> 00:51:32,960
What can we do here?

631
00:52:01,920 --> 00:52:26,940
Okay.

632
00:52:26,940 --> 00:52:29,920
What's the, again, algorithmic.

633
00:52:29,920 --> 00:52:35,160
Like what your computer is going to do when trying to take the next step here to simplify

634
00:52:35,160 --> 00:52:36,160
the state.

635
00:52:36,160 --> 00:52:37,160
Yeah.

636
00:52:37,160 --> 00:52:42,080
All the way in the back.

637
00:52:42,080 --> 00:52:43,080
I'm sorry.

638
00:52:43,080 --> 00:52:46,400
What was that?

639
00:52:46,400 --> 00:52:48,720
Distribute the definition to each expression.

640
00:52:48,720 --> 00:52:50,040
This is the definition?

641
00:52:50,040 --> 00:52:51,040
Yeah.

642
00:52:51,040 --> 00:52:58,320
So we can say that this is equal to lambda Y dot X, where X is equal to three, applied

643
00:52:58,320 --> 00:53:06,360
to lambda Z dot X plus Z, where X is equal to three.

644
00:53:06,360 --> 00:53:10,480
We're telling each expression that X is equal to three.

645
00:53:10,480 --> 00:53:15,200
Then if we wanted to continue, we can, you know, keep substituting, blah, blah, blah.

646
00:53:15,200 --> 00:53:22,320
But we need to be able to actually give X in each of those two contexts the value three.

647
00:53:22,320 --> 00:53:23,320
Yeah.

648
00:53:23,320 --> 00:53:30,320
I'm a little confused, because I thought we could only substitute bounds, or, like, the

649
00:53:30,320 --> 00:53:37,280
bounds are the same, so why are we assigning them to that?

650
00:53:37,280 --> 00:53:38,280
Yeah.

651
00:53:38,280 --> 00:53:39,280
Let me do that.

652
00:53:39,280 --> 00:53:40,280
Yeah.

653
00:53:40,280 --> 00:53:42,920
So are these free or bound?

654
00:53:42,920 --> 00:53:52,120
Is X free or bound in this expression?

655
00:53:52,120 --> 00:53:53,120
Free?

656
00:53:53,280 --> 00:53:54,280
Bound?

657
00:53:55,840 --> 00:53:59,120
It is actually free.

658
00:53:59,120 --> 00:54:05,600
If we look at the free variables of this expression, we would say X is free, X is free, the union

659
00:54:05,600 --> 00:54:08,640
of X and X is X.

660
00:54:08,640 --> 00:54:11,880
How would we have gotten to a state like this, though?

661
00:54:11,880 --> 00:54:18,040
Maybe it's bound in a larger function?

662
00:54:18,040 --> 00:54:22,000
It's bound in a larger function, where we've given it value.

663
00:54:22,000 --> 00:54:32,400
It's like if we go back to our JavaScript, and we have that outer let A equal.

664
00:54:32,400 --> 00:54:35,080
And we've said A is equal to three.

665
00:54:35,080 --> 00:54:39,000
Then we know exactly what to do with A. We can substitute it with three.

666
00:54:39,000 --> 00:54:41,000
So same thing's happening here.

667
00:54:41,000 --> 00:54:48,120
And one way, if we kind of, like, backstep here, we could pretend that there was a lambda

668
00:54:48,120 --> 00:54:55,960
X three, right before this step, that we've now substituted in that three for X, and so

669
00:54:55,960 --> 00:55:01,720
now we have this state, X equals three.

670
00:55:01,720 --> 00:55:08,640
This step here is very similar to what's called an eta reduction, or an eta conversion.

671
00:55:08,640 --> 00:55:10,440
But we'll cover that later.

672
00:55:10,440 --> 00:55:11,440
Yeah?

673
00:55:11,440 --> 00:55:15,720
So we can't bound it into only free variables?

674
00:55:15,720 --> 00:55:17,800
We can substitute only free variables.

675
00:55:18,000 --> 00:55:20,320
Yeah, so that's right.

676
00:55:20,320 --> 00:55:27,480
If we had, let's see, what can I do here?

677
00:55:27,480 --> 00:55:35,600
X plus lambda X dot X plus two, it doesn't make any sense anymore, because we're adding

678
00:55:35,600 --> 00:55:37,040
a function.

679
00:55:37,040 --> 00:55:41,200
But this X here is bound to this X.

680
00:55:41,400 --> 00:55:48,800
That means when we substitute X equals three, we don't want to replace this inner X with

681
00:55:48,800 --> 00:55:51,000
the value three.

682
00:55:51,000 --> 00:55:53,160
Because it's tied to a different parameter.

683
00:55:53,160 --> 00:55:56,080
It's scoped to a different parameter.

684
00:55:56,080 --> 00:55:59,720
That's just like shadowing in, like, traditional programming.

685
00:55:59,720 --> 00:56:03,560
But we haven't gotten to the lambda one yet.

686
00:56:03,560 --> 00:56:07,200
We're about to.

687
00:56:08,200 --> 00:56:11,520
Okay.

688
00:56:11,520 --> 00:56:20,880
So where we are right now is that with two expressions, we can say the X equals E distributes

689
00:56:20,880 --> 00:56:26,760
to each expression.

690
00:56:26,760 --> 00:56:32,800
Now the question that we have over here is what are we supposed to do if we have lambda

691
00:56:32,800 --> 00:56:38,880
X dot E and X is assigned a value?

692
00:56:38,880 --> 00:56:54,000
What should we get here with this substitution?

693
00:56:54,000 --> 00:57:04,760
The simplest case of this would be lambda X dot X where X is equal to two.

694
00:57:04,760 --> 00:57:19,320
What should that reduce to?

695
00:57:19,320 --> 00:57:24,200
How many people feel like they have an idea?

696
00:57:24,200 --> 00:57:28,000
How many people are confused as to what I'm asking?

697
00:57:28,000 --> 00:57:29,560
A few.

698
00:57:29,560 --> 00:57:32,000
No, it's fair.

699
00:57:32,000 --> 00:57:33,000
It's tricky.

700
00:57:33,000 --> 00:57:36,640
Especially, like, there's math notation in computer science.

701
00:57:36,640 --> 00:57:44,940
It doesn't happen very often when you're actually, like, coding.

702
00:57:44,940 --> 00:57:47,260
But some number of you had an idea.

703
00:57:47,260 --> 00:58:07,780
What are you thinking?

704
00:58:07,780 --> 00:58:08,780
Go for it.

705
00:58:08,780 --> 00:58:13,780
Yeah, it's a bound variable.

706
00:58:13,780 --> 00:58:15,600
So can't we just rename it?

707
00:58:15,600 --> 00:58:22,820
So what would happen if we say it's equal to ZZ?

708
00:58:22,820 --> 00:58:25,220
Does this make it easier?

709
00:58:25,220 --> 00:58:31,020
What should this simplify to?

710
00:58:31,020 --> 00:58:35,860
Yeah?

711
00:58:35,860 --> 00:58:46,960
Does it simplify to Z?

712
00:58:46,960 --> 00:58:54,840
So we aren't passing 2 in as a parameter.

713
00:58:54,840 --> 00:59:10,580
We have an expression and we have some state as well.

714
00:59:10,580 --> 00:59:12,620
We can push state inside the function.

715
00:59:12,620 --> 00:59:13,620
Sure.

716
00:59:13,620 --> 00:59:26,700
We can get lambdaZ.Z where X is equal to 3 inside of that Z.

717
00:59:26,700 --> 00:59:30,380
What does that simplify to?

718
00:59:30,380 --> 00:59:38,740
We can use rule number 2.

719
00:59:38,740 --> 00:59:39,740
Go for it.

720
00:59:39,740 --> 00:59:44,780
Is Z equal to X?

721
00:59:44,780 --> 00:59:45,780
No.

722
00:59:45,780 --> 00:59:50,300
Z is equal to Z. Z is Z.

723
00:59:50,300 --> 00:59:56,260
So it's equal to Z. So we can just get rid of this state.

724
00:59:56,260 --> 01:00:01,740
That's the intuitive thing to do when we're trying to substitute X equals 2 in an expression

725
01:00:01,740 --> 01:00:04,740
that doesn't use X. We can just ignore X.

726
01:00:04,740 --> 01:00:12,100
Right?

727
01:00:12,100 --> 01:00:13,740
Does that feel intuitive?

728
01:00:13,740 --> 01:00:14,740
Does it...

729
01:00:14,740 --> 01:00:22,420
Do you have questions about why we can do that?

730
01:00:22,420 --> 01:00:25,700
We're trying to say X is equal to 2, but we aren't using X.

731
01:00:25,700 --> 01:00:31,660
So within that scope, we can just ignore the fact that X is equal to 2.

732
01:00:31,660 --> 01:00:46,320
What that looks like is saying lambdaX.E, where X is equal to E, is just lambdaX.E.

733
01:00:46,320 --> 01:00:54,080
This problem started, by the way, slightly differently with XX.

734
01:00:54,080 --> 01:01:00,840
But the point was, because this X is bound to that X parameter, we were able to rename

735
01:01:00,840 --> 01:01:04,880
it.

736
01:01:04,880 --> 01:01:08,020
Which is why, then, it was very clear that we could do this.

737
01:01:08,020 --> 01:01:13,120
We can do it either way, without the rename or with the rename.

738
01:01:13,120 --> 01:01:20,640
But the rename kind of makes it a little bit clearer as to why we can do that.

739
01:01:20,640 --> 01:01:21,640
Question?

740
01:01:21,640 --> 01:01:22,640
Yeah.

741
01:01:22,640 --> 01:01:36,880
Yeah, so this X in the outer scope that is equal to E, what if this X is in E1?

742
01:01:36,880 --> 01:01:37,880
Yeah.

743
01:01:37,880 --> 01:01:42,080
Then it would be bound.

744
01:01:42,080 --> 01:01:48,520
And it wouldn't be this X. This X cannot exist inside of the scope E1.

745
01:01:48,520 --> 01:01:57,880
Any Xs inside of E1 are bound to this X or another inner X that is binding them.

746
01:01:57,880 --> 01:02:03,600
It's never going to be this X. Because that one comes first.

747
01:02:03,600 --> 01:02:08,280
It's similar to when you're writing code and you say X is equal to 3.

748
01:02:08,280 --> 01:02:11,880
That X is equal to 3, the outer ones aren't.

749
01:02:11,880 --> 01:02:16,000
Unless you're, like, doing something weird.

750
01:02:16,000 --> 01:02:18,720
All right.

751
01:02:18,720 --> 01:02:22,080
Can we get the last one here?

752
01:02:22,080 --> 01:02:33,920
What happens lambda Y dot E1 and X is equal to E2?

753
01:02:33,920 --> 01:02:53,000
Push it inside.

754
01:02:53,000 --> 01:02:54,000
Yeah.

755
01:02:54,000 --> 01:03:14,640
Maybe...

756
01:03:14,640 --> 01:03:22,740
So what we want to say is that it's lambda Y dot E1 where X is equal to E2.

757
01:03:22,740 --> 01:03:30,020
So basically what we've done is we've dropped the lambda Y as part of the consideration.

758
01:03:30,020 --> 01:03:38,260
And so then we can take another step based on whatever E1 is where X is equal to E2.

759
01:03:38,260 --> 01:03:43,220
That's what we would like to say.

760
01:03:43,220 --> 01:03:48,740
But there are some important caveats here.

761
01:03:48,740 --> 01:03:51,140
Yeah.

762
01:03:51,340 --> 01:03:53,360
Yeah.

763
01:03:53,360 --> 01:03:56,060
So can I read what I just wrote?

764
01:03:56,060 --> 01:03:57,700
Lambda Y dot E1.

765
01:03:57,700 --> 01:04:05,460
The expression lambda Y dot E1 where the state X is equal to E2.

766
01:04:05,460 --> 01:04:14,540
On the next line, we have lambda Y dot E1 where the state is X equals E2.

767
01:04:14,540 --> 01:04:21,780
So here what I'm saying is that the state is part of this expression only.

768
01:04:21,780 --> 01:04:35,720
Here what I'm saying is the state is part of the entire expression.

769
01:04:35,720 --> 01:04:38,280
We might have Y in E2.

770
01:04:38,280 --> 01:04:44,920
So Y in E2.

771
01:04:44,920 --> 01:04:54,480
What would happen if we have Y in E2?

772
01:04:54,480 --> 01:04:59,120
So if E2 is equal to exactly, for example, Y.

773
01:04:59,120 --> 01:05:00,120
Yeah.

774
01:05:00,120 --> 01:05:01,120
Yeah.

775
01:05:01,120 --> 01:05:02,120
Yeah.

776
01:05:02,120 --> 01:05:26,400
So if E2 is equal to Y, and let's say E1 equals X, then when we perform our replacement based

777
01:05:26,400 --> 01:05:32,420
on the state, we would get lambda Y dot Y as our result.

778
01:05:32,420 --> 01:05:39,760
Because E1 is X, and X is equal to E2, and E2 is equal to Y.

779
01:05:39,760 --> 01:05:42,460
So we would end up with lambda Y dot Y.

780
01:05:42,460 --> 01:05:48,800
In which case, we have captured the Y.

781
01:05:48,800 --> 01:05:57,760
Because E2 is not being controlled by this Y here.

782
01:05:57,760 --> 01:05:59,840
So this Y was free, potentially.

783
01:05:59,840 --> 01:06:03,140
Well, I guess, no, it's definitely free here.

784
01:06:03,140 --> 01:06:05,880
And then we've accidentally captured it.

785
01:06:05,880 --> 01:06:13,320
So if Y is in E2, we have an issue, and we will need to do an alpha rename on this Y.

786
01:06:13,320 --> 01:06:19,680
This Y and any Y inside of E1.

787
01:06:19,680 --> 01:06:23,640
The other case is defined by this one here.

788
01:06:23,640 --> 01:06:34,960
If Y is equal to X, then we would just use this rule instead and drop the state.

789
01:06:34,960 --> 01:06:41,320
So our expression is that lambda Y dot E1, where X is equal to E2, is equal to lambda

790
01:06:41,320 --> 01:06:45,120
Y dot E1, where X is equal to E2.

791
01:06:45,120 --> 01:06:51,240
So long as Y does not equal X, if Y equaled X, we would use this rule here.

792
01:06:51,240 --> 01:06:55,200
And so long as Y is not in the free variables of E2.

793
01:06:55,200 --> 01:06:59,280
If Y were in the free variables of E2, then we would be capturing the Y.

794
01:06:59,280 --> 01:07:00,280
Yeah?

795
01:07:00,280 --> 01:07:01,280
Just to clarify, between these last two bullet points, does the E inside of the brackets

796
01:07:01,280 --> 01:07:22,280
having a 2 or not make a difference?

797
01:07:22,280 --> 01:07:23,280
No.

798
01:07:23,280 --> 01:07:24,280
OK.

799
01:07:24,360 --> 01:07:33,200
Yeah, it's just to say that these are different E's.

800
01:07:33,200 --> 01:07:34,720
These are different E's as well.

801
01:07:34,720 --> 01:07:35,720
Those are different E's.

802
01:07:35,720 --> 01:07:36,720
Yeah.

803
01:07:36,720 --> 01:07:37,720
Yeah?

804
01:07:37,720 --> 01:07:48,600
So if Y is in the state of the free variable E2, do you just go with X?

805
01:07:48,600 --> 01:07:51,600
If Y is in the state...

806
01:07:51,920 --> 01:07:56,920
If Y is in the free variable of E2, then you would just throw away that?

807
01:07:56,920 --> 01:07:57,920
Ah, yeah.

808
01:07:57,920 --> 01:08:04,600
So what do we do if Y is in E2 here, in the free variables of E2?

809
01:08:04,600 --> 01:08:08,360
Then what we need to do is we need to actually alpha rename.

810
01:08:08,360 --> 01:08:15,520
That's when we do our renaming of this Y here and any Y in E1.

811
01:08:15,520 --> 01:08:16,720
That's the way to solve that.

812
01:08:16,720 --> 01:08:19,080
It's not that we just throw away this state.

813
01:08:19,080 --> 01:08:22,720
We can't ignore the fact that X equals E2 here.

814
01:08:22,720 --> 01:08:26,200
Because we might be using X inside of E1.

815
01:08:26,200 --> 01:08:35,320
So we have to actually rename the bound version of Y so that we can do the substitution.

816
01:08:35,320 --> 01:08:38,320
Yeah?

817
01:08:38,320 --> 01:08:41,320
Yeah.

818
01:08:41,320 --> 01:08:44,320
Yeah.

819
01:08:44,560 --> 01:08:46,560
Yeah.

820
01:08:46,560 --> 01:08:47,560
Yeah.

821
01:08:47,560 --> 01:08:50,560
So we need to rewrite the code to do it this way.

822
01:08:50,560 --> 01:08:51,560
Yeah.

823
01:08:51,560 --> 01:08:54,560
To rename the parameters.

824
01:09:04,560 --> 01:09:05,560
Yeah.

825
01:09:05,560 --> 01:09:08,560
So let's use this one.

826
01:09:14,560 --> 01:09:17,560
Yeah.

827
01:09:25,560 --> 01:09:33,800
We have a function and we have a parameter or an argument being passed in to that function.

828
01:09:33,800 --> 01:09:35,840
Our first step here is...

829
01:09:35,840 --> 01:09:39,440
Well, actually, the first thing we can do is what are the free variables of this whole

830
01:09:39,440 --> 01:09:42,440
expression?

831
01:09:42,440 --> 01:09:57,880
What are the free variables of a union of...

832
01:09:57,880 --> 01:09:58,880
Or...

833
01:09:58,880 --> 01:09:59,880
Okay.

834
01:09:59,880 --> 01:10:01,440
It's the union of an application.

835
01:10:01,440 --> 01:10:06,440
So what are the free variables of the left-hand side of this application?

836
01:10:06,440 --> 01:10:09,640
None.

837
01:10:09,640 --> 01:10:10,800
It's the empty set.

838
01:10:11,160 --> 01:10:13,040
This X here is bound by this X.

839
01:10:13,040 --> 01:10:16,400
What are the free variables of the right-hand side of the application?

840
01:10:16,400 --> 01:10:17,800
Y.

841
01:10:17,800 --> 01:10:22,200
So the free variables of the whole expression are the union of empty set and Y.

842
01:10:22,200 --> 01:10:24,200
Which means...

843
01:10:24,200 --> 01:10:25,500
Y.

844
01:10:25,500 --> 01:10:36,200
When we perform this substitution, what's the first step that we do?

845
01:10:36,600 --> 01:10:39,600
Yeah.

846
01:10:39,600 --> 01:10:54,600
Set X equal Y.

847
01:10:54,600 --> 01:11:01,100
We're gonna pass Y in for the parameter to X.

848
01:11:01,220 --> 01:11:16,580
So we're going to get lambda Y dot X, where X is equal to Y.

849
01:11:16,580 --> 01:11:22,820
What's our next step?

850
01:11:22,820 --> 01:11:28,380
Go for it.

851
01:11:28,380 --> 01:11:31,420
How about rename Y in the lambda Y?

852
01:11:31,420 --> 01:11:34,340
This Y here.

853
01:11:34,340 --> 01:11:36,800
And why do we have to do that?

854
01:11:36,800 --> 01:11:43,340
If we take a look at this example here, or this rule here, we are exactly in violation

855
01:11:43,340 --> 01:11:44,860
of it.

856
01:11:44,860 --> 01:11:52,900
Where we're trying to do lambda Y dot X, where X is equal to Y.

857
01:11:52,900 --> 01:11:58,460
And so that means Y is in the free variables of the Y.

858
01:11:58,460 --> 01:12:04,340
This Y here is in the free variables of that Y there.

859
01:12:04,340 --> 01:12:12,320
And if we don't do the renaming, then we will end up with lambda Y dot Y, where we've captured

860
01:12:12,320 --> 01:12:13,580
the Y.

861
01:12:13,580 --> 01:12:21,020
We've accidentally bound a free variable that started out free, now it's not free.

862
01:12:21,140 --> 01:12:31,020
If we rename this Y to something like Z, how can we simplify this expression?

863
01:12:31,020 --> 01:12:50,540
What rule would we use?

864
01:12:50,540 --> 01:12:57,420
We'll use the last rule, where we're saying, let's pass this state into the expression

865
01:12:57,420 --> 01:13:01,340
instead of looking at it at the whole level.

866
01:13:01,340 --> 01:13:05,200
So now we're saying X, where X equals Y.

867
01:13:05,200 --> 01:13:08,500
How do we substitute that?

868
01:13:08,500 --> 01:13:11,500
What rule do we use?

869
01:13:11,500 --> 01:13:20,820
Yeah.

870
01:13:20,820 --> 01:13:26,500
We have X, where X equals E. E in this case is Y.

871
01:13:26,500 --> 01:13:28,460
So we can do our substitution.

872
01:13:28,460 --> 01:13:32,340
We will end up with lambda Z dot Y.

873
01:13:32,340 --> 01:13:42,660
Y.

874
01:13:42,660 --> 01:13:48,340
So that's Y, the if.

875
01:13:48,340 --> 01:13:51,400
Okay.

876
01:13:51,400 --> 01:13:56,500
This largely speaking covers these first two rules.

877
01:13:56,500 --> 01:14:02,300
We have alpha rename, where we're saying we can rename any bound variable.

878
01:14:02,300 --> 01:14:10,300
And we have beta reduction, where we're saying we can actually perform an application.

879
01:14:10,300 --> 01:14:16,460
We can pass an argument into a function and then reduce it.

880
01:14:16,460 --> 01:14:23,940
The last one here is the eta conversion, which says that if we have a pattern such as lambda

881
01:14:23,940 --> 01:14:32,300
X, E of X, that can be reduced to E automatically.

882
01:14:32,300 --> 01:14:37,180
I'll leave you to figure out exactly how this works.

883
01:14:37,180 --> 01:14:42,620
I would recommend writing it in JavaScript, and then it becomes kind of apparent.

884
01:14:42,620 --> 01:14:45,300
But I'm going to stop here.

885
01:14:45,300 --> 01:14:48,820
We do have some more lambda calculus to do on Monday.

886
01:14:48,820 --> 01:14:53,780
But you are equipped to solve all of the homework assignment problems.

887
01:14:53,780 --> 01:14:57,820
Just using basically these first two techniques.

888
01:15:23,780 --> 01:15:48,780
Hey, what's up?

889
01:15:53,780 --> 01:16:20,780
Hey, what's up?

890
01:16:20,780 --> 01:16:49,780
Hey, what's up?

891
01:16:49,780 --> 01:17:18,780
Hey, what's up?

892
01:17:18,780 --> 01:17:47,780
Hey, what's up?

893
01:17:47,780 --> 01:18:16,780
Hey, what's up?

894
01:18:16,780 --> 01:18:45,780
Hey, what's up?

895
01:18:45,780 --> 01:19:14,780
Hey, what's up?

896
01:19:14,780 --> 01:19:15,780
Hey, what's up?

897
01:19:15,780 --> 01:19:15,780


898
01:19:44,780 --> 01:19:45,780
Hey, what's up?

899
01:19:45,780 --> 01:19:46,780
Hey, what's up?

900
01:19:46,780 --> 01:19:57,780
Hey, what's up?

901
01:19:57,780 --> 01:20:11,780
Hey, what's up?

