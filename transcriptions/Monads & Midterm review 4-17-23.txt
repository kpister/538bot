 Yeah
 No
 But I can potentially give you a little bit of practice questions
 Yeah
 We'll be able to do that
 All right, guys
 Before we get into the rest of lecture and all that normal stuff, a fun little demonstration that was actually shown to me by one of your fellow classmates
 Many of you in office hours came to me with this question
 What does the question mark operator do in Rust? Which is a very reasonable question to have
 And you might go to Google to ask that exact question
 And, you know, there's the Let Me Google that for you
 But that's not really the point
 If you go to Google, you'll get the Rust documentation, which then you have to click on and read through and try and parse this whole chart to figure out like what does the question mark operator do and maybe your monitor disconnects
 So that's the Google approach
 But more recently, just within the last year, there's a cool startup called THIND, PHIND
 PHIND
 And THIND is a search engine with basically a search engine
 But importantly, it tries to actually answer your questions kind of like Google has been doing for a decade where it gives you that little blurb that's like, oh, you want to fly to San Francisco
 Here's the flights widget
 So when you search for what does question mark and Rust do, it comes up immediately with the answer
 Oh, well, that's known as the tri operator
 It's used to simplify error handling and rust code, which is almost exactly what I would tell you in office hours as well
 I highly recommend trying out THIND for any of your programming assignment or just coding questions that you have
 It's basically a more intelligent Google
 You don't have to go to like Geeks for Geeks or W3, you know, all the like crappy, super ad bloated websites to learn how to do Python things
 So it's just right here
 Yeah
 Yeah
 So one of the amazing things about startups is that they don't make money
 And instead they just take in a lot of money from venture and they burn it
 They light it on fire for the rest of us to watch
 And that's exactly what FIND is currently doing within the next year or maybe five years
 Like I mean, Uber was around for a literal decade before they turned a profit
 And everyone knows what Uber is
 Everyone uses Uber
 So FIND, which is a smaller startup, might take a while
 But most likely, unfortunately, what they will do is one of two things
 They will put a little sponsored box right here
 This answer was sponsored by so and so
 Or you will have to pay a monthly subscription to use the service
 One of the two
 Yeah, but right now they don't make money
 So I mean, this isn't as powerful as GPT-4
 So it's not just that you have access to GPT-4 for free
 But it's, you know, similar
 Yeah
 So that's kind of fun
 There's no reason to be stuck in the past
 Google was an amazing search engine for doing this sort of thing for 20 years
 Now there's a better option
 Try and use the better option
 Just because why not? That's what we're here to do
 We're here to learn
 There are also a bunch of others
 By the way, FIND is like one of 10 different generative search engines right now
 So feel free to use your own
 But try them out
 Have fun
 There's a midterm this Wednesday
 For those of you who don't know, now you know
 Make sure you show up
 It's in class
 It's right here
 75 minutes
 Four questions
 Plus an extra credit
 P-A-8
 Oh, whoa, wait
 Those are the ones that you're doing right now, right? All right
 Let's just
 P-A-8 is due next this upcoming Sunday
 Homework eight
 Hopefully you're already submitted
 That was due yesterday, I think
 But P-A-9, homework nine, slash the final
 I'm going to be talking about those on next Monday
 So hold off on your questions about those for now
 But you only have one more assignment in this class
 After you take the midterm on Wednesday, there's one more thing for you to do to finish the class
 The take home is the same thing as all that
 Yeah
 Yes, that is correct
 And I'll tell you all about it on Monday
 But for now, we're going to talk about some code
 Once I get my color palette, correct
 Who remembers how to do this? It's profiles, right? No
 Means? Which one is it? I've done this so many times now, and I still cannot
 Here in
 Say, I remember how to do colors
 No, it's not that one
 Color theme
 Here we go
 Solarize light
 All right
 There we go
 Okay
 Readable
 Are we good in the back or big yet good? Okay
 So let's talk about some code
 This is type script for those of you who don't recognize it
 It looks very similar to JavaScript because it is based on JavaScript
 But it basically has type annotations
 So anything that you see just pretend it's JavaScript
 But every now and then you'll see a type that goes with a parameter or a type that goes with a return type
 So this is a function square that takes in a number and it returns a number, just like JavaScript, though, everything else, basically
 And let's say you're working at your standard big tech company and they've asked you to implement some functions
 They want to be able to square numbers and they want to be able to add to numbers, which is great
 You write out your functions
 Call it a day's work
 Go home
 You're doing well for yourself
 And you can compose your functions together
 Something like that
 You can add one to square and get five
 Cool
 But you've chosen the path of industry and the path of industry has its weights
 In particular, you have a project manager
 And your project manager says, hey, that's cool, but that's not what we need
 We actually need you to update that and rewrite it so that now any time you call one of your functions, we want to track what function was called
 We want to have an audit log of all of the function history that gets a result
 That's no big deal, right? Try and do it within the next few hours and get back to me
 Thanks
 So we have our simple functions that take in numbers and return numbers, but we've been told that we now need to add logging to these functions
 So we should be able to add one to the square of two and we should get back a complicated result
 The result should have the actual number that we want five, but it should also have a sequence of logs that tells us how did we get from from where we are to five
 And so it would say something like, well, we squared two to get four
 We added one to four to get five
 Any questions on the setup? Those pesky project managers, if you go to the academic route, your PI is not much better just to be clear, but there's really no winning
 So we want to get this return type
 We want to be able to add one to square and this is what we get out
 That means we're going to have to rewrite our functions
 So how would we have to rewrite our add one function to make that work? What would we have to change here? I guess we have to rewrite both of them
 We can start with square or add one
 Let's start with square
 How do we have to edit square so that we get to the place where we can then edit add one to get our final result? What are we going to do? And no need to overthink
 Like a simple approach is going to be okay here
 Yeah
 So we have to change our return type
 And what we can do here is we can create a quick interface that we could call, I think I call it number with logs
 Let's call it number with logs that has a result
 If you don't use Google Copilot, I mean GitHub Copilot, now is the time to start as you can see
 I use it here
 So now what we are doing needs to make sure we keep our names the same
 Square now returns a number with logs
 And our number with logs is this object
 The object has a result and it's got logs
 Good? Yeah
 So we need to edit our add one to take a number with logs and then also it's going to be returning a number with logs
 So what does that return type actually look like? Copilot is going to beat you to it if I hit the curly brace
 What's the return value? It's not a trick
 Yeah
 So we are going to be a concatenation of the previous logs with our new string that we are adding one to the result to get result plus one
 And now what we're going to get out when we do add one of square of two is exactly what we want
 Result five logs is squared two to get four, add one to four to get five
 So our project manager is super happy
 They're like, yes, you fulfilled the one unit test that we had
 You're done
 Go home, celebrate
 But what's wrong with this? Yeah
 Let me close this
 Sorry
 All right
 I'll be able to hear now
 We can't
 Yeah
 We can't
 We can't do the inverse basically
 We can't add one to three and then square that result because square still only takes a number
 Whereas add one takes a number with logs and it returns the number with logs
 So our functions are no longer composable the same way
 We've kind of broken that previous property that we had where both of them took a number and returned a number
 So how can we fix that? Yeah
 I think you're going way more complicated than we need to
 How can we make these composable? What? Yeah
 Right
 So long as they take the same type that they return, we can pass them around in any different order
 We don't need anything more complicated
 So we can rewrite square to also take a number with logs
 But then how do we need to update our code? Yeah
 Can we do it this way? Yeah
 Yeah
 Thanks, Copilot
 Copilot wrote like half of my work this morning
 It was amazing
 It's a good day
 Okay
 So then what? Yep
 And then what? Okay
 Great
 So we first calculate the result of, you know, multiplying the number by itself
 Then we set up our return types
 So we're still returning our number with logs
 Cool
 Are we all good? Yeah
 Right
 So previously, we were assuming that square always came first, which meant that it returned a list with only one value
 But when we had add one, what we were doing was actually concatenating our logs to the old logs
 We want to do the same thing here
 So what would that be? X dot logs dot concatenate something like that? Okay
 Are we good? Yeah
 Yeah
 Yeah
 So when we now actually call square, we can't just pass the number two
 What do we need to pass instead? Yeah
 Right
 We need a new number with logs
 And what should that number with logs look like? Yeah
 Yeah
 Yeah
 So logs is an empty array
 The result is the number that we want
 So we could do this
 And then logs is that I think we can do that
 Does TypeScript get mad at us if we forget our curly race? Yeah
 So so long as we have the right interface, we don't actually have to call it a number with logs
 TypeScript is smart enough to know that that is a number with logs
 But this becomes kind of tedious because everywhere that you were just passing to, now you have to rewrite it to create one of these number with logs
 And I don't like doing that
 You might
 That's fine
 But I took CS 538
 And so I love functions
 So I'm going to create a function wrap with logs
 And this wrap with logs is going to be a way to generate a number with logs from just an integer
 So the point of this is that I don't have to keep creating these objects kind of that all look the same except for the number
 This will just take a number
 And as co pilot knows, it's just going to return that object for me
 Okay
 And then the nice thing is I get to get rid of this
 And just do wrap with logs of two
 Okay
 Any questions so far? We transformed our really nice just numerics, everything's kind of clean and just math into something that's kind of hideous
 But it works
 It satisfies the requirements
 Move on with life
 Maybe apply for a new job
 Any questions at all? All right
 How can we improve what we have? We've got some redundancy here
 Between our square function and our ad function, there are some complex ideas that we would like to be able to abstract outside of each of those
 And it would be nice if instead of having each of them deal with a log value coming in, they both just took a number in and then returned a number with logs coming out
 So what I mean is what if we had a way to have a square two that takes a number and before it autocomplates everything, it takes a number and it returns a number with logs
 And also we're going to have a function add one to that takes a number and it returns a number with logs
 And then what we would want is some shared functionality to handle what do we want to call this? We can just call it run for now
 This shared functionality run, which we will investigate, with the purpose of handling all of this log stuff
 These the logs don't actually matter to add one
 All that add one cares about is the actual add one part
 And everything else is redundant to the square function where the square function all it cares about is the square
 It doesn't really care about the logs
 So we would like to be able to abstract those logs outside of our function
 And this is where I can I might lose you so make sure to stop me if I do
 I mean, I scroll down a little bit because we have lots more code
 I think we've actually covered a lot of these things
 So we have our interface number with logs square
 We did all this great, great, great
 What happens if we square this? Yep, we covered all that
 We keep going
 This is where we are
 Right
 So in particular, I want to demonstrate that if we rewrite square, if we rewrite square from looking like this, which is what we had before, and we turn it into something that looks like this
 Square takes a number with logs
 It creates its new number with logs and then it returns the results with the concatenated logs
 Sorry about the pop-ups
 So this is doing the exact same thing as square from before
 It's just kind of pulled one part, the multiplication part out above
 Yeah
 Yeah, we definitely are
 Good call
 Like he's all over the place
 Yep, like that
 Better? Better
 We could do the same thing with add one
 Add one would look the exact same except we would change the value of the log itself and the math that we are doing
 But the important thing is that we would actually be duplicating this concatenation logic, which might seem pretty minor
 Sure, it is
 But it's duplicated code
 Let's remove it
 And what we're going to come up with is a


 is a new function that's going to look like this
 Whoa, why is it look like that? What is that coloring? That's probably because these are weird maybe? Yeah, good
 Good
 Instead of doing something like square wrap with logs 5, we're going to create a new function run with logs with the purpose of taking the function, the command that we want to execute, and a number with logs
 And then what it's going to give me back is another number with logs
 And I can write as many of these functions like square that will have the abstracted away log information handled for them
 So what this might look like is if we start here, actually I don't want to scroll down so that we can think about it
 We're going to start with that
 What should this function run with logs do? What it is doing, what the function type is telling us is that it takes a number with logs
 It takes a transformation function and it returns a number with logs
 And our transform function itself takes a number and returns a number of logs
 So based on those pieces, what should run with logs do? How should we implement this function? You can think of it as kind of like puzzle pieces fitting together
 You can say at a high level as well
 You can say it doesn't need to be the actual type script
 Yeah
 It should call the transform on the input values, result, and then what? What's the second part there? Yeah
 Right
 Then we join the new logs to whatever the previous logs from input work
 So what that might look like is, let's see if Copilot just gets it all
 Do we have to give it a


 So good
 Okay
 So first we transform our result
 That's going to give us a number with logs back
 Then the next thing that we want is we are returning a new number with logs
 The result is our result from the previous from the transformation
 And the logs, we keep our old logs and concatenate on the new logs that we get
 One of the important things with Copilot, by the way, is very much still be able to read the code that it gives you
 So it's cool to just be able to hit tab
 But if you can't parse what it tells you, it's not going to be much help to you
 Except when you get lucky
 Sometimes it will just give you exactly what you need
 But often you need to update it
 So that's going to allow us to do this type of function where we want to run with logs, a wrapped five, and square
 And then the nice thing is we can say let a equal this, and then let b equal run with logs of a add one
 And we could do this as much as we wanted
 We could then keep going, c is add one to b
 And what we're getting each time, a, b, and c are all numbers with logs, and they're tracking the audit history of our code
 But we do need to make one more update
 What else do we need to update to make this work? Why do I have so many red squiggly lines? What else needs to change? Yeah
 Yeah, our function type for add one and square is still taking a number with logs
 But all that we were giving it up here is actually a number
 So we get to simplify our code for square and for add one to just be taking a number again
 Square takes in a number, it returns a number with logs
 Add one takes in a number, it returns a number with logs
 If I wanted to add another one multiplied by three, it takes in a number, and it returns a number with logs
 This is nice, it simplifies my interface
 It also means that if somebody wanted, they could directly call add one or square
 They don't need to do all this wrapping things up and making it all fancy
 So I think we're still getting an error on this, because I commented out, but now we're all good
 And at the end of the day, we can run all of our things, except I called these a previously
 Ta-da
 We can now run our functions together
 They're all audited
 Now, not only is your PM happy, you get to be happy too for writing clean code
 What was the point of that? I don't know
 Let's talk about this error case instead
 You might have some code like this
 Now we're back to just plain JavaScript plan
 You have your email is blah blah blah
 You want to get the domain from the email
 So you have a function that you've written, get domain from email, email
 And then you have, you want to get the TLD from that
 So you have a function TLD from domain, pass it in the domain
 And then finally, it is good
 The reason we're doing this is because I'm submitting to a web form and I want to parse the emails that come in to make sure they're valid emails
 I don't know, whatever
 But there's a problem that all of you have encountered many many many times at this point, which is that functions don't always return sometimes they have exceptions
 Sometimes there are errors
 And in particular, when we're dealing with strings, there's almost always the possibility of an error
 So get domain from email, that might cause an error
 What happens if they pass in an empty string? I don't know
 Maybe they've handled it, but maybe they haven't
 TLD from domain
 Maybe that's going to cause an error
 Is good
 Probably should never cause an error
 That should only ever return true or false
 Like an error is just false
 Right? So we're going to run into a problem that we aren't handling errors
 One way to solve that problem, which I'm sure you guys have done before
 I certainly have
 It's something of this sort
 We wrap all the things that might fail and try catch
 Or even better, we put one try catch around the entire thing
 And then it's just like try and do it
 And if it fails, I don't know where it failed
 I don't know what to do
 It just failed
 I'm sorry
 You know, return an error to the user
 And that's all you can do
 So this is one approach, but this kind of sucks
 It sucks for a lot of reasons, but in particular, it looks ugly
 That's the real reason
 At the end of the day, everything can be considered equal, but writing code that people can read and want to read is what's important
 So this is not something that you want to read
 It's not something you want to reason about
 What else can we do? What's another way to handle errors in JavaScript? I guarantee you guys have all seen this, but I also guarantee you guys have almost all shyed away from it
 What else could we do? Yeah
 Have them return error results instead of functions
 Definitely
 That could be a nice way to handle it
 We're still going to end up in the same place, though, where instead of necessarily having these try catch, what we would have is something of the sort
 This is going to be mad at me because it's scoping
 We would do something like if domain
 That is good
 Too much Python
 Something like this
 If TLD dot is good
 So we could wrap it up in kind of like a result type
 But we're still roughly in the same spot
 It looks a little bit different
 We aren't using exceptions, which is an improvement
 But we still have this constant check of is this good, is this good? Which, by the way, is one of the reasons why Rust is great
 Because all you have to do is use a question mark, and then you're kind of done
 But we'll get to that
 What's another approach? So if statements checking validity, definitely another approach
 How many of you have used promises by show of hands? How many of you are afraid to use promises? I definitely was for quite a while
 Because they're weird
 And generally a sink
 And that causes all sorts of issues
 But we can use promises to kind of resolve this
 Where what we're doing is we create this idea of is good
 That's our final result that we wanted
 And what we do is we're trying to chain together a couple of functions
 Any one of those functions might have an error
 But if they don't, then we just proceed naturally
 We get to have this kind of then do this, then do this, then do this
 Which is a lot more easy, a lot easier to read, at least in my mind than something of this sort
 Try catch, try catch, try catch
 We're just saying then do this, then do this, then do this
 And we can have our catch at the end that handles the various errors for us
 So this is kind of cool, but it's also not quite doing enough
 Which one of these can error? Which one of them cannot error? It doesn't tell us
 But we should know is good TLD never causes errors
 On the other hand, TLD from domain and get domain both might cause errors
 It'd be nice to have two different ways of handling that functionality, the error functionality and the non-error functionality
 So we can build this sort of optional type instead where we say create an optional, which you guys have seen before in Haskell with some, or with maybe, which could be some or none
 But you also have now seen it in Rust where it's okay or it's not okay
 Or I mean, there are a bunch of different ways of doing optional
 And so we create our optional from our string value, and then we get to nicely chain together our functionality
 We say first create our optional, then do this, then do this, and finally this map here is not your traditional functional mapping
 That's the same thing as then, but it can't error
 The point of map is to say run this function, but don't cause any errors
 This is now very concise and easy to read
 That's code that you can understand the flow of what's happening, without having to like dive in step by step what's going on
 And now that you guys have worked with Rust, you've seen results
 So results can make this even better because now we can have specific error types associated as we go
 Not only is it that we stop when we get an error, we know which function caused the error
 Is it an error on the TLD? Is it an error on the domain? That sort of thing
 Okay, questions so far
 Have I lost anybody at this point? This might seem a little random, but I promise you it's worth it
 Okay, we don't have too much more
 So there's a bit of a pattern here
 First of all, we have our then function
 Then is supposed to chain two operations together and create some sort of side effect
 The side effect might be an error, for example
 Our map chains two functions together that don't have a side effect
 So it's not going to cause an error, for example
 And we have our from, which is a constructor to create our optional
 What all of this is, is a monad, which is a kind of arbitrary word to just be learning
 It's not a big deal
 But this same functionality, then map and from, looks like what that we have previously seen today
 What were we doing earlier that resembles this? Right, we were chaining together arithmetic with some side effect of having logs being tacked on to our state every time
 In that situation inside of audit, what was our from function? Yeah
 Wrap with logs
 We were able to create our special type, saying wrap with logs, turning two into a number with logs
 What was then? Yeah
 No, it wasn't just another call to a function
 Then had a specific counterpart in our previous example
 Yeah
 Run with logs
 Run with logs was a function that took a value and a function to transform that value
 That's exactly what then is doing
 Then up above takes a value such as my email, it takes a transform, and it will give me back a potential
 It's going to give me back a result, which I can then transform again into this TLD from domain, and then I can transform it again with is good TLD
 So we've seen all this before just with different names
 Which means you guys have actually seen two monads at this point
 All right
 And now, what is the point? Why am I just standing up here talking about these monads with errors and whatnot? If we look at what some of you might consider very normal code, we have statement A, statement B, statement C
 If we consider the fact that those might be statements that we want to chain together in a monad form, you might write it something like this with our promises kind of notation
 Statement A dot then statement B dot then statement C
 Which we can once again just reformat, same exact code, reformatted to look like this
 And that might not be too surprising, but all that we have to do to transform from the first to the last is, delete that, semicolon, delete that, semicolon, delete that
 So all of that to show that monads are just an overload of the semicolon
 Monads which are kind of this weird esoteric functional programming concept are actually just the semicolon
 There are a way of rewriting what it means for two statements to go together
 We've talked a lot in imperative programming what the sequential command meant, where we have command 1, command 2, with a semicolon in between them
 And the power of a monad is that you get to choose what happens in between two commands
 You can decide how you want to change memory in between them, or you can decide that you want to update the logs, or that you want to print to screen, or anything of that sort
 You can control laziness with monads
 It's everything that has to do with sequencing
 So you've been using monads all of your programming life since you started writing with semicolons
 So maybe not if you were using Python
 But other than that
 The point here, monads change statements together
 And a statement is an expression with a side effect
 With an effect
 Okay
 I think this is crazy
 It's like so cool
 How many problems you think of where you start writing your code
 And then you get halfway through and you realize, actually I need to inject a command every time this style of programming is going to happen
 That's where a monad comes in
 It gets to give you this meta level of programming in between all your normal commands
 You can put whatever other commands you want in there
 It's like the super debugger
 So super, super powerful
 But I understand if you guys aren't as excited as I am
 But I'm very excited about this
 I just learned about this like a year ago and it blew my mind
 Like how is that? Because I wasn't teaching monads before then
 Because they're kind of weird and random
 Until you realize that they are overloading this emi column
 All right
 That's the end of code
 I want to spend just a second
 Finishing up on monads specifically in Haskell
 Before we get to that though, any questions on all of the code stuff? My goal was that coming into this lecture you either had never heard of a monad or you had heard of it and you were kind of frightened by the idea of it
 Because it's often shrouded in all this mathematics
 But really they aren't so crazy
 They're pretty approachable
 Any questions here? Yeah
 Yeah
 I'll drop these in the code section
 Any other questions? Okay
 So let's go all the way back to Haskell
 It's been a few weeks now
 But we never really covered this idea of IO
 Printing and reading from the user
 Printing to screen reading from the user
 Can we do this in Haskell as you would in a normal language? Yes? No? I'm not listening
 We got a few of you
 What's going on here? Yeah
 You can print and print in Haskell or if you would specifically
 Yeah
 So what would this
 Let's take a second
 You have the answer
 You'd like to answer
 Wait
 So before we do, let's look at what this would look like
 What I'm trying to do if I were writing this in a reasonable language
 I would be saying something like LS equals
 It's a list and I want to print X
 And I want to print Y
 So my list is equal to the result of calling print with each of these values
 Which print itself might return nothing
 So my list has two nothings in it
 That's fine
 I can have a list with two nothings in it
 But what is different about doing this in Haskell versus doing this in a language like Python? You have an answer though? Go for it
 Yeah
 If it has a whole need to know the return type of a call for something like put character in my operation
 Could you see that you need a nothing for an error? So the return type is something that we could kind of abstract away
 It might give me an error at runtime
 But I could say that this is a list of potential errors
 I don't necessarily need to
 But there is a different runtime issue that's coming on here
 Writing to I
O
 is a mutation which breaks the fact that Haskell is supposed to be pure
 True
 However, having a language that can't read or write is not a real language
 It's not going to help you do anything
 So Haskell is pure in that you can make pure programs
 But at the end of the day, you're going to need to do I
O
 Haskell does actually allow you to do it
 But that is fair
 It's not a pure language
 It's not a truly pure language
 Wait, both of you guys have been answering a lot of questions
 Who else has an idea here? What other feature of Haskell causes an issue? Yeah
 Is it because it's immutable? No, these values won't change here
 So that's going to be fine
 Like if we tried to update LS, that would cause an issue for sure
 But LS isn't going to change
 We have another feature
 Yeah, go for it
 No, so that's just saying it's the void type
 Because these put characters don't return anything to you
 So it's just a void, like a null value
 Yeah
 Yeah, Haskell is lazy
 We aren't going to evaluate these expressions until we use it
 So what order are these printed in? What does shrug mean? Yeah, it's not something we could know
 And I would say, like, what order are they printed in? They aren't printed
 Until we actually reference LS at zero, we're not going to print out either x or y
 So this is not OK because of laziness
 Laziness where we want to delay execution of our program until we need to use it is going to cause problems for all of I
O
 Because Haskell can get away with being pure most of the time and handle, like, sweep that under the rug
 But it can't get away with not being lazy
 Laziness is like the core idea of functional programming here
 So if we did something like length LS, that's going to give us a different result than if we called just head LS
 One of them would print x, y
 One of them would only print x
 If we didn't have laziness, we actually would be fine
 And we could get away with all of these impurities and void types and all that
 We could make it work
 But laziness itself forces Haskell to be more principled about how to do I
O
 It needs to be strictly evaluated
 It can't follow the same type of coding pattern that normal Haskell does
 So the way that Haskell solves this is using Monats
 Each I
O
 value is called an action
 And when an action happens, it has performed actions before and it will go into actions after
 And the idea of our Monads is being these things that chain together statements fits very nicely for these actions
 Because in order to execute statement 2, we need to execute statement 1 first
 So we get rid of laziness
 We can build laziness out of the language
 All right
 There are a lot more slides on Haskell, Monad, I
O
 That I'm not going to cover
 You guys can feel free to check them out
 The important things to know are
 I mean, this specifics aren't too big of a deal
 Instead of our wrap with logs, we have a function called return, which is a very poorly named function
 The point of return is it takes a non-Monad value and turns it into an I
O
 value so that we can start chaining together
 So it's not your typical return
 We aren't leaving functions or anything like that
 This is our wrap with logs
 And then there's composed, but bind is the important one
 We can also bind, which is also the then function, which is also run with logs, is two greater than signs and then an equal sign
 And the point of this function is it takes an action with a value A
 It takes an A, or a function that takes an A and returns an action
 And then it returns an action
 So from the type, the idea is we take in a value, a way to transform the inner value, and then we give back whatever the result of that transformation is
 OK, that is Haskell, known as
 There's plenty more on here
 These are not my slides, so they aren't as readable, I guess
 One other cool things that you can have laws, that's not super important
 We don't need to talk about it
 All right
 It is 326
 We have 19 minutes of class remaining until the midterm
 Who wants to do some review? Or first, if there are any last questions about Haskell, we can cover those
 Yes
 Monads will be on the exam to some extent
 It's not, if you understand the idea of chaining and wrap with logs and run with logs, you should be good to go
 If you also can think about Haskell
 But you don't need to do, what are all these laws, and how does bind work, and how do I work with all this in Haskell? What's due notation? None of that
 Yeah
 It will be
 Yeah
 Other questions about today's lecture
 Okay
 Let's talk about review
 What do you guys want to know? What can I help you with? Ask me anything
 Yeah
 Damn
 Yeah
 What type class question is going to be on the exam? I will give you a type class, and I will say, create an instance of this type class for this type class
 So you will be expected to write the Haskell code that makes that work, and then I'll say, do it again, and then I'll say, tell me something about it
 That's the type class question
 You will not be writing dictionary code
 Yeah
 But it would be good to understand how the dictionaries work
 Other questions? Yeah
 The small step semantic notation
 Will the rules be provided to you? I don't think so
 I think I did not include them
 Let me check that real quick
 Yeah
 No
 No
 They are not provided, and it wouldn't be fair for me to provide them at this point, because some, the exam is in different places at this point, so I can't edit it, unfortunately
 So you get two full cheat sheets front and back
 Yeah
 Other questions? That's also the extra credit question
 So if you don't care, you don't care
 Yeah
 No
 There is no truth
 Well, there's not going to be a similar truth false
 There is one part that is true false, but it's different
 The re-exsection is, here's lambda-count expression
 Reduce it
 Here's a Haskell function
 What's the type? And here's some JavaScript closure
 What is the output? Yeah
 No
 Yeah
 So they aren't true false
 Yeah
 What else? It's nine pages, but there's a lot of white space
 And the first page is the cover sheet
 So it's like eight pages with a lot of white space
 Yeah
 JavaScript closures will involve activation records
 You don't need to draw the activation records
 You only need to tell me the answer
 If you don't know how the activation records work, you can guess a number between one and a hundred, and there's a chance that you'll be right
 Otherwise, you're going to want to know how the activation records work
 But you don't need to draw them out
 You can just, you know, do it in your head
 Yeah
 Do you need to do the activation records for exceptions? No
 But it would be good to know if there is an exception at any point in code
 Where does that exception get caught? So again, that's the sort of thing that you will just, you don't need to show any work for
 You just get to say it would be caught right here
 And that will be good enough
 Yeah
 Yeah
 For object oriented, I'm going to be testing you on two main categories, sub typing, dynamic lookup
 Because inheritance is ridiculously easy
 It's just copying code
 And encapsulation is something that's just, you know, like a broad level idea that's hard to test
 So be able to do dynamic lookup in C++ with virtual tables and function sub typing like it was on homework seven
 Yeah
 Those should be posted
 So homework seven and eight solutions are posted
 You should be able to find them online
 Let me know if that's not the case
 These are all easy questions so far
 What are the answers? Yeah
 I can't, can't do that one from memory
 Sorry
 Yeah
 For continuation passing style does a function take an error continuation if it doesn't throw
 Typically no
 You can always pass a success and failure continuation
 So if the question shows you give both then provide both
 But generally speaking, you don't need one
 You should be comfortable writing CPS, transforming from regular JavaScript to CPS
 And you should be comfortable doing that with errors
 Yeah
 So that's homework eight
 What else? Yeah
 No, no small talk
 Small talk questions are hard to grade
 Because it's like you guys haven't written any of it
 And it's not
 It's all kind of wishy washy
 They're good for concept questions
 But no small talk
 And we could just go to office
 Yeah
 What's up? An example of the tables
 Sure
 Do you have anything in mind? Fair enough
 Let's create a class a with a non virtual function
 And let's create a class B with a with the same function
 No, actually, let's not have that function
 Let's create a virtual function to
 And B will be a subtype of a public
 And let's create a class C is a subtype of E
 And it will have a virtual void function to
 We've got three classes
 Class A has a non virtual function function
 Class B inherits from a and has a virtual function to class C inherits from B and has that same function to
 This is our setup
 We have some classes
 Cool
 Then we're going to create an A pointer is a new A
 What happens if I call a dot function? Yeah
 It runs this code right here
 Cool
 Nothing crazy
 What happens if I call a dot function to
 Yeah
 Compile air
 A doesn't have a function to cool
 Great
 What about
 I create my new B
 What happens when I call B dot function
 Yeah
 It's going to call is version of function
 How would that change if B also had an implementation of function? It will call B's version of function
 Why? Yeah
 Right
 B is of type B as we've said right here
 That's what tells us the type
 And non virtual functions, which is what function is non virtual functions go based on the type at compile time of the kind of closest approximation of your class
 So this would call if we had a function function here, it would call B's version
 All right
 What if we do B dot function to which version is executed? B's
 Great
 Is there a way to get a C's version of function to on B can be ever run C's version of function to? No
 No
 No
 It's not possible
 The way that we would have to do that is somehow cast B to be a C pointer, which is illegal
 You can't cast a generic shape to be a square
 Because what if it was a triangle that wouldn't work? Yeah
 Great question
 If we create a B pointer, C equals new C and we call C dot function
 What what is executed? C dot f n
 What rounds? A's version of function
 There's only one version of function
 If we had f n defined inside of B
 If we had overwritten this function inside of B and we then called C dot f n, which version would run? B's are A's
 B's
 Cool
 What about C dot function to? Which version is executed? C's version
 This function to will run
 Why? We're going to use the V table here, which involves the run time representation of the object
 The run time representation is that it is a C
 So a C has the function function to in its V table
 If that sequence of starting from here, choose one of these functions
 What's run? Choose one of those functions
 If that feels comfortable, great
 If it doesn't, test it out
 You can write all of this code in your IDE, compile it and see plus plus and run it
 You will see what happens
 Just put little like C outs right here
 And say print chunk one, chunk two
 Yeah
 Okay
 Function two is no longer virtual
 When we call C dot function two, which version is executed? We're doing this
 C dot function two
 What version is going to be executed? B's version
 Why? Yeah, go for it
 Yeah, see this variable is of type B
 Non-virtual functions use the static compile time type of the object to figure out what function to run
 The type is of B
 So we're going to use B's version
 Yeah
 You can't change the virtualness of a function
 That's right
 So when we have virtual function two and then function two here is not listed as being virtual, this function is still virtual, even though it doesn't look virtual
 If we do this, we get a compiler
 Yeah
 We can't change the virtualness of a function as we inherited
 Any and all combinations of this are fair game for the midterm
 So if we create an A that's a C or a C that's a C or if we have the A is calling a virtual function or a non virtual function, all of those different combinations could be on the midterm
 Yeah
 The virtual keyword makes the function look up dynamic, which means it's happening at runtime
 Yeah, exactly
 Yeah
 Can you have a virtual function today? This is fine
 Yeah
 Because this is still virtual
 This function here is still virtual
 If we say that it's virtual up here, it's virtual down here
 Yeah
 That's just like C++ syntax
 They decided it was that way
 It starts up
 We're like the highest level of bread for all below
 Right
 I will be in my office for another two hours, do an office hours, feel free to drop by
 Otherwise, best of luck on the midterm
 Yeah
 Yeah
 So, yeah
 So, so if we have try code, except catching code
 Right
 Then, I guess, okay, so we should have continued
 So, we want to try this thing
 And if it succeeds, we want to do this
 And if it fails, we want to do that
 And then no matter what we're going to come back right here
 So, this chunk right here is the thing that could fail
 Right
 I guess this can also fail, but we can ignore that
 So, this piece can fail if it does fail go here, if it doesn't fail go here
 That means when we rewrite this, we're going to be calling code
 And we're going to be passing a continuation, a success continuation of continue code
 And our fail continuation will be our catch code
 So, the thing that will cause an error or that might cause an error is going to take the two continuations
 Right
 Right
 But the homework, like dives into that and kind of explains why it's doing what it's doing
 So, take a look at the solutions and kind of use that as a reference to see why is it, yeah
 Yeah, what's up? Yeah, what's up? So, I have a question about virtual
 So, for example, there are three virtual functions at GH
 And so, the virtual table for, so the runtime representation is like this
 But what is, for example, function F is not virtual
 And the GNH is still virtual and so the VT go for C is no longer look like this
 Right
 A we are B removed
 Yep
 And only GNC
 Yep
 Yeah, exactly
 So, the VT go is only for the virtual function
 Yeah
 So, it's V stands for virtual
 It's the virtual table
 So, virtual table has virtual functions
 So, I think that's a good question
 And I have a question about the overlord and override
 So, for this case, class B have a function named GNH
 And overrides is a G
 That's right
 It overrides it
 And see overrides the age
 That's right
 So, override just, we can replace the function
 Yeah
 Overriding is replacing
 Overloading means you have multiple
 Yeah
 You have a question about the objects
 So, for example, we have, yes, we'll have that
 Activation for the Jax
 Oh, it's for this class
 There is a code for point equals for the color point object
 So, it's not being used
 Because, so the colored point only will point to the colored point equals
 This still exists because normal points will use that
 But colored points don't have access to it
 Oh, so there is no, so in the color point object, there is no line point to the


 Exactly
 Yep
 Is that the original? So, it has also override? Yes, that's right
 It's overriding
 So, it only has one variant
 Yeah
 What's up, Dan?