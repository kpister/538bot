WEBVTT

00:00.000 --> 00:05.000
This is a course on the principles and paradigms of programming languages.

00:30.000 --> 00:32.000
This is a course on the principles and paradigms of programming languages.

01:00.000 --> 01:28.880
This is a course on the principles and paradigms of programming languages.

01:29.880 --> 01:31.160
Is there a fourth option?

01:31.160 --> 01:32.120
Is that what you said?

01:32.120 --> 01:32.840
Yeah, really hard.

01:32.840 --> 01:33.340
Really hard.

01:40.160 --> 01:42.160
This is anonymous, just so you guys know.

01:42.160 --> 01:44.480
I'm not recording what you say.

01:48.160 --> 01:50.160
Can you guys see two questions, by the way?

01:50.160 --> 01:52.000
Or just one?

01:52.000 --> 01:52.760
You see two?

01:52.760 --> 01:53.260
Great.

01:53.260 --> 01:53.760
Thank you.

01:58.880 --> 01:59.840
I'm taking an exam.

01:59.840 --> 02:01.840
I'm trying to figure out, like, what is it?

02:01.840 --> 02:03.820
Are we going to do, like, a couple of them?

02:03.820 --> 02:04.320
Yeah.

02:04.320 --> 02:05.320
I don't know that.

02:05.320 --> 02:07.800
Like, I feel like we're going to do a couple of those.

02:07.800 --> 02:09.280
Yeah, professor, really hard.

02:09.280 --> 02:10.760
They do this every day, right?

02:10.760 --> 02:12.240
And then they're like, I don't know.

02:12.240 --> 02:13.720
So I'm like, you're really weird.

02:13.720 --> 02:14.720
I'm like, I don't know.

02:14.720 --> 02:15.720
I'm like, I don't know.

02:15.720 --> 02:16.720
I'm like, I don't know.

02:16.720 --> 02:17.720
I'm like, I don't know.

02:17.720 --> 02:20.720
I think my answer to that is I'm like, I'm not great.

02:20.720 --> 02:21.720
I'm like, I don't know.

02:21.720 --> 02:22.720
I'm like, I don't know.

02:22.720 --> 02:23.720
I'm like, I don't know.

02:23.720 --> 02:24.720
I'm like, I don't know.

02:24.720 --> 02:25.720
Fair enough.

02:25.720 --> 02:26.720
Yeah.

02:26.720 --> 02:39.720
Can we get participation points from participating in class, or is that only in class?

02:39.720 --> 02:40.720
Yes.

02:40.720 --> 02:46.720
In class matters, but a lot of it is, like, if I can know your name.

02:46.720 --> 02:53.000
I have a photo of everyone, and I match it with your name, and then based on how well

02:53.000 --> 02:55.600
I remember you participating in class.

02:55.600 --> 02:57.520
So it's a little bit of a loose system.

02:57.520 --> 03:01.480
But it kind of works.

03:01.480 --> 03:02.480
Bring a name tag.

03:02.480 --> 03:03.480
It might work.

03:03.480 --> 03:04.480
It might help.

03:04.480 --> 03:06.160
All right, guys.

03:06.160 --> 03:10.600
We have 27 responses here, so I think we are gonna close it out, because it looks like

03:10.600 --> 03:12.360
there are roughly 30 people.

03:12.360 --> 03:15.160
Those of you in the back, you should scoot forward.

03:15.160 --> 03:16.160
Why not?

03:16.160 --> 03:17.160
You know?

03:17.160 --> 03:19.020
Come on up a little bit.

03:19.020 --> 03:24.040
We will be looking at some code on the screen, and the code is a little bit small, so the

03:24.040 --> 03:27.800
closer up you are, the better.

03:27.800 --> 03:30.800
Can I show you the responses?

03:30.800 --> 03:32.800
Responses.

03:32.800 --> 03:34.800
Okay.

03:34.800 --> 03:37.840
That sounds good.

03:37.840 --> 03:43.180
So harder than it was medium, and definitely not easy.

03:43.180 --> 03:46.680
And then in terms of fairness-ish.

03:46.680 --> 03:51.920
All right.

03:51.920 --> 03:54.200
So compared to last semester, maybe a bit harder.

03:54.200 --> 03:55.200
Good to know.

03:55.200 --> 03:57.700
I will take that into account as we go forward.

03:57.700 --> 04:01.720
Thank you for your feedback.

04:01.720 --> 04:05.560
Don't forget, we do drop the lowest midterm, so if that's this one, great.

04:05.560 --> 04:07.560
If it's not this one, also great.

04:07.560 --> 04:09.760
Up to you.

04:09.760 --> 04:12.280
All right.

04:12.280 --> 04:17.200
Welcome to a fun lecture in CS538.

04:17.200 --> 04:21.520
I try and add these as much as I can, because I like to talk about things that aren't just

04:21.520 --> 04:28.520
the stuff that's on the ACM, like, requirements for what principles and paradigms of programming

04:28.520 --> 04:30.280
languages is.

04:30.280 --> 04:33.200
Before we get into the fun stuff, some notes.

04:33.200 --> 04:35.740
The PA and the homework are not going to be released.

04:35.740 --> 04:40.240
If you already have a copy somehow, because you stole them while they were halfway released

04:40.240 --> 04:42.040
or something, ignore them.

04:42.040 --> 04:43.480
They are not released.

04:43.480 --> 04:46.080
You don't have to do them until after spring break.

04:46.080 --> 04:49.480
Have a fun spring break.

04:49.480 --> 04:50.920
Midterms will be graded soon-ish.

04:51.320 --> 04:52.320
I have them all scanned.

04:52.320 --> 04:55.840
The TA and I will be grading them.

04:55.840 --> 05:00.680
We will get those back to you hopefully within a week, and then once that is done, I will

05:00.680 --> 05:04.880
be able to update Canvas with your current grade.

05:04.880 --> 05:14.120
This will be unscaled, so it won't be â€“ if there is a curve, there's no curve on this

05:14.120 --> 05:19.000
grade, but it will have your 10% bonus for submitting early.

05:19.000 --> 05:25.760
It will have the individual weighting of each assignment versus the other assignments.

05:25.760 --> 05:30.040
This should be a pretty accurate reflection of what your grade will be at this point in

05:30.040 --> 05:31.400
time.

05:31.400 --> 05:34.800
I'm hoping that that will be done before spring break ends.

05:34.800 --> 05:41.640
It takes a while, so please be patient.

05:41.640 --> 05:48.360
I have a coding project that is school-related, so it's not work, it's not industry stuff.

05:48.360 --> 05:49.880
It's a coding project.

05:49.880 --> 05:56.920
If somebody is a very proficient Python coder and interested in hacking on something, come

05:56.920 --> 06:02.600
chat with me either after class or in office hours or send me an email.

06:02.600 --> 06:03.600
It might be hard.

06:03.600 --> 06:04.600
I don't know.

06:04.600 --> 06:05.600
We'll figure it out.

06:05.600 --> 06:10.320
There is a course eval that is the midterm course eval.

06:10.320 --> 06:13.020
You got it from the school.

06:13.020 --> 06:14.520
They ask you to fill it out.

06:14.520 --> 06:15.520
Please do.

06:15.960 --> 06:21.920
I appreciate it, because I take that information into all of the rest of my teaching.

06:21.920 --> 06:30.000
Let me know if I'm doing anything poorly or well, and I will try and fix or stay the course.

06:30.000 --> 06:31.000
Those are my notes.

06:31.000 --> 06:32.380
There were a lot of them.

06:32.380 --> 06:39.600
Any notes from you guys?

06:39.600 --> 06:42.120
It's a fun lecture, so we can talk about anything.

06:42.120 --> 06:43.120
Anything on your mind?

06:43.120 --> 06:44.120
Yeah?

06:44.120 --> 06:48.920
These lecture slides are called static analysis.

06:48.920 --> 06:49.920
They are on Canvas.

06:49.920 --> 06:50.920
Yep.

06:50.920 --> 06:51.920
Yep.

06:51.920 --> 07:04.080
I will post the solutions to the midterm.

07:04.080 --> 07:07.760
I don't typically go over them, but we can do that in office hours if you want to stop

07:07.760 --> 07:12.360
by.

07:12.360 --> 07:14.640
Anything else?

07:14.640 --> 07:17.960
All right.

07:17.960 --> 07:21.200
Today's lecture is loosely based...

07:21.200 --> 07:22.920
It was going to be something totally different.

07:22.920 --> 07:28.480
And then I read this article this morning called fixing the next 10,000 aliasing bugs.

07:28.480 --> 07:31.240
And just from the title, you know that's gonna be super exciting.

07:31.240 --> 07:32.240
I was like, yes!

07:32.240 --> 07:35.920
This is the thing I want to spend an hour and a half chatting about.

07:35.920 --> 07:37.880
No, not actually.

07:37.880 --> 07:43.600
It's a really boring looking title, and only a real PL nerd would get excited about that.

07:43.600 --> 07:48.120
But that's because they missed out on the real title.

07:48.120 --> 07:54.760
Which is using type inference to make $150.

07:54.760 --> 07:57.200
Minor correction.

07:57.200 --> 08:01.320
To steal $150 million.

08:01.320 --> 08:07.920
So the algorithm that we have been covering, Hindley-Milner type inference, loosely can

08:07.920 --> 08:15.800
be used to describe an attack that took place two years ago and resulted in somebody literally

08:15.800 --> 08:19.120
stealing $150 million.

08:19.120 --> 08:23.000
All of the material, or almost all of the material, comes from this blog post, the one

08:23.000 --> 08:25.600
that I showed at the start there.

08:25.600 --> 08:27.960
All the animations are my own.

08:27.960 --> 08:29.800
All right.

08:29.800 --> 08:32.880
So let's take a look at Java.

08:32.880 --> 08:37.160
I'm certainly not proficient in Java, but I have a little piece of Java for you.

08:37.160 --> 08:43.280
If you have your computer with you, feel free to go to my GitHub, to the CS538 snippets

08:43.280 --> 08:47.520
repo and take a look at the code that is there.

08:47.520 --> 08:52.120
Otherwise, I'm gonna put the code up on the screen so we can all look at it as a class.

08:52.120 --> 08:57.800
But if you want it so you can play around with it, do so.

08:58.800 --> 09:01.800
All right.

09:19.800 --> 09:20.800
All right.

09:20.800 --> 09:29.440
So in that folder, you should have a bug.java, if you can find it.

09:29.440 --> 09:31.800
And when we look at this...

09:31.800 --> 09:34.800
All right.

09:34.800 --> 09:39.800
I can go one bigger, two bigger, three bigger.

09:39.800 --> 09:40.800
Yeah.

09:40.800 --> 09:41.800
Is that readable?

09:41.800 --> 09:45.840
If it's not readable, there are plenty of seats up front.

09:45.840 --> 09:47.800
So please do come up front.

09:47.800 --> 09:49.500
All right.

09:49.500 --> 09:51.500
We have Java code.

09:51.500 --> 09:57.300
I have not written Java code since probably my sophomore year of college.

09:57.300 --> 10:01.500
So even getting this to compile was like, what is going on?

10:01.500 --> 10:02.820
But I did.

10:02.820 --> 10:05.900
So that's good.

10:05.900 --> 10:07.800
We have a class called MyList.

10:07.800 --> 10:13.180
This might come out from you having to write a data structure in one of your intro CS classes.

10:13.180 --> 10:19.100
You're told, write a data structure for a list in Java.

10:19.100 --> 10:24.620
This list should be able to add items of arbitrary length.

10:24.620 --> 10:31.300
So even though it started out as an array of ten items, once I add the eleventh item,

10:31.300 --> 10:36.180
it should be able to restructure and become an array of length 11.

10:36.180 --> 10:37.220
Or 20.

10:37.220 --> 10:38.760
Or 100.

10:38.760 --> 10:42.220
So it should be a dynamically lengthed list.

10:42.220 --> 10:46.500
But we have to stick within Java, so we're going to use an array to do that.

10:46.500 --> 10:52.100
And every time we go past our bounds, we will reallocate a new array, copy over all

10:52.100 --> 10:56.180
the old elements, and be good to go.

10:56.180 --> 10:57.320
Great.

10:57.320 --> 10:59.780
So we have some code.

10:59.780 --> 11:05.540
My challenge to you is identify the bug.

11:05.540 --> 11:09.000
And I'll give you five to ten minutes to do so.

11:09.000 --> 11:16.020
If you have code on your computer, feel free to download it, compile it, run it, and figure

11:16.020 --> 11:17.420
out what's going on.

11:17.420 --> 11:20.020
If you don't have code, talk to somebody next to you.

11:20.020 --> 11:22.920
Or stare at this for a little while.

11:22.920 --> 11:26.740
There is one piece at the very bottom that's not being shown.

11:26.740 --> 11:34.720
All that is is the main function, where I create a list S, I create a list T, add elements,

11:34.720 --> 11:40.020
and then, like, concatenate the two lists together.

11:40.020 --> 11:45.700
All right.

11:45.900 --> 11:47.900
So...

11:47.900 --> 11:48.900
Find the bug.

11:48.900 --> 11:53.500
I'll wander around and chat with you guys individually to see what you come up with.

11:53.500 --> 11:55.780
But give it five or ten minutes of debugging.

12:15.700 --> 12:16.700
And I'll see you guys later.

12:16.700 --> 12:17.700
Bye.

12:17.700 --> 12:17.700


12:45.700 --> 12:46.700
Bye.

12:46.700 --> 12:46.700


13:15.700 --> 13:16.700
Bye.

13:16.700 --> 13:16.700


13:46.700 --> 13:47.700
Bye.

13:47.700 --> 13:48.700
Bye.

13:48.700 --> 13:48.700


14:15.700 --> 14:16.700
Bye.

14:16.700 --> 14:16.700


14:46.700 --> 14:47.700
Bye.

14:47.700 --> 14:48.700
Bye.

14:48.700 --> 14:48.700


15:15.700 --> 15:16.700
Bye.

15:16.700 --> 15:16.700


15:46.700 --> 15:47.700
Bye.

15:47.700 --> 15:48.700
Bye.

15:48.700 --> 15:48.700


16:16.700 --> 16:17.700
Bye.

16:17.700 --> 16:18.700
Bye.

16:18.700 --> 16:18.700


16:45.700 --> 16:46.700
Bye.

16:46.700 --> 16:47.700
Bye.

16:47.700 --> 16:47.700


17:15.700 --> 17:16.700
Bye.

17:16.700 --> 17:17.700
Bye.

17:17.700 --> 17:17.700


17:46.700 --> 17:47.700
Bye.

17:47.700 --> 17:48.700
Bye.

17:48.700 --> 17:48.700


18:16.700 --> 18:17.700
Bye.

18:17.700 --> 18:18.700
Bye.

18:18.700 --> 18:18.700


18:45.700 --> 19:09.820
Okay.

19:09.820 --> 19:12.540
So what did we come up with?

19:12.540 --> 19:13.540
Who's got some ideas?

19:13.540 --> 19:17.260
I heard a lot of different ideas floating around.

19:17.260 --> 19:19.340
Did anybody get an actual error?

19:19.340 --> 19:24.300
Was anybody able to compile this and run it with some sort of main?

19:24.300 --> 19:28.900
Like changing this at all and getting an actual error?

19:28.900 --> 19:30.300
Okay.

19:30.300 --> 19:33.060
Fair enough.

19:33.060 --> 19:41.180
Did anybody come up with something that might be going wrong?

19:41.180 --> 19:50.660
All right.

19:50.660 --> 19:53.140
I'd like to poll the class.

19:53.140 --> 19:59.980
You have four functions, if you include the constructor as a function.

19:59.980 --> 20:02.380
Where is the bug?

20:02.380 --> 20:04.820
Could be based on your gut or just...

20:04.820 --> 20:05.820
I don't know.

20:05.820 --> 20:06.820
Something else.

20:06.820 --> 20:07.820
But I'm curious.

20:07.820 --> 20:08.820
Where do you think the bug is?

20:08.820 --> 20:12.020
Choose one of the four functions.

20:12.020 --> 20:13.100
The constructor.

20:13.100 --> 20:15.980
My list.

20:15.980 --> 20:18.980
Ensure capacity.

20:18.980 --> 20:20.700
Add.

20:20.700 --> 20:21.700
Add all.

20:21.700 --> 20:22.700
Okay.

20:22.700 --> 20:25.340
We got about a 50-50 split.

20:25.340 --> 20:28.380
Add all and ensure capacity.

20:28.380 --> 20:29.380
So which one is it?

20:29.580 --> 20:32.860
First of all, let's double check that I haven't, like,

20:32.860 --> 20:37.940
just cheated the whole time, and we can actually compile this thing.

20:37.940 --> 20:44.820
Compiles, it gives us a warning for our types, but that's fine.

20:44.820 --> 20:47.740
And then if we actually run it, we do actually run it.

20:47.740 --> 20:51.300
So there's no bug.

20:51.300 --> 20:56.300
That's gonna be annoying.

20:56.300 --> 20:58.780
In this main.

20:58.780 --> 21:03.300
In this version of main, where we create a list, we create a second list,

21:03.300 --> 21:06.020
we add an element to the first list, or to the second list,

21:06.020 --> 21:09.540
add an element to the second list, and then add them together.

21:09.540 --> 21:10.620
This part's fine.

21:10.620 --> 21:11.620
No bugs.

21:11.620 --> 21:12.620
Compiles.

21:12.620 --> 21:13.620
Runs.

21:13.620 --> 21:14.620
Without issue.

21:14.620 --> 21:26.700
I'm gonna make a one-character change.

21:26.700 --> 21:31.180
That's all that we're gonna change.

21:31.180 --> 21:35.980
This is what it was.

21:35.980 --> 21:47.220
This is what I'm changing it to.

21:47.220 --> 21:49.460
What happens?

21:49.460 --> 21:54.220
What we are saying now is that we're taking a list S

21:54.220 --> 22:02.740
and add all the elements from S to that list.

22:02.740 --> 22:03.740
So what's gonna happen?

22:03.740 --> 22:04.740
Yeah.

22:04.740 --> 22:14.980
There's gonna be a problem with ensure capacity.

22:14.980 --> 22:17.260
Let's run through it and see if there is.

22:17.260 --> 22:19.540
So we hit add all.

22:19.540 --> 22:22.860
Our parameter C is the list S.

22:23.380 --> 22:26.780
We are in the scope of S itself.

22:26.780 --> 22:33.100
So when we call ensure capacity, we're using the S version of ensure capacity,

22:33.100 --> 22:38.460
with the length of S and the length of S.

22:38.460 --> 22:42.060
So 2 times S.

22:42.060 --> 22:46.980
When we call ensure capacity with 2 times the length of S,

22:46.980 --> 22:51.460
which in this case is length 1, so it's a value of 2,

22:51.460 --> 22:56.780
we would check to see is min capacity 2 greater than array.length?

22:56.780 --> 22:57.780
Yes.

22:57.780 --> 23:01.060
Array.length is 1.

23:01.060 --> 23:06.060
So then we're going to set the new capacity equal to 2.

23:06.060 --> 23:09.340
The max of 2 and 2.

23:09.340 --> 23:17.020
Create a new list of length 2 and copy the old list into the new list.

23:17.020 --> 23:19.700
Is there a bug there?

23:19.700 --> 23:26.340
Did anything break?

23:26.340 --> 23:29.420
I don't think anything did break.

23:29.420 --> 23:42.340
And yet, so if we recompile and we rerun, we crash.

23:42.340 --> 23:46.220
So ensure capacity did not have any issue,

23:46.220 --> 23:49.780
but making this change did break something.

23:49.780 --> 23:52.540
That leaves the second group.

23:52.540 --> 23:58.340
The group that had the intuition that the issue is in add all.

23:58.340 --> 24:06.020
Something has gone wrong in add all after our ensure capacity check.

24:06.020 --> 24:07.020
What is it?

24:07.020 --> 24:08.020
Yeah.

24:08.020 --> 24:25.980
Right.

24:25.980 --> 24:34.660
So in Java, we are referencing this S, the length variable on that S,

24:34.660 --> 24:37.780
which we are incrementing inside of this for loop.

24:38.540 --> 24:48.380
However, our for loop check is saying until we are less than the length of C.length.

24:48.380 --> 24:50.900
While we are less than C.length.

24:50.900 --> 24:55.820
C is S. And we are incrementing the value of S's length.

24:55.820 --> 24:59.540
So we will continue going through this for loop over and over and over

24:59.540 --> 25:03.580
until we actually hit the bounds of the entire loop,

25:03.580 --> 25:14.460
which is when we get our final array index out of bounds exception.

25:14.460 --> 25:19.660
So I've got some slides to make this a bit more step by step.

25:19.660 --> 25:27.340
Let's go to those.

25:27.340 --> 25:31.100
The thing that we have, actually, let's go back.

25:31.100 --> 25:32.700
Let's do this backwards.

25:32.700 --> 25:37.220
We start with add all.

25:37.220 --> 25:43.180
And our first step of add all is saying let's ensure the capacity of the current list

25:43.180 --> 25:47.800
is greater than the old list with the new list combined.

25:47.800 --> 25:51.180
So make sure that we have enough space for whatever we're doing.

25:51.180 --> 25:55.140
And this is the, like, we're calling this the correct way.

25:55.140 --> 26:00.460
On the first iteration, I is zero, length of our list is two,

26:00.460 --> 26:06.020
length of C.length, or C.length is one.

26:06.020 --> 26:10.900
We execute the body of the loop, incrementing our length.

26:10.900 --> 26:16.420
And then setting C.length, or C.length is still one.

26:16.420 --> 26:21.940
Loop back through, am I on the right one?

26:21.940 --> 26:22.940
I am on the right one.

26:22.940 --> 26:24.260
We go back to the top.

26:24.260 --> 26:27.380
We check is I less than C.length.

26:27.380 --> 26:28.380
It's no longer.

26:28.380 --> 26:29.380
So we're done.

26:29.380 --> 26:35.700
This is if we ran it with the correct inputs, like not passing S. We don't run into any

26:35.700 --> 26:41.660
issue because C.length has remained constant.

26:41.660 --> 26:49.100
On the other hand, if we pass in S as our parameter, first we do that same ensure capacity

26:49.100 --> 26:50.660
check.

26:50.660 --> 26:57.940
Then we say I is equal to zero, length is equal to two, C.length is equal to two.

26:57.940 --> 27:05.220
When we get to our length++, we increment not only our length, but also C.length.

27:05.220 --> 27:09.860
Because C.length is the same as our length.

27:09.860 --> 27:15.140
Which means that C.length increments with our own length.

27:15.140 --> 27:20.380
We go back up to the next time, increment I. I is less than C.length.

27:20.380 --> 27:29.660
And this will continue forever and ever and ever until we actually index into the array

27:29.660 --> 27:36.540
at an invalid location.

27:36.540 --> 27:41.340
So this is the bug that we have found.

27:41.340 --> 27:50.300
Questions on the bug?

27:50.300 --> 27:52.020
It's a bit involved.

27:52.020 --> 27:59.740
I recognize that.

27:59.740 --> 28:05.220
So if we go back to what went wrong, we had this implicit invariant.

28:05.220 --> 28:12.260
And it was that the length of the input list does not change between the ensure capacity

28:12.260 --> 28:15.380
call and the for loop.

28:15.380 --> 28:27.060
Outside of our add list, or add all function, our input list length does not change.

28:27.060 --> 28:33.420
And you might look at that and say, that's safe, so long as we aren't multithreading.

28:33.420 --> 28:38.420
It makes sense that if we're multithreading, maybe somebody updated the list in between.

28:38.420 --> 28:41.380
But if we aren't multithreading, maybe we're safe.

28:41.380 --> 28:43.960
What we found is that no, that's not true.

28:43.960 --> 28:50.520
If we pass in the same object itself, when we increment length, we're incrementing the

28:50.520 --> 28:52.240
input length as well.

28:52.240 --> 29:02.360
Which means we've broken our invariant.

29:02.360 --> 29:03.360
Sound good?

29:03.360 --> 29:04.360
Questions?

29:04.360 --> 29:09.740
All right.

29:09.740 --> 29:15.820
So how does this turn into $150 million?

29:15.820 --> 29:20.140
How many of you are familiar with DAOs?

29:20.140 --> 29:21.140
Some number of you.

29:21.140 --> 29:23.340
Follow, like, news and whatnot.

29:23.340 --> 29:28.260
So before we talk about what a DAO is, we should take a second to say, what is a smart

29:28.260 --> 29:29.260
contract?

29:29.260 --> 29:31.700
How many of you know what smart contracts are?

29:31.700 --> 29:32.700
Very few.

29:32.700 --> 29:33.700
How many of you have written a smart contract?

29:33.700 --> 29:34.700
All right.

29:34.700 --> 29:37.060
One or two.

29:37.060 --> 29:47.140
So a smart contract is a small piece of public code, very similar to an API endpoint.

29:47.140 --> 29:54.220
However, different than an API endpoint is that it's run on a distributed cloud.

29:54.220 --> 30:00.020
Typically associated with what's called a blockchain.

30:00.020 --> 30:06.260
And the way that you purchase credits so that you can run code on this distributed

30:06.260 --> 30:12.020
cloud is that you pay with a digital currency.

30:12.020 --> 30:16.020
Such as Doge.

30:16.020 --> 30:21.060
What this code is, though, is effectively anything.

30:21.060 --> 30:28.340
We can write whatever web app we want and run it on a distributed cloud.

30:28.340 --> 30:29.660
For example, ETH.

30:29.660 --> 30:33.600
Or I guess Doge doesn't actually have smart contracts, but that's beside the point.

30:33.600 --> 30:37.900
So there are languages designed to write smart contracts.

30:37.900 --> 30:41.540
One of them, for example, is called Solidity.

30:41.540 --> 30:43.780
Solidity looks something like this.

30:43.780 --> 30:47.380
We create a contract and we give it a name.

30:47.380 --> 30:50.140
And it has some stored data.

30:50.140 --> 30:53.260
And then we define functions on that contract.

30:53.260 --> 30:56.500
Set and get, for example.

30:56.500 --> 31:02.980
Someone can then call these functions and provided they pay the gas to make them happen,

31:02.980 --> 31:07.380
they will execute that code.

31:07.380 --> 31:13.420
This is a really convenient model compared to the idea of having to spin up your own

31:13.420 --> 31:19.020
EC2 box, where you're running all of your functions and having it all handled there.

31:19.020 --> 31:25.060
You just deploy your code and pay other people to run it for you when you want it to be run.

31:25.060 --> 31:26.060
Very cool.

31:26.060 --> 31:33.820
In theory, crypto and Web3 have kind of spiraled into insanity at this point.

31:33.820 --> 31:41.660
But fundamentally, cool idea.

31:41.660 --> 31:43.540
You guys like seeing real code?

31:43.540 --> 31:54.220
So this is a smart contract that I wrote that creates, like, NFTs of those audio snippets

31:54.380 --> 31:56.620
that I showed you from before.

31:56.620 --> 32:02.220
So not only do you put one line of HTML and I turn your web page into a podcast, I also

32:02.220 --> 32:07.660
mint an NFT that you can then put on OpenSea.

32:07.660 --> 32:09.140
This feature never deployed.

32:09.140 --> 32:11.460
It was just more of a meme.

32:11.460 --> 32:15.740
And then to show investors and be like, hey, yeah, we're Web3.

32:15.740 --> 32:19.900
Anyway, back to the DAO.

32:19.900 --> 32:24.340
So what is a DAO?

32:24.340 --> 32:33.220
The original DAO was this relatively reasonable idea that we could build a smart contract

32:33.220 --> 32:39.100
and have it be used as a distributed investment fund.

32:39.100 --> 32:42.780
Remove the idea of a hedge fund.

32:42.780 --> 32:44.660
Remove big banks.

32:44.660 --> 32:45.660
They suck.

32:45.660 --> 32:48.220
They only help the very wealthy.

32:48.220 --> 32:52.540
Let's have a distributed hedge fund, effectively.

32:52.540 --> 32:54.060
The functionality is very simple.

32:54.060 --> 32:56.060
You put money in.

32:56.060 --> 32:58.460
The money grows over time.

32:58.460 --> 33:01.460
You vote on what the fund should invest in.

33:01.460 --> 33:02.900
And you vote...

33:02.900 --> 33:08.940
Your weight of your vote is corresponding to your percent ownership of the DAO.

33:08.940 --> 33:12.780
And then obviously you get to pull money out.

33:12.780 --> 33:18.540
Once it has grown and accumulated value.

33:18.540 --> 33:20.860
Power to the people.

33:20.860 --> 33:21.860
Distribute finances.

33:21.860 --> 33:23.860
It's great.

33:23.860 --> 33:25.860
Oops.

33:25.860 --> 33:29.060
So...

33:29.060 --> 33:31.700
It's a great idea.

33:31.700 --> 33:38.900
But now we're starting to put real money in code where what if there's a bug in your code

33:38.900 --> 33:43.620
and you can never pull out your money again?

33:43.620 --> 33:50.300
This is an abbreviated version of the real DAO smart contract where you would be able

33:50.300 --> 33:52.340
to withdraw money.

33:52.340 --> 33:56.700
So when you had put in your money and it had grown and you decided it's time to pull this

33:56.700 --> 34:03.140
money out so I can use it again, you would call this function and you would say...

34:03.140 --> 34:04.700
Here's my ID.

34:04.700 --> 34:08.420
This is how much money I want to withdraw.

34:08.420 --> 34:11.220
And simplified, it would boil down...

34:11.220 --> 34:13.940
The function boils down to roughly this.

34:13.940 --> 34:15.260
Step one.

34:15.260 --> 34:21.260
Calculate how many funds, how much of the money that you have in the DAO do you want

34:21.260 --> 34:22.260
to remove?

34:22.260 --> 34:25.260
Do you want to remove 5 ETH?

34:25.260 --> 34:27.300
Do you want to remove 10 ETH?

34:27.300 --> 34:28.500
0.1 ETH?

34:28.500 --> 34:32.700
So calculate how much money you want to move.

34:32.700 --> 34:34.340
Step two.

34:34.340 --> 34:36.420
Prepare to move that money.

34:36.420 --> 34:40.700
And check to see if there's an error when you remove that money.

34:40.700 --> 34:46.060
So if they're trying to move more money than they have, for example, check.

34:46.060 --> 34:48.940
If they are, don't do it.

34:48.940 --> 34:54.460
Don't let somebody withdraw 10 ETH when they only have 5 ETH in their bank.

34:54.460 --> 35:01.140
So that's what this if error or if no error, then withdraw the actual money.

35:01.140 --> 35:02.300
They're asking for their money.

35:02.300 --> 35:03.620
Give them the money.

35:03.660 --> 35:06.540
Finally, zero the user's balance.

35:10.300 --> 35:10.800
All right.

35:10.800 --> 35:11.800
What goes wrong?

35:22.660 --> 35:23.660
Yeah?

35:23.660 --> 35:29.780
What if they're not withdrawing all their money?

35:29.780 --> 35:30.780
Yep.

35:30.780 --> 35:31.780
What do you mean?

35:31.780 --> 35:35.260
At the bottom, that would be zero, right?

35:35.260 --> 35:36.100
Oh, sure.

35:36.100 --> 35:38.020
Yeah.

35:38.020 --> 35:41.260
That's me simplifying code.

35:41.260 --> 35:44.100
We set it to be whatever is remaining.

35:44.100 --> 35:47.100
Or we could pretend this is full withdrawal.

35:47.100 --> 35:47.600
Yeah.

35:47.600 --> 35:48.100
Either way.

35:58.020 --> 35:58.520
Yeah.

35:58.600 --> 36:02.480
This createToken.value is basically our check to say,

36:02.480 --> 36:06.440
will this thing, when we withdraw this amount of money,

36:06.440 --> 36:09.080
will it cause an error?

36:09.080 --> 36:12.480
What it's really doing is it's preparing a separate coin

36:12.480 --> 36:16.080
for that user under the hood and all of this

36:16.080 --> 36:18.440
that we will transfer to that user.

36:18.440 --> 36:20.680
So there's a bit more complexity hidden behind there.

36:20.680 --> 36:24.020
But we can think of it as an error check.

36:24.020 --> 36:27.600
We're checking to validate, is this thing OK to do?

36:28.520 --> 36:29.020
Yeah?

36:33.980 --> 36:34.480
Yeah?

36:34.480 --> 36:38.440
What's a HashMap?

36:38.440 --> 36:39.320
It's a dictionary.

36:39.320 --> 36:40.940
HashMap, whatever you want to call it.

36:44.120 --> 36:47.480
Consider that we're on a distributed cloud.

36:47.480 --> 36:51.760
It's one of the actual main purposes of smart contracts.

36:51.760 --> 36:53.080
Yeah?

36:53.080 --> 36:56.320
Does that do something with atomic operations

36:56.320 --> 36:57.760
in parallel?

36:57.760 --> 36:58.280
Sure.

36:59.040 --> 37:02.800
So what does that mean?

37:02.800 --> 37:04.400
What part of this is not atomic?

37:04.400 --> 37:07.100
What part of it would you want to be atomic?

37:07.100 --> 37:07.600
Yeah?

37:28.480 --> 37:30.120
Or something?

37:30.120 --> 37:35.480
That is exactly what these guys exploited.

37:35.480 --> 37:39.040
If we have multiple of these processes running

37:39.040 --> 37:44.160
at the same time, and they check that they're

37:44.160 --> 37:48.160
valid all at the same time, before we

37:48.160 --> 37:52.240
have set our actual value to zero,

37:52.240 --> 37:56.480
then they will all say, you have 5 ETH in your bank.

37:56.480 --> 38:01.080
Then when we withdraw 5 ETH from five different processes

38:01.080 --> 38:04.440
running the same thing, you get 25 ETH.

38:04.440 --> 38:07.920
While at the end, you're only ever set down to zero.

38:07.920 --> 38:13.040
You can't have negative 20 ETH in your account.

38:13.040 --> 38:19.740
So because these are not atomic in this check withdraw set,

38:19.740 --> 38:22.640
we're running into this concurrency problem

38:22.640 --> 38:25.880
where the attackers were able to literally withdraw

38:25.880 --> 38:27.040
$150 million.

38:32.040 --> 38:33.600
So what's going wrong?

38:33.600 --> 38:36.920
Once again, we have this implied invariant

38:36.920 --> 38:40.880
that at all times, the balance for a user

38:40.880 --> 38:46.140
matches the actual money that they are owed.

38:46.140 --> 38:50.760
And we're trying to approximate that by saying, if no error,

38:50.760 --> 38:53.200
throw, and then withdraw.

38:53.200 --> 38:57.480
But because that's not atomic, we don't actually

38:57.480 --> 39:01.160
have that invariant for the two lines of code

39:01.160 --> 39:02.120
that it really matters.

39:06.200 --> 39:09.360
So just like in the MyList example,

39:09.360 --> 39:13.900
we are temporarily invalidating our invariant

39:13.900 --> 39:15.960
while our function is running.

39:15.960 --> 39:19.520
Once we've finished running, our invariant's back and restored,

39:19.520 --> 39:22.760
and we're fine, unless somebody was able to exploit it

39:22.760 --> 39:23.720
in the meantime.

39:32.480 --> 39:38.280
So atomic to the rescue?

39:43.280 --> 39:46.620
Can we just wrap all of our code in mutexes

39:46.620 --> 39:53.100
and basically check, lock this piece, unlock this piece?

39:53.100 --> 39:54.820
The idea here would be to take learnings

39:54.820 --> 39:56.700
from databases or operating systems

39:56.700 --> 39:59.660
where we do this all the time.

39:59.660 --> 40:03.740
And maybe atomic actions will fix this.

40:03.740 --> 40:06.460
But not quite.

40:06.460 --> 40:11.460
So Uber published a lengthy blog post

40:11.460 --> 40:13.420
roughly talking about all of this.

40:13.420 --> 40:15.460
Uber does a ton of their development

40:15.460 --> 40:20.280
in the language Golang, which is very similar to C,

40:20.280 --> 40:24.900
but has a lot better guarantees, generally.

40:24.900 --> 40:27.780
And what we're doing here is we want to take,

40:27.780 --> 40:30.460
we can think of it very similar.

40:30.460 --> 40:32.180
The square brackets are lists.

40:32.180 --> 40:34.980
Effectively, they're called slices in Go.

40:34.980 --> 40:35.580
No big deal.

40:35.580 --> 40:37.220
They're basically just lists.

40:37.220 --> 40:39.160
So we have a list of strings.

40:39.160 --> 40:41.900
And then we have a safe append function.

40:41.900 --> 40:46.100
And that function is going to lock our,

40:46.100 --> 40:51.860
set our locks so that we can update the my results slice,

40:51.860 --> 40:54.540
which is technically, or it's technically a slice,

40:54.540 --> 40:55.980
but it looks like a list.

40:55.980 --> 41:02.700
So we're only going to write to our list with the lock.

41:02.700 --> 41:05.660
And then we can set up multiple threads.

41:05.660 --> 41:07.540
One of the amazing things about Go

41:07.540 --> 41:10.800
is that you can just say Go function,

41:10.800 --> 41:12.560
and then it will spin up a thread

41:12.560 --> 41:16.280
to run that function for you asynchronously.

41:16.280 --> 41:22.320
So we can set 10 threads going all at once to take our string

41:22.320 --> 41:29.680
and split it up and append it to our list of strings.

41:29.680 --> 41:32.840
But what's going to go wrong is that even though we only

41:32.840 --> 41:36.640
can write one at a time to safe atomic,

41:36.640 --> 41:40.120
we can read concurrently.

41:40.120 --> 41:44.040
And so we might be halfway through a write

41:44.040 --> 41:46.000
and then start reading.

41:46.000 --> 41:48.800
And because we've only written half of the content,

41:48.800 --> 41:51.800
we might not have copied the correct length,

41:51.800 --> 41:55.040
or we might not have grabbed the entire list.

41:55.040 --> 41:58.120
Any number of things could go wrong.

41:58.120 --> 42:01.920
So when we do the read right here,

42:01.920 --> 42:07.840
and we request my results, this is undetermined.

42:07.840 --> 42:12.160
It could be any value within reason.

42:15.480 --> 42:18.360
So maybe what we could do is we could wrap literally everything

42:18.360 --> 42:22.000
in mutexes, but now we're in single-threaded land,

42:22.000 --> 42:25.760
and that kind of sucks for its own reasons.

42:25.760 --> 42:27.560
Nobody wants to write single-threaded code.

42:27.560 --> 42:32.120
It's super slow, especially with the death of Moore's law.

42:32.120 --> 42:37.200
So the shared issue here, we have

42:37.200 --> 42:43.600
this idea of invariance being violated repeatedly

42:43.600 --> 42:47.480
to multiple aliased references.

42:47.480 --> 42:50.960
Aliasing means we have multiple references to the same memory.

42:50.960 --> 42:53.960
Here, we have multiple references of my results

42:53.960 --> 42:55.520
up here and in the append.

42:55.520 --> 43:02.440
In this place, we have multiple references

43:02.440 --> 43:09.520
to the actual balances feature that stores our information.

43:09.520 --> 43:14.560
And the last one, we have multiple references

43:14.560 --> 43:20.040
to our length, or to our array, which has the length variable.

43:20.040 --> 43:24.800
So we have aliases of the same important memory.

43:24.800 --> 43:25.800
Question?

43:25.800 --> 43:27.800
Yeah, this might not be relevant,

43:27.800 --> 43:32.780
but regarding the mutex and any distributed system,

43:32.780 --> 43:35.280
how does a mutex work with something

43:35.280 --> 43:39.720
that's like a blockchain distributed system?

43:39.720 --> 43:41.280
Oh, it certainly wouldn't.

43:41.280 --> 43:43.760
So you can't do, like, mutexes as far as possible

43:43.760 --> 43:44.960
to contribute it?

43:44.960 --> 43:52.920
So mutex needs to operate at the underlying level for it to work.

43:52.920 --> 43:57.240
You need to have some sort of supervisor saying,

43:57.240 --> 44:00.160
lock this thing, and then unlock this thing.

44:00.160 --> 44:03.000
And if you don't have something like that, it's not going to work.

44:03.000 --> 44:05.880
If you could build that into your chain,

44:05.880 --> 44:07.920
you could make something like it work.

44:07.920 --> 44:10.480
But by default in ETH, you'd probably

44:10.480 --> 44:11.840
have some trouble with that.

44:19.720 --> 44:21.840
All right, lots of things.

44:21.840 --> 44:28.880
All right, so our invariants have been violated by multiple.

44:28.880 --> 44:30.640
Did I say inviolated?

44:30.640 --> 44:35.440
Invariants are violated by multiple aliased references.

44:35.440 --> 44:39.480
An alias is when we have multiple references to the same memory.

44:45.000 --> 44:47.560
Let's try and fix that.

44:47.560 --> 44:50.840
So to the original title of the blog post,

44:50.840 --> 44:56.160
solving the next or fixing the next 10,000 aliasing bugs,

44:56.160 --> 44:57.040
or whatever it was.

44:59.680 --> 45:02.560
The author makes the point that this is not new.

45:02.560 --> 45:05.880
Tony Hoare gave a presentation about 10 years ago

45:05.880 --> 45:09.080
called Null References, the Billion Dollar Mistake,

45:09.080 --> 45:11.720
where he talks about, in ALGOL, the language

45:11.720 --> 45:13.880
that he developed in the 60s, he included

45:13.880 --> 45:16.420
the idea of a null reference.

45:16.420 --> 45:18.680
And every other language since then

45:18.680 --> 45:21.400
has said, null is a good idea.

45:21.400 --> 45:23.680
Let's also have null.

45:23.680 --> 45:28.040
But how many bugs come up because of null?

45:28.040 --> 45:30.360
Maybe a billion dollars worth of bugs.

45:30.360 --> 45:31.000
Maybe more.

45:31.000 --> 45:33.960
Maybe it's even crazier.

45:33.960 --> 45:36.600
So over the last 20 years, people

45:36.600 --> 45:40.560
have started saying, how can we fix null pointers?

45:40.560 --> 45:45.920
The issue fundamentally is that every variable can be null.

45:45.920 --> 45:48.280
Developers then have what options?

45:48.280 --> 45:51.480
What can a developer do to handle null?

45:51.480 --> 45:53.440
You're writing C code.

45:53.440 --> 45:56.360
What do you do when you're worried

45:56.360 --> 45:57.760
about this sort of stuff?

45:57.760 --> 46:00.400
Yeah.

46:00.400 --> 46:01.860
Put if statements everywhere.

46:01.860 --> 46:03.200
That is the first one.

46:03.200 --> 46:03.840
Excellent.

46:03.840 --> 46:05.000
Good order.

46:05.000 --> 46:09.600
We can always do a null check and say, if the thing is null,

46:09.600 --> 46:10.120
do this.

46:10.120 --> 46:12.600
Otherwise, do whatever else.

46:12.600 --> 46:15.360
What else can we do?

46:15.360 --> 46:17.440
Yeah.

46:17.440 --> 46:21.000
We can use union types in C.

46:21.000 --> 46:22.960
OK, I haven't used union types in C.

46:22.960 --> 46:26.040
In other languages, definitely.

46:26.040 --> 46:28.160
And that's what I will talk about on the next slide.

46:31.080 --> 46:31.880
What else can we do?

46:31.880 --> 46:32.380
Yeah.

46:32.380 --> 46:34.440
Exception handling.

46:34.440 --> 46:37.680
C doesn't have exceptions.

46:37.680 --> 46:39.200
Right?

46:39.200 --> 46:39.700
Am I wrong?

46:39.700 --> 46:40.960
New versions of C might.

46:40.960 --> 46:42.880
I don't think C has exceptions.

46:42.880 --> 46:45.680
But in other languages, we have exception handling.

46:45.680 --> 46:47.360
We can capture null pointers.

46:47.360 --> 46:47.860
Sure.

46:53.160 --> 46:59.760
We can also just be very careful and try not to mess up.

46:59.760 --> 47:03.080
And I would say the last option is segfile.

47:07.440 --> 47:11.340
But these are antiquated ideas.

47:11.340 --> 47:13.840
You should not have to do any one of these.

47:13.840 --> 47:15.600
You shouldn't have to do null checks.

47:15.600 --> 47:17.320
You shouldn't have to be very careful.

47:17.320 --> 47:19.480
And you shouldn't be segfaulting.

47:19.480 --> 47:21.280
And instead, what we should do is

47:21.280 --> 47:23.360
we should fix it at the language level

47:23.360 --> 47:27.640
with things like union types, which I guess are in C,

47:27.640 --> 47:30.000
but are only more recently in C for sure.

47:33.040 --> 47:34.160
Either way.

47:34.160 --> 47:36.880
But a ton of other languages have this idea

47:36.880 --> 47:42.040
that things, you can tag them as either being never null

47:42.040 --> 47:45.200
or possibly null.

47:45.200 --> 47:46.880
So you have something like TypeScript,

47:46.880 --> 47:48.640
where you put this little question mark

47:48.640 --> 47:50.360
after your variable name.

47:50.360 --> 47:53.400
And what you're saying there is, this thing is a number, maybe.

47:53.400 --> 47:55.040
It also might be null.

47:55.040 --> 47:58.720
And whenever you use it, you should check to see is it null.

47:58.720 --> 48:00.640
But if it doesn't have a question mark,

48:00.640 --> 48:05.680
the name property is never null.

48:05.680 --> 48:07.680
And you never have to worry that that thing

48:07.680 --> 48:11.180
might be uninitialized.

48:11.180 --> 48:12.760
So a bunch of languages are doing this.

48:12.760 --> 48:13.560
TypeScript does it.

48:13.560 --> 48:16.000
You can do front-end or back-end dev with that.

48:16.000 --> 48:16.920
Rust does it.

48:16.920 --> 48:18.440
You can do systems dev with that.

48:18.440 --> 48:19.160
Swift does it.

48:19.160 --> 48:21.120
You can write iOS apps with that.

48:21.120 --> 48:22.240
Kotlin does it.

48:22.240 --> 48:23.760
I don't know if anybody uses Kotlin.

48:26.360 --> 48:28.280
So that's null pointers that have been

48:28.280 --> 48:30.200
addressed at the compiler level.

48:30.200 --> 48:33.100
These languages now solve this problem for you.

48:33.100 --> 48:37.140
When you accidentally use a possibly null value

48:37.140 --> 48:40.080
and don't check if it's null, the compiler

48:40.080 --> 48:42.160
will tell you that's an error.

48:42.160 --> 48:42.680
Don't do that.

48:46.160 --> 48:48.160
Can we treat aliasing the same way?

48:48.160 --> 48:48.660
Oh, yeah.

48:48.660 --> 48:49.160
Yeah.

48:49.160 --> 48:56.040
So in SQL, I think they have something like some.

48:56.040 --> 48:59.080
Oh, SQL's a nightmare with null.

48:59.080 --> 49:01.480
Yeah, but no, it's interesting.

49:01.480 --> 49:08.240
SQL has null, but it also has empty and other very weird

49:08.240 --> 49:10.400
states that it can be in.

49:10.400 --> 49:12.360
But it also depends on the variant in SQL.

49:12.360 --> 49:16.840
So SQL has some null handling, but then it also

49:16.840 --> 49:21.120
has some not null handling that gets into issues.

49:25.800 --> 49:29.240
Other questions or ideas about null pointers?

49:36.000 --> 49:36.500
Yeah.

49:41.400 --> 49:44.880
Why are null pointers bad?

49:44.880 --> 49:49.360
Why are null pointers good and bad?

49:49.360 --> 49:52.840
Sometimes, they're useful, but not always.

49:52.840 --> 49:54.320
They have some use, right?

49:54.320 --> 49:55.800
Sometimes, they're not.

49:55.800 --> 49:58.280
Sometimes, they're not always.

49:58.280 --> 50:00.240
Sometimes, they're not always.

50:00.240 --> 50:00.920
Yeah.

50:00.920 --> 50:03.680
So why are null pointers bad?

50:03.680 --> 50:07.480
And I think that's, to some extent,

50:07.480 --> 50:10.600
a philosophical question.

50:10.600 --> 50:13.000
Should you ever use a null pointer?

50:13.000 --> 50:20.040
But it's also very much just an engineering problem.

50:20.040 --> 50:25.640
When you are trying to learn C, you run into a lot of segfaults.

50:25.640 --> 50:27.720
When you are trying to learn JavaScript,

50:27.720 --> 50:31.480
you run into a lot of undefined is not a function.

50:31.480 --> 50:35.440
You guys have probably hit that one a lot in this class.

50:35.440 --> 50:39.200
When you try and learn a language like Python, though,

50:39.200 --> 50:43.920
I guess you also still get none can't be used like that.

50:43.920 --> 50:48.440
But you can't ever call a non-function.

50:48.440 --> 50:51.800
You can't ever reference something and use something

50:51.800 --> 50:54.280
if it's a null pointer.

50:54.280 --> 50:57.760
You're not getting segfaults.

50:57.760 --> 51:00.760
Or if you're in TypeScript, even better,

51:00.760 --> 51:04.320
you're being forced to handle null.

51:04.320 --> 51:06.640
So it's not that you don't have null.

51:06.640 --> 51:10.000
It's that you only have to think about it on the things

51:10.000 --> 51:11.400
where it's relevant.

51:11.400 --> 51:13.960
I can still initialize my thing to be empty.

51:13.960 --> 51:16.120
But in doing so, I have to specify

51:16.120 --> 51:19.880
that it can be empty, which means everybody else knows

51:19.880 --> 51:21.560
that's potentially empty.

51:21.560 --> 51:23.880
But not everything is empty.

51:23.880 --> 51:26.080
Name is always going to be a string.

51:26.080 --> 51:27.840
And I never have to put an if statement

51:27.840 --> 51:30.960
to check, is name undefined?

51:35.320 --> 51:41.800
Which leads to cleaner code, and it leads to fewer mistakes.

51:41.800 --> 51:43.800
Fewer bugs.

51:48.240 --> 51:50.200
Cool.

51:50.200 --> 51:52.080
So what can we do about aliasing?

51:52.080 --> 51:57.000
Because we found this issue that aliasing presents bugs

51:57.000 --> 51:58.400
in our code as well.

51:58.400 --> 51:59.800
It's not just null pointers.

51:59.800 --> 52:02.480
It's aliasing, too.

52:03.320 --> 52:06.440
Well, inherently, in most languages,

52:06.440 --> 52:09.960
every reference is implicitly aliasable.

52:09.960 --> 52:18.280
We can always say x equals y and create an alias of y with x

52:18.280 --> 52:22.280
so that x and y both point to the same thing.

52:22.280 --> 52:27.280
No language outside of the one that we're about to discuss

52:27.280 --> 52:29.280
prevents you from being able to do that.

52:32.600 --> 52:35.760
What this means is that what developers

52:35.760 --> 52:39.120
can do to prevent aliasing is what?

52:39.120 --> 52:42.840
How can we stop aliasing bugs, such as the ones

52:42.840 --> 52:43.680
that we've just seen?

52:44.680 --> 52:45.160
Yeah?

52:57.080 --> 52:59.560
If we only have an immutable copy of something,

52:59.560 --> 53:04.640
wouldn't that, like, start to do, like, a bad thing?

53:04.640 --> 53:08.280
If we only have an immutable copy,

53:08.280 --> 53:11.560
what would stop me from saying x equals y?

53:12.240 --> 53:16.520
It's best practice to say x equals set y.

53:16.520 --> 53:22.880
Yeah, so I think that definitely gets to the right idea.

53:22.880 --> 53:24.400
Have you written Rust?

53:24.400 --> 53:25.840
Yeah, OK.

53:25.840 --> 53:32.000
So in JavaScript, we started using the immutable list

53:32.000 --> 53:35.560
library, where we couldn't update any of the variables.

53:35.560 --> 53:38.680
But that didn't actually stop us from having two references

53:38.680 --> 53:40.000
to those immutable lists.

53:40.000 --> 53:42.680
So there's nothing inherent in immutability

53:42.680 --> 53:46.480
that says we can't have multiple references, which

53:46.480 --> 53:50.280
is why there's nothing here.

53:50.280 --> 53:54.040
There's not really any way for the developer

53:54.040 --> 53:58.080
to prevent aliasing of memory that they think

53:58.080 --> 54:00.880
that they exclusively own.

54:00.880 --> 54:05.200
Because maybe somebody else is also copying it.

54:05.200 --> 54:08.920
But what if we were able to create a fixed language where

54:08.920 --> 54:13.480
we can flag references as being exclusive,

54:13.480 --> 54:16.480
meaning they have no aliasing allowed,

54:16.480 --> 54:19.160
or they could be shared, which means

54:19.160 --> 54:22.320
they can be aliased as normal.

54:22.320 --> 54:24.480
So shared memory, shared references

54:24.480 --> 54:28.960
would be just like every other variable you've ever used.

54:28.960 --> 54:32.480
Exclusive references, you would not

54:32.480 --> 54:36.400
be able to have two pointers to that same memory.

54:36.400 --> 54:40.960
So for example, we might say foo is an exclusive XCL,

54:40.960 --> 54:43.800
exclusive new foo.

54:43.800 --> 54:46.040
And then if we tried to say bar is

54:46.040 --> 54:50.280
equal to foo, which would create two references to that memory,

54:50.280 --> 54:52.280
we would get a compile error.

54:52.280 --> 54:54.800
Well, I guess we'd get a compile error here

54:54.800 --> 54:56.560
when we tried to use foo.

54:56.560 --> 54:59.080
Because foo is no longer a reference to our thing,

54:59.080 --> 55:01.120
we've transferred the reference.

55:02.120 --> 55:07.960
So what we're doing is we're adding a new alias type

55:07.960 --> 55:10.480
modifier to all of our variables.

55:10.480 --> 55:16.560
Our variables are now either shared or they're exclusive.

55:16.560 --> 55:20.080
And we can use the compiler to perform type inference

55:20.080 --> 55:25.920
on our code and say, are we misusing exclusive pointers

55:25.920 --> 55:29.740
or misusing shared pointers in any of our places?

55:29.740 --> 55:32.660
We will run type inference and type checking

55:32.660 --> 55:34.500
to find those sorts of bugs.

55:37.980 --> 55:43.180
So if we wrote a slightly larger function, increment,

55:43.180 --> 55:47.860
it could take a parameter x, which is exclusive.

55:47.860 --> 55:52.440
So x is an exclusive non-zero number.

55:52.440 --> 55:54.660
Then we could convert it to an int.

55:54.660 --> 55:56.220
We could increment it.

55:56.220 --> 55:57.660
We can do whatever we want.

55:57.660 --> 56:03.620
Anything inside of our increment function,

56:03.620 --> 56:06.420
we have exclusive control over x.

56:06.420 --> 56:10.900
Nobody else is going to be updating x.

56:10.900 --> 56:14.180
And the compiler will tell us that based on the types

56:14.180 --> 56:18.180
that we've annotated the rest of our code with.

56:18.180 --> 56:23.100
So the xcl flag guarantees that no one else

56:23.100 --> 56:24.500
is accessing the variable.

56:24.500 --> 56:28.400
And we can safely invalidate our invariants.

56:28.400 --> 56:32.900
If we had something like this in Solidity or in Java

56:32.900 --> 56:36.200
or, what was the other one, in Go,

56:36.200 --> 56:40.540
we could prevent the errors that we were seeing before.

56:40.540 --> 56:45.460
And the reveal of all of this is that this

56:45.460 --> 56:48.300
isn't some crazy new concept.

56:48.300 --> 56:53.500
This is what Rust does with its borrow checker.

56:53.500 --> 56:55.760
Rust checks to make sure that you're

56:55.760 --> 56:58.540
treating your exclusive variables as exclusive

56:58.540 --> 57:01.700
and your shared variables as shared.

57:01.700 --> 57:04.620
And so it has the borrow checker,

57:04.620 --> 57:06.420
not just for memory management.

57:06.420 --> 57:08.260
It also does aliasing.

57:11.140 --> 57:13.140
All right.

57:13.140 --> 57:16.020
Questions on any of those last slides?

57:16.020 --> 57:18.780
Borrow checker, Rust, things of this nature, exclusive?

57:18.940 --> 57:23.660
Even with that fix in Rust, to go back to the dowel example,

57:23.660 --> 57:28.380
that doesn't fix that issue, does it?

57:28.380 --> 57:31.980
In the exact solution, does it?

57:31.980 --> 57:36.100
Because that's a problem with parallel operations

57:36.100 --> 57:39.780
on not one central piece.

57:39.780 --> 57:40.260
Right.

57:40.260 --> 57:42.660
So you would need your underlying system

57:42.660 --> 57:46.980
to be written in Rust and to have these sorts of things

57:47.020 --> 57:50.500
be part of your exclusive memory.

57:50.500 --> 57:53.340
So nobody else should be able to access balance

57:53.340 --> 57:56.020
while I am accessing balance.

57:56.020 --> 57:59.260
Inside of this function, where I'm running this,

57:59.260 --> 58:02.500
no one else should be able to run that function while I

58:02.500 --> 58:03.980
am running this function.

58:03.980 --> 58:07.580
And my smart contract, if it were written in Rust,

58:07.580 --> 58:10.980
should prevent other people running the same smart

58:10.980 --> 58:12.620
contract.

58:12.620 --> 58:14.300
Because we're all trying to update.

58:14.300 --> 58:16.500
The issue is that we're updating balances.

58:16.500 --> 58:18.980
We're checking balances and updating balances.

58:18.980 --> 58:23.220
If we make that exclusive, we should be fine.

58:23.220 --> 58:27.660
You can make that exclusive across distributed

58:27.660 --> 58:28.620
and correct?

58:28.620 --> 58:29.120
Right.

58:29.120 --> 58:32.380
How does that component come into play?

58:32.380 --> 58:39.900
So there's, I'm blanking on the term, for consistency.

58:39.900 --> 58:41.940
That is a problem for consistency

58:41.940 --> 58:44.900
of distributed systems.

58:44.900 --> 58:47.940
I mean, the heart of all of crypto stuff

58:47.940 --> 58:52.540
is built on consensus algorithms, such as like Paxos

58:52.540 --> 58:58.860
or what's the cool one?

58:58.860 --> 58:59.940
Blanking on that as well.

58:59.940 --> 59:02.460
It's been too long since I've done distributed.

59:02.460 --> 59:05.180
But there are protocols that allow

59:05.180 --> 59:09.500
you to achieve consistency for your data store, which

59:09.500 --> 59:10.700
is the blockchain.

59:10.700 --> 59:13.200
So the blockchain is always consistent.

59:13.200 --> 59:16.240
So you just need a language on top of it where you can say,

59:16.240 --> 59:18.920
no one should be updating this part of the blockchain

59:18.920 --> 59:20.720
at the same time as me.

59:20.720 --> 59:21.220
Yeah?

59:21.220 --> 59:24.720
So what's the difference between a mutex on balances

59:24.720 --> 59:27.680
versus a reference on mutex on balances?

59:33.360 --> 59:37.080
So the difference between a mutex on balances

59:37.080 --> 59:40.720
here is addressing this at the application level,

59:40.720 --> 59:46.440
where I'm saying, no one can be running inside of my scope

59:46.440 --> 59:48.080
this same stuff.

59:48.080 --> 59:51.920
You would want a mutex for the entire protocol,

59:51.920 --> 59:55.480
for the entire blockchain, to do that.

59:55.480 --> 59:58.900
And that would be probably prohibitively slow

59:58.900 --> 59:59.840
on the chain.

59:59.840 --> 01:00:01.720
Because you'd say, no one else can, like,

01:00:01.720 --> 01:00:06.240
operate on the chain while I am operating on the chain.

01:00:06.240 --> 01:00:07.080
Does that make sense?

01:00:07.080 --> 01:00:07.580
Yeah.

01:00:07.580 --> 01:00:10.440
What is the reference on the reference here?

01:00:10.440 --> 01:00:13.340
I'm not quite sure how you would bring in the exclusive reference

01:00:13.340 --> 01:00:13.840
here.

01:00:13.840 --> 01:00:17.380
But it would have to be at a more fundamental layer

01:00:17.380 --> 01:00:18.320
than this piece.

01:00:18.320 --> 01:00:18.820
Yeah.

01:00:18.820 --> 01:00:20.280
I don't know what the reference is.

01:00:20.280 --> 01:00:22.140
I don't know what the reference is in that.

01:00:22.140 --> 01:00:24.800
But I think it's similar to the reference

01:00:24.800 --> 01:00:27.500
that was used for graphing the data.

01:00:27.500 --> 01:00:28.000
No.

01:00:28.000 --> 01:00:34.420
So this is part of the language.

01:00:34.420 --> 01:00:36.840
This is a new feature for the language

01:00:36.880 --> 01:00:39.240
that the compiler is going to be enforcing.

01:00:39.240 --> 01:00:42.960
There's no actual runtime implication of exclusive.

01:00:42.960 --> 01:00:44.880
Oh, OK.

01:00:44.880 --> 01:00:47.840
This is a piece that's saying, I'm going to check your code

01:00:47.840 --> 01:00:50.800
and make sure no one else can operate on this thing

01:00:50.800 --> 01:00:54.240
while you are operating on this thing.

01:00:54.240 --> 01:01:00.400
Here, with mutexes, we have very much runtime implication,

01:01:00.400 --> 01:01:02.520
and checks, and stuff of that sort.

01:01:02.520 --> 01:01:05.280
So you still want to have mutexes in a world

01:01:05.280 --> 01:01:08.880
where you'd have exclusive references.

01:01:08.880 --> 01:01:10.560
I could see that still playing a part.

01:01:19.800 --> 01:01:21.040
Other questions?

01:01:28.000 --> 01:01:28.500
Yeah.

01:01:28.500 --> 01:01:30.120
If you're not writing in Rust, you're

01:01:30.120 --> 01:01:32.680
risking that problem?

01:01:32.680 --> 01:01:34.400
Even if you're writing in Rust, sometimes

01:01:34.400 --> 01:01:36.840
you're risking that problem.

01:01:36.840 --> 01:01:37.340
But yeah.

01:01:37.340 --> 01:01:37.840
No.

01:01:37.840 --> 01:01:40.440
I mean, actually, while we're on this slide,

01:01:40.440 --> 01:01:43.840
this is a reasonable piece of Go code,

01:01:43.840 --> 01:01:47.480
where the whole point of me writing code in Go

01:01:47.480 --> 01:01:52.680
is because I want to distribute all of my tasks concurrently

01:01:52.680 --> 01:01:55.720
and just say, everyone go do this thing,

01:01:55.720 --> 01:01:57.880
and come back and tell me once it's done.

01:01:57.880 --> 01:02:00.520
So the idea of writing a for loop,

01:02:00.520 --> 01:02:03.560
where I'm running a bunch of threads

01:02:03.560 --> 01:02:07.920
in parallel across some shared memory,

01:02:07.920 --> 01:02:11.240
that probably happens all the time.

01:02:11.240 --> 01:02:14.440
And you would run into, potentially, this problem,

01:02:14.440 --> 01:02:18.480
even if you're trying to solve it with mutexes.

01:02:18.480 --> 01:02:19.980
Yeah.

01:02:19.980 --> 01:02:21.940
Do you get the couple when you do the product?

01:02:21.940 --> 01:02:24.000
Like, are you doing the product?

01:02:24.000 --> 01:02:26.080
But then, do you get any parallelism?

01:02:26.960 --> 01:02:31.920
Like, you don't get any benefit of all of the cores

01:02:31.920 --> 01:02:36.160
on your CPU, if you put read-write locks everywhere

01:02:36.160 --> 01:02:38.160
on here.

01:02:38.160 --> 01:02:39.880
But yeah, you can.

01:02:39.880 --> 01:02:41.360
It's just then you kind of lose out.

01:02:46.000 --> 01:02:46.500
Yeah.

01:02:46.660 --> 01:02:50.140
So what's it exactly like that I'm going to use the mute?

01:02:50.140 --> 01:02:52.580
Like, if you were in Rust, is that

01:02:52.580 --> 01:02:54.500
the type-checking you're doing when you're doing

01:02:54.500 --> 01:02:57.140
do-able registers and non-do-able registers?

01:02:57.140 --> 01:03:01.460
Or is there something else that you're not doing?

01:03:01.460 --> 01:03:10.940
So in Rust, if we say, let x equal mem,

01:03:10.940 --> 01:03:13.940
we allocate some space on the heap.

01:03:13.940 --> 01:03:15.780
We say x is equal to that mem.

01:03:15.820 --> 01:03:19.140
And then we say y equal x, or let y equal x.

01:03:22.740 --> 01:03:25.900
Then we try to access y.

01:03:25.900 --> 01:03:26.860
We're good to go.

01:03:26.860 --> 01:03:29.300
If we try to access x, all right,

01:03:29.300 --> 01:03:32.140
I've chosen a poor letter, we are not good to go.

01:03:32.140 --> 01:03:34.460
We run into an issue.

01:03:34.460 --> 01:03:37.140
And this is a compile issue that says, hey,

01:03:37.140 --> 01:03:40.260
you don't have access to x anymore.

01:03:40.260 --> 01:03:43.940
And that's just the default behavior.

01:03:43.940 --> 01:03:47.780
That's what the borrow checker will ensure for any memory

01:03:47.780 --> 01:03:50.460
that you create.

01:03:50.460 --> 01:03:53.180
Then you can create mutable references and stuff

01:03:53.180 --> 01:03:54.420
on top of that.

01:03:54.420 --> 01:03:58.140
But that's kind of a layer above.

01:04:00.860 --> 01:04:05.020
We will all start working on Rust quite soon.

01:04:05.020 --> 01:04:06.580
I think PA6.

01:04:06.580 --> 01:04:11.980
So it'll be in two weeks, or two weeks after spring break,

01:04:11.980 --> 01:04:13.700
where you'll write your first Rust code,

01:04:13.700 --> 01:04:14.620
if you haven't before.

01:04:17.700 --> 01:04:19.820
With some intro to it, so don't worry too much.

01:04:23.260 --> 01:04:24.540
Any other questions?

01:04:24.540 --> 01:04:25.540
Yeah?

01:04:25.540 --> 01:04:28.020
But this way, you're kind of pushing the problem

01:04:28.020 --> 01:04:29.980
to the compiler side.

01:04:29.980 --> 01:04:32.460
So you probably have a lot of errors

01:04:32.460 --> 01:04:34.940
showing up about concurrency issues,

01:04:34.940 --> 01:04:37.220
what you do to it in general.

01:04:37.220 --> 01:04:38.180
Definitely.

01:04:38.180 --> 01:04:41.180
This is now the compiler's job to tell you

01:04:41.180 --> 01:04:42.980
when you are right and wrong.

01:04:42.980 --> 01:04:45.140
And just like comparing JavaScript

01:04:45.140 --> 01:04:50.260
to a language like Java, with types,

01:04:50.260 --> 01:04:55.180
sometimes JavaScript works, even though the types are weird.

01:04:55.180 --> 01:04:59.100
And you're trying to call an integer

01:04:59.100 --> 01:05:00.300
as though it were a function.

01:05:00.300 --> 01:05:03.180
So long as you never use that piece of code,

01:05:03.180 --> 01:05:05.260
it's not going to crash.

01:05:05.260 --> 01:05:07.700
But Java would say, hey, that's a type error.

01:05:07.700 --> 01:05:10.180
You can't do that.

01:05:10.180 --> 01:05:13.460
Here, Rust is going to give you compile errors

01:05:13.460 --> 01:05:15.500
for all of the places where you're doing something

01:05:15.500 --> 01:05:17.780
potentially wrong, even if it wouldn't have caused

01:05:17.780 --> 01:05:19.620
a problem in the first place.

01:05:19.620 --> 01:05:22.020
So it's more restrictive.

01:05:22.020 --> 01:05:28.100
But as a result, it's always safe,

01:05:28.100 --> 01:05:31.100
unless you specifically say unsafe.

01:05:31.100 --> 01:05:32.540
Then it's not always safe.

01:05:32.540 --> 01:05:36.020
Yeah?

01:05:36.020 --> 01:05:39.020
So is it like, at compile time, I

01:05:39.020 --> 01:05:42.500
should be able to figure out how should I

01:05:42.500 --> 01:05:45.980
access the concurrency as a shared memory?

01:05:45.980 --> 01:05:50.980
Rather than dedicate that problem to the compile time,

01:05:50.980 --> 01:05:53.980
where if I don't, I don't need it.

01:05:53.980 --> 01:05:54.820
Exactly.

01:05:54.820 --> 01:05:58.100
So the big benefit here is that now we're

01:05:58.100 --> 01:06:00.420
able to do this stuff at compile time.

01:06:00.500 --> 01:06:04.100
And what we are doing is effectively type inference,

01:06:04.100 --> 01:06:06.740
where we're saying, track the type,

01:06:06.740 --> 01:06:11.220
the exclusive or shared type of this variable,

01:06:11.220 --> 01:06:13.100
and infer it as it goes along.

01:06:13.100 --> 01:06:17.180
Anytime we run into a conflict, raise an error.

01:06:17.180 --> 01:06:22.660
So wouldn't that reduce the parallelism even more?

01:06:22.660 --> 01:06:25.140
Because in the new text, it kind of

01:06:25.140 --> 01:06:27.620
allows being optimistic about it.

01:06:27.620 --> 01:06:30.100
And you just let all the threads run.

01:06:30.100 --> 01:06:32.100
And no matter who gets the, yeah,

01:06:32.100 --> 01:06:35.100
you can use runtime checks to do that.

01:06:35.100 --> 01:06:37.100
But at compile time, you're preemptively

01:06:37.100 --> 01:06:44.100
forcing the order of threads getting used to it.

01:06:44.100 --> 01:06:46.020
I think that's a fair argument.

01:06:46.020 --> 01:06:50.820
Is this not potentially slower?

01:06:50.820 --> 01:06:56.660
But counter-argument, right?

01:06:56.660 --> 01:07:00.340
So it is more restrictive in what you can write.

01:07:00.340 --> 01:07:02.660
What that means is either you have to write,

01:07:02.660 --> 01:07:05.460
what you end up is with something slower,

01:07:05.460 --> 01:07:08.300
or you have to write the code correct

01:07:08.300 --> 01:07:11.420
so that it's equally fast, or potentially faster,

01:07:11.420 --> 01:07:14.420
and you're never going to get cycles.

01:07:14.420 --> 01:07:15.340
Yeah.

01:07:15.340 --> 01:07:18.540
But it's maybe harder to write that mid-tier

01:07:18.540 --> 01:07:22.820
where it's fast sometimes, and it crashes sometimes.

01:07:22.820 --> 01:07:25.140
But that's probably a good thing.

01:07:25.140 --> 01:07:26.620
Yeah.

01:07:26.620 --> 01:07:29.580
I'm going back to the slow example.

01:07:29.580 --> 01:07:34.540
Was there a reason for that?

01:07:34.540 --> 01:07:36.500
Or is it all coming down to power?

01:07:36.500 --> 01:07:40.980
Is that the fact that it's high performance?

01:07:40.980 --> 01:07:41.940
Do I have to make it?

01:07:41.940 --> 01:07:45.740
I would have to think about it.

01:07:45.740 --> 01:07:49.060
We can think about it in Office Hours together, if you want.

01:07:49.060 --> 01:07:53.300
If you want to learn more about the piece

01:07:53.300 --> 01:08:00.660
that we were just talking about, considerations on code

01:08:00.660 --> 01:08:03.740
crafting, finding the next 10,000 aliasing bugs.

01:08:03.740 --> 01:08:06.420
I'll post it on Piazza as well, if you want to read it.

01:08:06.420 --> 01:08:11.780
They basically walk through a lot of the same ideas.

01:08:11.780 --> 01:08:15.700
I did not generate all of these ideas myself.

01:08:15.700 --> 01:08:18.820
Mostly I read about them this morning.

01:08:18.820 --> 01:08:21.860
So they go into more about the types,

01:08:21.860 --> 01:08:23.100
if you want to look at that.

01:08:23.900 --> 01:08:28.260
And the idea of permissions with exclusive types.

01:08:28.260 --> 01:08:29.940
Things of this nature.

01:08:29.940 --> 01:08:31.740
All right.

01:08:31.740 --> 01:08:34.620
From there, though, I think we will call it a day.

01:08:34.620 --> 01:08:36.860
Seven minutes early.

01:08:36.860 --> 01:08:39.340
Feel free to drop by Office Hours.

01:08:39.340 --> 01:08:41.700
If you want to write some Python code.

01:08:57.420 --> 01:08:58.820
Yeah, yeah, yeah.

01:08:58.820 --> 01:09:00.620
Let me.

01:17:09.340 --> 01:17:10.900
I'll do it.

01:17:10.900 --> 01:17:12.140
I'll do it.

01:17:12.140 --> 01:17:21.740
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,

01:17:21.740 --> 01:17:28.980
13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,

01:17:28.980 --> 01:17:35.820
26, 27, 28, 29, 30, 31, 32, 33, 34, 34, 35, 36, 37,

01:17:35.940 --> 01:17:45.420
38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,

01:17:45.420 --> 01:17:58.620
52, 53, 54, 55, 56, 57, 58, 59, 60.

01:17:58.620 --> 01:18:14.300
59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 78,

01:18:14.300 --> 01:18:24.060
79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 93, 94, 94, 93, 94,

