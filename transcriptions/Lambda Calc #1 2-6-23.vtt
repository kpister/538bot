WEBVTT

00:30.000 --> 00:42.680
All right, welcome to class.

00:42.680 --> 00:46.760
Let's get started.

00:46.760 --> 00:50.360
So some of you may have seen some cool news today.

00:50.360 --> 00:52.120
Let me hit the lights.

00:52.120 --> 01:00.760
Google, or the CEO of Google, just put this out.

01:00.760 --> 01:03.680
An important next step for our AI journey.

01:03.680 --> 01:10.640
Some of you have probably been following GPT-3 and 3.5, chat GPT, that sort of stuff.

01:10.640 --> 01:18.280
Google has an AI model similar to GPT-3 that's literally three times larger.

01:18.280 --> 01:19.280
And they've had it forever.

01:19.280 --> 01:21.680
They just haven't been letting anybody use it.

01:21.680 --> 01:28.720
They announced today what they're calling BARD, which is effectively chat GPT, but Google

01:28.720 --> 01:29.720
branded.

01:29.720 --> 01:30.920
It's their version.

01:30.920 --> 01:33.920
With potentially a model that's significantly more powerful.

01:33.920 --> 01:37.160
So some fun stuff in the news today.

01:37.160 --> 01:40.460
We don't get access to it for a little bit longer, but that's Google for you.

01:40.460 --> 01:48.360
So just thought I'd give you that update in case you haven't seen it.

01:48.360 --> 01:49.360
Today...

01:49.360 --> 01:50.360
Oh, yeah?

01:50.360 --> 01:52.920
What do companies do keeping it internal?

01:52.920 --> 01:55.040
What do companies do keeping it internal?

01:55.040 --> 01:56.040
What do you mean?

01:56.040 --> 01:57.040
So something like chat GPT.

01:57.040 --> 01:58.040
I know it's not making any money for Microsoft just yet.

01:58.040 --> 01:59.040
But it's, like, good marketing.

01:59.040 --> 02:00.040
Right?

02:00.040 --> 02:01.040
But unless Google is integrating this into one of their services, what is the point of

02:01.040 --> 02:14.040
keeping it on your laptop?

02:14.040 --> 02:15.040
Yeah.

02:15.040 --> 02:16.640
So what's the point of keeping...

02:16.640 --> 02:21.040
As a business, what's the point of keeping a service that you've created internal and

02:21.040 --> 02:24.520
not allowing kind of open access to it?

02:24.520 --> 02:26.720
I think the first thing is...

02:26.720 --> 02:29.060
Why allow open access to something?

02:29.060 --> 02:30.760
The pro is...

02:30.760 --> 02:31.920
You might make money.

02:31.920 --> 02:33.840
You can potentially sell the service.

02:33.840 --> 02:34.880
That's great.

02:34.880 --> 02:38.080
The con is that people are gonna be messing around with your service.

02:38.080 --> 02:41.040
And maybe they're gonna be able to do things that you aren't expecting them to do.

02:41.040 --> 02:44.920
You might get really bad PR, especially.

02:44.920 --> 02:48.440
Google is very conscious of their PR.

02:48.440 --> 02:53.560
When it comes to AI, they don't want to be too scary.

02:53.560 --> 02:59.120
So keeping things internal keeps their PR presence contained.

02:59.120 --> 03:07.160
It means that when chat GPT says something racist or very out there and problematic,

03:07.160 --> 03:08.520
that's on open AI.

03:08.520 --> 03:11.000
Open AI has released that model.

03:11.000 --> 03:12.240
Anybody can use it.

03:12.240 --> 03:16.720
Google doesn't have that problem, because Google has not released their model.

03:16.720 --> 03:21.520
The benefits of keeping something internal, though, go beyond just having something internal.

03:21.520 --> 03:23.800
They can still use it.

03:23.800 --> 03:27.840
Open AI has built something that a lot of engineers are using now.

03:27.840 --> 03:32.840
So Copilot is something done by open AI that's great and useful.

03:32.840 --> 03:38.080
But beyond that, their GPT model is useful for all sorts of data processing.

03:38.080 --> 03:44.400
Google definitely uses Lambda, their GPT equivalent, internally to do data processing.

03:44.400 --> 03:45.400
Yeah.

03:45.400 --> 03:49.040
So there's a lot of benefit to having it.

03:49.040 --> 03:53.640
Even if it's not directly generating funds.

03:53.640 --> 03:54.960
That's not what we're talking about today.

03:54.960 --> 03:57.480
That's a future lecture, if we have time.

03:57.480 --> 04:04.400
Today, what we're talking about is fundamentals of Lambda calculus.

04:04.400 --> 04:13.680
Today, what we're talking about is fundamentals of Lambda calculus.

04:13.680 --> 04:17.000
Before we get started, a couple of quick notes.

04:17.000 --> 04:19.560
Homework 2 and PA2 are released.

04:19.560 --> 04:23.000
Homework 2 is decently harder than Homework 1.

04:23.000 --> 04:24.000
It's longer.

04:24.000 --> 04:25.080
There are more questions on it.

04:25.080 --> 04:29.600
Homework 1 had seven pretty short questions that you could kind of just throw into Node

04:29.600 --> 04:31.240
and see what happens.

04:31.240 --> 04:35.480
Homework 2 has, I think, four times as many questions.

04:35.480 --> 04:36.480
Start earlier.

04:36.480 --> 04:39.000
PA2, though, is a bit easier.

04:39.000 --> 04:43.920
It's just got, like, three or four functions that you have to implement.

04:43.920 --> 04:45.640
Video recordings seem to be a success.

04:45.640 --> 04:47.000
I have another one going now.

04:47.000 --> 04:53.200
So hopefully you'll always be able to watch these recordings as you study later.

04:53.200 --> 04:56.680
Any questions on those two before the third one?

04:56.680 --> 05:01.480
Oh, yeah.

05:01.480 --> 05:02.480
That's me.

05:02.480 --> 05:03.480
Sorry.

05:03.480 --> 05:04.840
I normally turn that off at the start of class.

05:04.840 --> 05:08.080
I got excited by this Google announcement.

05:08.080 --> 05:09.720
It's really cool.

05:09.720 --> 05:14.920
It's three times bigger than OpenAI.

05:14.920 --> 05:15.920
Not necessarily.

05:15.920 --> 05:16.920
No.

05:16.920 --> 05:22.680
It is likely better, but it's not guaranteed to be.

05:22.680 --> 05:23.960
Whole different training regimen.

05:23.960 --> 05:24.960
So...

05:24.960 --> 05:25.960
Could be anything.

05:25.960 --> 05:26.960
Questions.

05:26.960 --> 05:27.960
Questions.

05:27.960 --> 05:28.960
Questions.

05:28.960 --> 05:29.960
Okay.

05:29.960 --> 05:34.840
Then the form here that I have is a quick...

05:34.840 --> 05:37.360
Like it should take two minutes.

05:37.360 --> 05:40.480
It's a form that I have hosted on my website.

05:40.480 --> 05:48.240
If you go to uw.pister.dev...

05:48.240 --> 05:51.240
There's this DEIB form here.

05:51.240 --> 05:58.200
It'll take you to a Google form where I'm asking a simple set of questions.

05:58.200 --> 05:59.200
It's not...

05:59.200 --> 06:00.200
Oh.

06:00.200 --> 06:01.200
Okay.

06:01.200 --> 06:02.200
It apparently needs you to log in.

06:02.200 --> 06:05.480
It does not collect your email or anything of the sort.

06:05.480 --> 06:06.720
It's completely anonymous.

06:06.720 --> 06:09.600
I am not recording names or anything like that.

06:09.600 --> 06:15.080
But this is part of the micro grant that I received where I'm trying to figure out how

06:15.080 --> 06:18.760
to engage best for your learning.

06:18.760 --> 06:22.400
So if you could answer those questions as honestly as you can.

06:22.400 --> 06:27.120
If you don't have a computer with you today, I mean, you could probably do it on your phone,

06:27.120 --> 06:28.320
because it's a Google form.

06:28.320 --> 06:31.720
But the slides are up with the links, so please do it later.

06:31.720 --> 06:37.280
I'll give you guys two to three minutes right now, though, just to fill it out.

06:37.280 --> 06:38.520
Don't spend...

06:38.520 --> 06:40.060
You don't need to put a lot of effort.

06:40.060 --> 06:42.440
Just whatever first comes to mind.

06:42.440 --> 06:43.440
Yeah.

06:43.440 --> 06:44.440
Yeah.

06:44.600 --> 06:47.600
The link is...

06:47.600 --> 06:50.600
Somewhere.

07:03.240 --> 07:04.240
Is it working?

07:04.240 --> 07:05.240
You guys can access it?

07:05.240 --> 07:06.240
Okay.

07:14.440 --> 07:17.440
Okay.

07:44.440 --> 07:47.440
Okay.

08:14.440 --> 08:17.440
Okay.

08:44.440 --> 08:48.440
Okay.

09:14.440 --> 09:34.440
All right.

09:34.440 --> 09:36.320
If you were able to fill out the form, thank you.

09:36.320 --> 09:38.000
I appreciate your input.

09:38.000 --> 09:40.960
It will improve my teaching down the line.

09:40.960 --> 09:43.640
If you weren't able to fill out the form, either you need more time or you didn't have

09:43.640 --> 09:47.060
your computer, please find time later tonight to do that.

09:47.060 --> 09:50.000
It really just takes, like, two minutes.

09:50.000 --> 09:53.880
Now we're going to move on to LambdaCalc, though.

09:53.880 --> 09:56.880
So I did a sign reading.

09:56.880 --> 09:57.880
A sign reading.

09:57.880 --> 10:02.800
I uploaded, like, a few photos from my phone of a book.

10:02.800 --> 10:07.160
How many of you were able to read the PDF that I uploaded?

10:07.160 --> 10:08.400
Okay.

10:08.400 --> 10:09.400
Decent number of you.

10:10.200 --> 10:15.600
Then some decent number of you understand what this line of code means.

10:15.600 --> 10:20.200
But we're going to dive into it pretty explicitly.

10:20.200 --> 10:31.360
So what I'm saying here is an expression can become a variable X, or it can become a function

10:31.360 --> 10:39.320
that takes a parameter X and has an expression for a body, or it can become an expression

10:39.320 --> 10:43.320
with another expression passed in as an argument.

10:43.320 --> 10:49.740
That's the English way of reading this line of code.

10:49.740 --> 10:54.480
So how can we use that?

10:54.480 --> 10:56.160
If we wanted to...

10:56.160 --> 10:57.160
This is...

10:57.160 --> 10:58.160
Sorry.

10:58.160 --> 10:59.160
Backing up a step.

10:59.160 --> 11:03.080
This is the grammar for LambdaCalculus.

11:03.080 --> 11:08.360
This is the CFG, the context-free grammar, for the language LambdaCalculus.

11:08.360 --> 11:09.960
That's all that you need.

11:09.960 --> 11:18.800
So what this means is that we can start from E and turn this into a valid LambdaCalculus

11:18.800 --> 11:20.320
program.

11:20.320 --> 11:26.760
That's one step that we could take from E to generate a valid LambdaCalculus program.

11:26.760 --> 11:40.120
Yeah, so we can use E goes to an X and turn this into the variable X.

11:40.120 --> 11:43.080
X is a LambdaCalculus program.

11:43.080 --> 11:46.400
All it is is a variable called X.

11:46.400 --> 11:47.880
That's the program.

11:47.880 --> 11:49.840
Pretty simple.

11:49.840 --> 11:52.720
What if we wanted a slightly more complex program?

11:52.720 --> 12:00.980
What's a different step that we could take right here that would lead us down that path?

12:00.980 --> 12:13.120
What else could we do?

12:13.120 --> 12:14.400
Apply E to itself.

12:14.400 --> 12:26.080
So we can use this third rule to turn E into E1, E2, where these are different Es.

12:26.080 --> 12:30.080
What's another step that we can take from this program?

12:30.080 --> 12:31.840
This is a partial program.

12:31.840 --> 12:34.360
It's not complete.

12:34.360 --> 12:35.360
What can we do to this one?

12:35.360 --> 12:36.360
To E1, E2?

12:36.360 --> 12:54.360
Yeah, so let's turn this...

12:54.360 --> 12:55.360
Either one.

12:55.360 --> 12:56.360
Either one or both.

12:56.360 --> 12:57.680
We could turn into X.

12:57.680 --> 13:04.200
So we could say that this E1 becomes an X, and then we still have our E2.

13:05.040 --> 13:09.960
So E1, by this production rule, we could turn E into X.

13:09.960 --> 13:11.960
So we've turned E into X.

13:11.960 --> 13:14.120
We've turned E1 into X specifically.

13:14.120 --> 13:16.560
We still have E2.

13:16.560 --> 13:22.040
What else can we do to continue simplifying or turning this into a real program?

13:22.040 --> 13:40.200
Yeah, so let's turn this E2, using the second rule, into lambdaX.E.

13:40.200 --> 13:46.200
So this would turn into X, lambdaX.E.

13:46.200 --> 13:54.320
I'm putting parentheses just to keep that together, because this one E, E2, turned into

13:54.320 --> 13:59.000
lambdaX.E by our second production rule.

13:59.000 --> 14:00.000
But it's still not done.

14:00.000 --> 14:01.440
We have an E in here.

14:01.440 --> 14:02.440
What can we do?

14:02.440 --> 14:11.640
Yeah, sure, we could turn this E into an X, using the first rule.

14:11.640 --> 14:18.680
And our final result here would be X, lambdaX.X.

14:18.680 --> 14:24.240
This is another valid program in lambda calculus.

14:24.240 --> 14:27.320
I don't know what it means or what it does.

14:27.320 --> 14:30.200
Right now, we don't actually care.

14:30.200 --> 14:35.240
But we know that it's valid, because we used the syntax, the grammar that we've been given,

14:35.240 --> 14:41.560
to generate it.

14:41.560 --> 14:46.160
We're gonna spend a little bit more time with the slides, like, diving into what's valid,

14:46.160 --> 14:47.480
what's not valid.

14:47.480 --> 14:54.000
But these steps that we take here are the fundamental steps of developing a program

14:54.000 --> 14:55.720
from a grammar.

14:55.720 --> 14:58.160
You do it with everything that you do.

14:58.160 --> 15:04.040
When you write code, JavaScript has a grammar that's way more complicated than this, but

15:04.040 --> 15:06.680
it fundamentally turns into something like that.

15:07.080 --> 15:12.720
English as well has a grammar where we start from expressions and build things out with

15:12.720 --> 15:18.520
noun phrases and replace the noun in the noun phrase with this or that.

15:18.520 --> 15:23.280
So context-free grammars have applications everywhere.

15:23.280 --> 15:26.360
Here what we're using them for is to generate valid programs.

15:26.360 --> 15:27.360
Yeah?

15:27.360 --> 15:38.280
Yeah, so what's the deal with these 1, 2?

15:38.280 --> 15:40.520
Why doesn't this one have one?

15:40.520 --> 15:42.240
The numbers here are arbitrary.

15:42.240 --> 15:43.920
We could give them any name we wanted.

15:43.920 --> 15:53.700
We could say that this is E1, and E1 turns into E2, E3, which turns into XE3, which turns

15:53.700 --> 15:56.320
into E4.

15:56.920 --> 16:02.720
So each of these are their own expression, independent of the other expressions.

16:02.720 --> 16:06.760
That's what the context-free part of context-free grammar means.

16:06.760 --> 16:07.760
Yeah?

16:07.760 --> 16:15.280
Yeah, so what's the deal with this X?

16:15.280 --> 16:18.320
Or this X or this X, right?

16:18.320 --> 16:19.560
Or even this X.

16:19.560 --> 16:23.000
So all of these are variables in our language.

16:23.000 --> 16:28.840
They're just like in JavaScript when we say let X equal 3.

16:28.840 --> 16:30.760
This X here.

16:30.760 --> 16:33.640
They're the variables that are gonna capture some meaning.

16:33.640 --> 16:36.840
We can actually use whatever we want here.

16:36.840 --> 16:41.400
So we could say this is actually the variable Y.

16:41.400 --> 16:42.480
You know, use a different name.

16:42.480 --> 16:45.000
I've just put X to keep things simple.

16:45.000 --> 16:46.840
We can name it whatever we want.

16:46.840 --> 16:49.400
Just don't name it E, because E is our expression.

16:49.400 --> 16:56.600
I think for clarity, could you explain the difference between the X, which is a variable,

16:56.600 --> 16:59.800
and an expression, which is E, right?

16:59.800 --> 17:00.800
Right.

17:00.800 --> 17:09.720
So what's the difference between this and this?

17:09.720 --> 17:17.600
The key difference, E has somewhere to go.

17:17.600 --> 17:19.360
It is non-terminal.

17:19.360 --> 17:24.600
E can turn into one of these three things.

17:24.600 --> 17:28.040
X is what's called a terminal.

17:28.040 --> 17:30.320
There's nowhere that X can go.

17:30.320 --> 17:32.980
It can't turn into anything else.

17:32.980 --> 17:40.720
We don't have a rule that says X is equal to, I don't know, what would even make sense

17:40.720 --> 17:41.720
here.

17:41.720 --> 17:44.480
Let's say X is equal to 3.

17:44.480 --> 17:52.080
If we had a rule like this, that means when we're generating our program, we have to turn

17:52.080 --> 17:58.520
these Xs into their corresponding value, in this case, 3.

17:58.520 --> 18:07.200
Because we don't have a production rule with X in it, X is a terminal value, and that's

18:07.200 --> 18:08.200
just part of our language.

18:08.200 --> 18:14.640
It's a feature of our language.

18:14.640 --> 18:17.160
So this is the syntax.

18:17.160 --> 18:18.160
It's the grammar.

18:18.160 --> 18:19.160
Do you have another question?

18:19.160 --> 18:20.160
Yeah.

18:20.160 --> 18:23.160
Again, could you also just explain what lambda is?

18:23.160 --> 18:25.600
Ah, yeah, sure.

18:25.600 --> 18:27.400
What is lambda?

18:27.400 --> 18:28.800
What is dot?

18:28.800 --> 18:30.160
What do these things mean?

18:30.160 --> 18:31.720
At this point, it doesn't matter.

18:31.720 --> 18:34.840
We're talking not about meaning.

18:34.840 --> 18:39.080
We're just talking about what is valid and what's not valid.

18:39.080 --> 18:41.880
What programs can exist?

18:41.880 --> 18:45.760
The meaning is something that we're going to dive into of, like, what does each of these

18:45.760 --> 18:47.720
characters represent?

18:47.720 --> 18:49.880
But that's semantics.

18:49.880 --> 18:54.440
This is syntax.

18:54.440 --> 18:58.200
And I want those two to be pretty separate in your mind.

18:58.200 --> 19:01.620
What is a valid thing in lambda calculus?

19:01.620 --> 19:11.060
And then once I know that it's valid, what does that valid thing mean?

19:11.060 --> 19:17.980
The one thing that I've put in here that's not actually in our grammar is these parentheses.

19:17.980 --> 19:22.180
Parentheses help us just to associate things together, just like we would do in math, where

19:22.180 --> 19:27.460
you say, like, multiply these two things first, then do the division.

19:27.460 --> 19:34.100
So any time we turn E into one of these three, we're effectively putting parentheses around

19:34.100 --> 19:35.100
it.

19:35.100 --> 19:41.060
And we could, if we wanted, put parentheses around each of those production rules.

19:41.060 --> 19:42.060
Yeah?

19:42.060 --> 19:50.900
Shouldn't it just start by, like, readability, which is, like, names, and stuff like that?

19:50.900 --> 19:51.900
Well, so...

19:51.900 --> 19:52.900
Do they actually change the...?

19:52.900 --> 19:53.900
Right.

19:53.900 --> 19:54.900
Yes and no.

19:55.220 --> 19:58.020
And this, our equivalent...

19:58.020 --> 20:00.180
In this case, it is just readability.

20:00.180 --> 20:03.100
At some points, parentheses will matter.

20:03.100 --> 20:08.220
So having them helps from the start.

20:08.220 --> 20:10.940
But they will matter.

20:10.940 --> 20:13.500
Yeah.

20:13.500 --> 20:16.140
Okay.

20:16.140 --> 20:25.500
Any other questions on syntax here?

20:25.500 --> 20:31.620
If this is the first time you've seen context-free grammars, I recognize it's tricky.

20:31.620 --> 20:32.620
They're different.

20:32.620 --> 20:35.700
And it's a new way of expressing language.

20:35.700 --> 20:38.580
Read the chapter that I uploaded to Piazza.

20:38.580 --> 20:39.780
It's ten pages.

20:39.780 --> 20:40.780
It's not...

20:40.780 --> 20:42.780
And it's a small book.

20:42.780 --> 20:46.580
So it will probably take 15, 20 minutes tops.

20:46.580 --> 20:48.580
And it will hopefully clarify some of this.

20:48.580 --> 20:49.580
Yeah?

20:49.580 --> 21:00.580
Does the X in front of the root get the statement that's kind of part of the head, or is the

21:00.580 --> 21:01.580
head just the lambda X?

21:01.580 --> 21:02.580
The head.

21:02.580 --> 21:03.580
I guess, I don't know.

21:03.580 --> 21:04.580
I'm just trying to figure out the format of it.

21:04.580 --> 21:11.580
I'm trying to figure out the format of it so I can read something that says that the

21:11.580 --> 21:12.580
head is the lambda...

21:12.580 --> 21:13.580
Oh!

21:13.580 --> 21:14.580
In lambda calculus, you mean.

21:14.580 --> 21:15.580
Yeah, yeah, yeah.

21:15.580 --> 21:17.140
So there's...

21:17.140 --> 21:18.880
This is its own expression.

21:18.880 --> 21:19.880
This X.

21:19.880 --> 21:22.140
You're asking about this piece, right?

21:22.140 --> 21:23.140
Yeah.

21:23.140 --> 21:30.260
So this piece here, this lambda X dot, which corresponds to this piece here, that's what

21:30.260 --> 21:32.980
we're going to dive into with semantics.

21:32.980 --> 21:34.980
Yeah.

21:34.980 --> 21:36.980
Okay.

21:36.980 --> 21:47.620
So let's start talking about semantics.

21:47.620 --> 21:50.140
Because that's what you guys keep asking about.

21:50.140 --> 21:51.140
Which is fair.

21:51.140 --> 21:56.980
Because that's what the language actually is.

21:56.980 --> 22:01.020
Okay.

22:01.020 --> 22:03.700
So we've seen this grammar.

22:03.700 --> 22:06.100
That's what I just had up on the board.

22:06.100 --> 22:11.260
E can turn into a variable, which we could call X, Y, Z, whatever we wanted.

22:11.260 --> 22:17.400
It can turn into a function that takes a parameter named X and returns an expression E. Or it

22:17.400 --> 22:23.020
can turn into a function application of E1 onto E2.

22:23.020 --> 22:27.140
So we have variables, such as X, Y, Z.

22:27.220 --> 22:32.140
We have functions, or lambda abstractions is another way of saying that.

22:32.140 --> 22:36.340
I'm going to dive into that part next.

22:36.340 --> 22:44.220
But the way to, like, just very straightforwardly think of it is lambda X dot E is equivalent

22:44.220 --> 22:48.500
to X arrow E in JavaScript.

22:48.500 --> 22:52.060
We've just started working with arrow syntax.

22:52.060 --> 22:56.420
But if you're getting more familiar with it, that might help.

22:56.420 --> 23:00.300
And then the last thing that we have is function application.

23:00.300 --> 23:07.180
Which in JavaScript looks like E1 is the function, where E2 is the argument.

23:07.180 --> 23:12.420
So these are the JavaScript conversion rules.

23:12.420 --> 23:17.380
Okay.

23:17.380 --> 23:20.920
We're sticking with syntax just for a second.

23:20.920 --> 23:28.480
One term that we might have is something like lambda X dot 2 plus X.

23:28.480 --> 23:30.840
And immediately you might say, hey, wait.

23:30.840 --> 23:32.000
You've lied to me.

23:32.000 --> 23:33.000
What is 2?

23:33.000 --> 23:34.220
What is plus?

23:34.220 --> 23:35.840
We don't have those things in our language.

23:35.840 --> 23:39.280
We only have X, lambda X, E1, E2.

23:39.280 --> 23:40.460
And that's fair.

23:40.460 --> 23:48.220
But you can't actually represent numbers and addition with these terms alone.

23:48.220 --> 23:50.980
We will do that at the end of next lecture, I believe.

23:50.980 --> 23:52.300
So for now, just bear with me.

23:52.300 --> 23:57.620
We can pretend that they exist in our language as normal entities.

23:57.620 --> 24:04.660
So lambda X dot 2 plus X would be the equivalent of a JavaScript function that takes a variable

24:04.660 --> 24:11.260
X and it returns 2 plus X.

24:11.260 --> 24:18.940
If we wanted to call that function with the value 5, that would look something like this.

24:18.940 --> 24:25.540
Lambda X dot 2 plus X applied to the value 5.

24:25.540 --> 24:31.460
So if we looked at it in JavaScript, that would look something like X arrow 2 plus X

24:31.460 --> 24:39.260
with the input value of 5.

24:39.260 --> 24:41.540
Before we get to this complicated one...

24:41.540 --> 24:42.900
Oh, no?

24:42.900 --> 24:43.900
Okay.

24:43.900 --> 24:47.300
I hit it too many times.

24:47.300 --> 24:54.540
I want to take a step and go backwards from what we're looking at there.

24:54.540 --> 24:57.220
Which is hard, because they don't give us much whiteboard space.

24:57.220 --> 24:59.100
But we'll make it work.

24:59.100 --> 25:08.920
So we have lambda X dot 2 plus X applied to 5.

25:08.920 --> 25:11.360
They have one more set of parentheses.

25:11.360 --> 25:14.960
That's fine.

25:14.960 --> 25:21.120
So I want to use the syntax that we have, our grammar that we've defined, and break

25:21.120 --> 25:25.440
this apart into the rules that we have.

25:25.440 --> 25:30.300
Using X, lambda X dot E, and E1, E2.

25:30.300 --> 25:41.220
How can we reverse engineer this statement into the expressions that it's composed of?

25:41.220 --> 25:46.340
What would be the steps to do that?

25:46.340 --> 25:50.620
Yeah.

25:50.620 --> 25:56.480
Let's do a little bit of a simpler one.

25:56.480 --> 26:07.640
If we have lambda X dot X, we can go backwards from this state to our expression by saying

26:07.640 --> 26:15.280
this is equivalent to lambda X dot E, where we've turned E into X.

26:15.280 --> 26:18.120
So we're reversing our production rule.

26:18.120 --> 26:25.560
And then this is equivalent to E. Where E is using the production rule, E turns into

26:25.560 --> 26:32.880
lambda X dot E. Using the production rule, E turns into X.

26:32.880 --> 26:38.360
So if we started with E, we could take this step and then take that step using our production

26:38.360 --> 26:41.400
rules.

26:41.400 --> 26:46.560
I want to do that same process on this more complicated term.

26:46.560 --> 26:48.400
Yeah.

26:48.400 --> 26:59.840
Yeah, so let's turn 2 plus X into E. That's a reasonable thing to do here.

26:59.840 --> 27:05.400
I guess we don't need this second parenthesis anymore.

27:05.400 --> 27:12.560
So what we've done here is, say, we have some complicated expression, 2 plus X.

27:12.560 --> 27:17.840
Let's turn that into E. You know, for whatever E is.

27:17.840 --> 27:21.160
Then we have this step here.

27:21.160 --> 27:28.200
What's another backward step we can take?

27:28.200 --> 27:30.240
Turn 5 into E. Yeah, sure.

27:30.240 --> 27:34.600
This 5 can be a different E. We'll give this one a new name.

27:34.600 --> 27:37.400
We'll call this one E2.

27:37.400 --> 27:39.200
Lambda X dot E1.

27:39.200 --> 27:40.640
So just to keep them separate.

27:40.640 --> 27:44.560
They aren't the same variable E. They're a different expression.

27:44.560 --> 27:46.080
Yeah.

27:47.080 --> 27:52.160
Yeah, so this lambda X E1, we can call that E3.

27:52.160 --> 27:55.240
And then we still have E2.

27:55.240 --> 27:59.080
What's our last step?

27:59.080 --> 28:10.480
We know that E1, E2 is one of the productions of E. So we can generate some E4.

28:10.480 --> 28:18.080
So what we've done here is, we've stepped backwards from a final term, a program, into

28:18.080 --> 28:19.580
the base expression.

28:19.580 --> 28:23.600
Which means that we have a valid program in lambda calculus.

28:23.600 --> 28:25.960
We were able to backward step here.

28:25.960 --> 28:26.960
All the way to E. Yeah?

28:26.960 --> 28:42.120
Yeah.

28:42.120 --> 28:49.640
So what if...

28:49.640 --> 28:59.600
In JavaScript, or in any language, really, we can do something like F of 3 times 2.

28:59.600 --> 29:05.640
Where we have a complicated expression as a parameter to a function.

29:05.640 --> 29:13.280
This is an E. But it's an E in the same exact way that F of 3 is.

29:13.280 --> 29:17.360
Both of those are expressions that have a value.

29:17.360 --> 29:21.000
That we want to, you know, backwards figure out.

29:21.000 --> 29:29.240
Now, the specifics of how we can turn 5, which we're kind of hand waving as being part of

29:29.240 --> 29:33.480
our language, into E is fair.

29:33.480 --> 29:36.520
What I would say is...

29:36.520 --> 29:42.460
We can write this as a full, long lambda expression.

29:42.460 --> 29:44.800
But 5 is just shorter.

29:44.800 --> 29:45.800
To do that.

29:45.800 --> 29:46.800
Yeah.

29:46.800 --> 29:50.840
But it would look kind of like 3 times 2.

29:50.840 --> 29:56.880
When you write it all out.

29:56.880 --> 30:09.600
Other questions about this backwards process that we've taken?

30:09.600 --> 30:10.600
Yeah.

30:10.600 --> 30:14.840
The three production rules that I gave you are the three rules of lambda calculus.

30:14.840 --> 30:16.380
That's all that there is.

30:16.380 --> 30:21.040
People put more rules on top of it to create variants of lambda calculus.

30:21.040 --> 30:25.920
Things like typed lambda calculus or lambda calculus with objects.

30:25.960 --> 30:34.240
But the base lambda calculus only has those three rules.

30:34.240 --> 30:36.840
Other questions?

30:36.840 --> 30:40.120
Okay.

30:40.120 --> 30:43.000
In that case...

30:43.000 --> 30:46.640
We have another example term here.

30:46.640 --> 30:53.680
Lambda F dot F of 3 applied to lambda X dot X plus 1.

30:53.680 --> 30:54.680
Yeah?

30:55.080 --> 30:56.080
Yeah.

30:56.080 --> 31:11.200
Yeah, so we went in a very specific order here.

31:11.200 --> 31:12.720
Does that order matter?

31:12.720 --> 31:14.560
Could we have gone in another order?

31:14.560 --> 31:23.000
And would it have still worked?

31:23.000 --> 31:24.000
You are nodding.

31:24.000 --> 31:25.000
Right.

31:25.000 --> 31:26.000
Exactly.

31:26.000 --> 31:43.400
So we could have swapped some of these things around and done them in a different order.

31:43.400 --> 31:46.280
We could have done this 5 to E2 right away.

31:46.280 --> 31:48.320
And then done the next rule right after it.

31:48.320 --> 31:50.120
And that would be fine.

31:50.120 --> 31:54.760
That's another feature of the fact that these are context-free grammars.

31:54.760 --> 31:56.720
The order here doesn't matter.

31:56.720 --> 31:59.560
So long as you're applying the rules correctly.

31:59.560 --> 32:03.520
If you try and turn, like, the whole...

32:03.520 --> 32:09.240
Like this piece here into an expression, that's, like, cheating.

32:09.240 --> 32:10.900
It doesn't work in the language.

32:10.900 --> 32:13.080
So you'll get a different answer.

32:13.080 --> 32:17.760
But so long as you apply valid rules from the language, you'll always end up in the

32:17.760 --> 32:20.880
same place.

32:20.880 --> 32:45.320
Little bit of an asterisk there that we'll cover at the end of the next lecture.

32:45.320 --> 32:52.720
So importantly, we can't go back up any way that we want.

32:52.720 --> 32:59.280
Once we have created our system here, we're actually storing more information than I've

32:59.280 --> 33:00.520
written.

33:00.520 --> 33:07.640
For example, we would say this step here works so long as...

33:07.640 --> 33:09.020
Where can I write this?

33:09.020 --> 33:14.980
So long as E is equal to X plus 2.

33:14.980 --> 33:16.340
Or 2 plus X.

33:16.340 --> 33:21.540
And then we can take this next step so long as E1 is equal to...

33:21.540 --> 33:24.820
Oh, I guess that's what we've said here.

33:24.820 --> 33:26.460
So E1 equals that.

33:26.460 --> 33:30.840
And then E2 is equal to 5.

33:30.840 --> 33:38.500
And then we can take this next step so long as E3 is equal to lambdaX.E1, et cetera.

33:38.500 --> 33:43.300
So we're encoding that transformation in this backwards process.

33:43.300 --> 33:47.780
But that's not super important towards the class.

33:47.780 --> 33:54.380
It's just that that is the way that we're doing it.

33:54.380 --> 33:55.380
That's brilliant.

33:55.380 --> 33:56.380
All right.

33:56.380 --> 33:57.380
Thank you.

33:57.380 --> 33:58.380
Thank you for that note.

33:58.380 --> 34:06.380
We will use this for the next stuff on the board.

34:06.380 --> 34:08.860
Other questions?

34:08.860 --> 34:11.220
Okay.

34:11.220 --> 34:18.280
Then try and do this same backwards process that we've done on the second example.

34:18.280 --> 34:23.540
On this third one, feel free to chat with someone next to you to figure it out.

34:23.540 --> 34:25.740
But try and get all the way back to sum E.

35:55.740 --> 36:04.740
All right.

36:04.740 --> 36:08.700
Let's put it together as a class.

36:08.700 --> 36:12.400
I've got the expression up here.

36:12.400 --> 36:13.620
Let's go backwards.

36:13.620 --> 36:17.380
What's one first step that we could take?

36:17.380 --> 36:22.420
Yeah.

36:22.420 --> 36:27.900
We can turn this X plus 1 into an E1, let's say.

36:27.900 --> 36:28.900
LambdaX.E1.

36:28.900 --> 36:29.900
Okay.

36:29.900 --> 36:33.260
And then we keep everything else.

36:33.260 --> 36:36.460
Cool.

36:36.460 --> 36:44.220
What's another step that we could take from here?

36:44.220 --> 36:46.860
We could turn the 3 into an E. Yeah.

36:46.860 --> 36:47.860
Sure.

36:47.860 --> 36:50.020
So here we kind of elided that step.

36:50.020 --> 36:53.900
We turned our X plus 1 all into an E. That's fine.

36:53.900 --> 36:57.000
We can do the same...

36:57.000 --> 37:01.100
Over here, I guess we're going to just do the 3, and that's okay.

37:01.100 --> 37:10.220
So F of E2, lambdaX.E1.

37:10.220 --> 37:11.220
What else can we do?

37:11.220 --> 37:12.220
Yeah.

37:12.220 --> 37:13.220
Behind you.

37:13.220 --> 37:14.220
Sorry.

37:14.220 --> 37:15.220
FE2 into E4.

37:15.220 --> 37:16.220
Yeah.

37:16.220 --> 37:17.220
We can totally turn that into E4.

37:17.220 --> 37:18.220
Cool.

37:18.220 --> 37:19.220
All right.

37:19.220 --> 37:20.220
So that's good.

37:20.220 --> 37:21.220
We're good.

37:21.220 --> 37:22.220
We're good.

37:22.220 --> 37:23.220
That's fine.

37:23.220 --> 37:24.220
We can do that.

37:24.220 --> 37:25.220
All right.

37:25.220 --> 37:26.220
So let's...

37:26.220 --> 37:27.220
We can do a class.

37:27.220 --> 37:28.220
That's fine.

37:28.220 --> 37:29.220
We're good.

37:29.220 --> 37:30.220
Let's go back.

37:30.220 --> 37:31.220
What else can we do?

37:31.220 --> 37:32.220
Yeah.

37:32.220 --> 37:33.220
Oh.

37:33.220 --> 37:34.220
Behind you.

37:34.220 --> 37:35.220
Sorry.

37:35.220 --> 37:36.220
FE2 into E4.

37:36.220 --> 37:38.580
Yeah.

37:38.580 --> 37:44.140
We can totally turn that into E4, E3.

37:44.140 --> 37:45.140
And then...

37:45.140 --> 37:46.140
Yeah.

37:46.140 --> 37:47.140
One from here.

37:47.140 --> 37:48.140
Yep.

37:48.140 --> 37:53.980
Turn that into E5, E3.

37:53.980 --> 37:55.740
And finally...

37:55.740 --> 38:00.620
You guys in the back probably can't see all the way down anymore, but...

38:00.620 --> 38:02.700
Turn the last thing into E6.

38:02.700 --> 38:04.280
Why not?

38:04.280 --> 38:13.800
So we're able to go from this complicated expression, step by step, into a simple E6.

38:13.800 --> 38:16.320
And each of these E's has a different value.

38:16.320 --> 38:21.400
We've given it some number or some meaning inside of there.

38:21.400 --> 38:25.240
But we can forget about that at this point.

38:25.240 --> 38:31.880
The point is we were able to get down to E, which means we have a valid program.

38:31.880 --> 38:38.320
This is exactly the process that your IDE takes every time it gives you a redline squiggle.

38:38.320 --> 38:41.080
And it says, hey, your code is bad.

38:41.080 --> 38:44.040
You forgot to write int at the start of this line.

38:44.040 --> 38:45.680
Or you forgot the semicolon.

38:45.680 --> 38:50.160
It's going through this process constantly, trying to figure out where do you fail to

38:50.160 --> 38:52.640
parse your code?

38:52.640 --> 38:56.600
That's an error.

38:56.600 --> 39:01.880
Same exact process in a more complicated language.

39:01.880 --> 39:05.600
Okay.

39:05.600 --> 39:13.040
If we wanted to write that one as JavaScript, it might look something like this.

39:13.040 --> 39:20.520
The first part of your homework is converting JavaScript into lambda calculus.

39:20.520 --> 39:26.640
And then the second part is lambda calculus into JavaScript.

39:26.640 --> 39:34.820
So if we wanted to turn a function in JavaScript into lambda calculus, for example, function

39:34.820 --> 39:45.880
composition, what would function composition look like in JavaScript?

39:45.880 --> 39:53.760
So this is a function where we're applying f of f of x.

39:53.760 --> 39:58.060
F of x, instead of fog x.

39:58.060 --> 40:01.920
What would this look like?

40:01.920 --> 40:04.920
Yeah?

40:04.920 --> 40:20.820
Yeah, so the main function body is going to be f of f of x.

40:20.820 --> 40:23.600
But we're defining a function to do this.

40:23.600 --> 40:32.160
So we might have some sort of x goes to this result.

40:32.160 --> 40:36.840
It's a function that takes x and applies f of f of x to it.

40:36.840 --> 40:45.000
Or we might go a step further and say it's a function that takes a function f and a value

40:45.000 --> 40:51.720
x and then applies f of f of x.

40:51.720 --> 40:54.200
That's probably how I would write it in JavaScript.

40:54.200 --> 40:57.280
Let's see if that's what I wrote over here.

40:57.280 --> 40:58.960
Yes.

40:58.960 --> 41:07.040
Basically the same, but I've separated out the parameters.

41:07.040 --> 41:10.120
Questions on this composition function?

41:10.120 --> 41:13.920
Before we take it a step further?

41:13.920 --> 41:15.920
Okay.

41:15.920 --> 41:17.920
So...

41:17.920 --> 41:20.920
Oh, yeah.

41:20.920 --> 41:39.760
That's primarily a preference thing.

41:39.760 --> 41:40.760
Yeah.

41:40.760 --> 41:41.760
No.

41:41.760 --> 41:48.440
No, like, performance or readability for general people, I would assume.

41:48.440 --> 41:52.000
Some people prefer one way, some would prefer another.

41:52.000 --> 41:53.480
In some cases it matters.

41:53.480 --> 41:56.160
But we can talk about that later.

41:56.160 --> 41:57.800
All right.

41:57.800 --> 42:02.880
So then let's use this function.

42:02.880 --> 42:10.600
So the inner part here from f up to these parentheses is the same function that we've

42:10.600 --> 42:12.040
written already.

42:12.040 --> 42:15.360
But now we're calling it with two parameters.

42:15.360 --> 42:21.560
We're calling it with a function that takes in a variable x and returns x plus 1.

42:21.560 --> 42:25.400
And we're calling it with the number 4.

42:25.400 --> 42:29.800
Right off the bat, what would you assume this program is going to output?

42:29.800 --> 42:34.760
What's the return value of this final thing?

42:34.760 --> 42:37.340
6, right?

42:37.340 --> 42:41.280
We're going to call x plus 1 on 4 twice.

42:41.280 --> 42:46.720
So we get 4 plus 1 is 5, plus 1 is 6.

42:46.720 --> 42:47.720
Okay.

42:47.720 --> 42:53.280
So this is how we would write and then use function composition.

42:53.280 --> 42:55.720
In JavaScript.

42:55.720 --> 43:00.120
Let's do it in lambda calculus.

43:00.120 --> 43:08.400
Here we've seen this, like, application before, where we're passing things in.

43:08.400 --> 43:10.300
I guess we've done that over here.

43:10.300 --> 43:14.560
But the 5 is the argument.

43:14.560 --> 43:33.140
So what this would look like is something like lambda f dot lambda x dot f of f of x.

43:33.140 --> 43:46.380
And what we've done, if we look at it as a transformation, I guess I've put in these

43:46.380 --> 43:47.380
extra parentheses.

43:47.380 --> 43:51.300
We don't need to.

43:51.300 --> 43:57.900
In JavaScript, we had our parameters on the left-hand side of this equal sign.

43:57.900 --> 44:06.140
In lambda calc, we have our parameters, x and f, on the left-hand side of these periods.

44:06.140 --> 44:08.340
Of the DOM.

44:08.340 --> 44:12.000
So x and f are our parameters.

44:12.000 --> 44:16.460
And our return is f of f of x.

44:16.460 --> 44:19.340
Which is f of f of x.

44:19.340 --> 44:25.460
And we could, if we wanted to, put in these extra parentheses, just to make it look more

44:25.460 --> 44:26.460
similar.

44:26.460 --> 44:30.900
But that would be kind of anti-lambda calc-y.

44:30.900 --> 44:37.620
So we'll write it like that much more often.

44:37.620 --> 44:43.200
Okay.

44:43.200 --> 44:50.500
If we wanted to then pass in our parameters, lambda x dotï¿½ or x goes to x plus 1 and

44:50.500 --> 44:56.180
4, that would look something like this.

44:56.180 --> 45:04.700
Where we're turning our x goes to x plus 1 function into lambda x dot x plus 1.

45:04.700 --> 45:09.700
Once again, notice the x, the parameter on the left-hand side of the equals corresponds

45:09.700 --> 45:12.500
to the x before the period.

45:12.500 --> 45:16.940
The right-hand side corresponds to the right-hand side.

45:16.940 --> 45:36.980
4 is 4.

45:36.980 --> 45:40.140
We're gonna keep going and see a lot more examples of this.

45:40.140 --> 45:43.820
So if it's feeling confusing, that's totally fine.

45:43.820 --> 45:46.760
That's very much expected, even.

45:47.580 --> 45:50.960
It will get less confusing the more that we look at it.

45:50.960 --> 45:52.960
Okay.

45:52.960 --> 45:59.800
And one way that we're gonna do this is just by doing a little, like, figure out is this

45:59.800 --> 46:02.440
valid, is this not?

46:02.440 --> 46:10.880
So if we had a term, lambda x plus y dot 3, is that valid?

46:10.880 --> 46:13.440
Give it a second of thought.

46:13.440 --> 46:21.840
You can try and go backwards from the final expression to an E, as we've done over here.

46:21.840 --> 46:24.180
If you get to E, then you're good.

46:24.180 --> 46:26.680
If you don't get to E, then you're bad.

46:26.680 --> 46:30.960
Like, I mean, the program is bad, not you.

46:30.960 --> 46:31.960
You guys are great.

46:31.960 --> 46:34.760
Thanks for showing up to class.

46:34.760 --> 46:39.760
But try and figure out, yes or no, is this valid?

46:39.760 --> 46:40.760
Okay.

46:40.760 --> 46:41.760
So let's do this.

46:41.760 --> 46:42.760
So let's do this.

46:42.760 --> 46:43.760
Okay.

46:43.760 --> 46:44.760
So let's do this.

46:44.760 --> 46:45.760
So let's do this.

46:45.760 --> 47:09.320
Okay.

47:09.320 --> 47:13.800
How many people are voting yes, valid term?

47:13.840 --> 47:16.440
How many people are voting no, not a valid term?

47:16.440 --> 47:17.440
All right.

47:17.440 --> 47:18.800
The nos have it.

47:18.800 --> 47:20.200
Why is it not valid?

47:20.200 --> 47:21.800
What's the problem here?

47:21.800 --> 47:29.120
Yeah, in the back.

47:29.120 --> 47:30.120
That's exactly right.

47:30.120 --> 47:33.720
So we have x plus y on the left-hand side of that dot.

47:33.720 --> 47:42.120
We have a rule that allows us to use lambda x dot E, but we can't turn x plus y into x.

47:42.240 --> 47:47.360
We could turn x plus y into E, into another expression, but that's not valid.

47:47.360 --> 47:49.560
That's not one of our production rules.

47:49.560 --> 47:52.920
So yep, not valid here.

47:52.920 --> 48:04.720
What about lambda x dot 3?

48:04.720 --> 48:07.360
How many people say yes, valid?

48:07.360 --> 48:08.600
No, not valid.

48:08.600 --> 48:10.000
All right.

48:10.000 --> 48:11.620
Yes, valid.

48:11.620 --> 48:18.180
We can turn 3 into E1, and then lambda x dot E1, we just use that second rule to turn

48:18.180 --> 48:20.300
it back into E. Great.

48:20.300 --> 48:24.260
What about lambda x x of x?

48:24.260 --> 48:27.580
Valid, not valid?

48:27.580 --> 48:31.060
How many people say valid?

48:31.060 --> 48:32.620
How many people say not valid?

48:32.620 --> 48:33.980
All right.

48:33.980 --> 48:35.740
A majority of valid.

48:35.740 --> 48:37.300
Yeah, this one is fine.

48:37.300 --> 48:46.260
So we can turn xx, this inside part, into E1, E2, and then E1, E2 turns into E3, and

48:46.260 --> 48:51.420
then lambda x E3 turns into E4.

48:51.420 --> 48:54.140
How about this one?

48:54.140 --> 48:56.580
Very similar, but we've replaced one of the x's with a y.

48:56.580 --> 49:05.820
Valid?

49:05.820 --> 49:07.260
Not valid.

49:07.260 --> 49:09.540
All right.

49:09.540 --> 49:11.340
Most people are saying valid here.

49:11.340 --> 49:12.660
I'm in agreement.

49:12.660 --> 49:20.420
The one caveat being that I've said E goes to x, so long as x is the set of variables.

49:20.420 --> 49:23.880
So we can name our variables anything we want.

49:23.880 --> 49:31.220
In this case, we're naming one of our variables y instead of x, which is fine.

49:31.220 --> 49:32.220
But we don't know what y is.

49:32.220 --> 49:34.540
But that's also fine.

49:34.540 --> 49:37.380
Okay.

49:37.380 --> 49:51.780
Any questions on any of these problems here?

49:51.780 --> 49:59.180
Since we're in PL, and PL people are mathematicians, and mathematicians are very tired of writing,

49:59.180 --> 50:03.020
there is more compact syntax.

50:03.020 --> 50:09.900
So for example, function application, that is E1, E2, is left associative.

50:09.900 --> 50:16.200
That means you perform the left application before the right-hand application.

50:16.200 --> 50:24.620
So E1, E2, E3 is equivalent to E1 applied to E2, the result of that applied to E3.

50:24.620 --> 50:29.860
So we don't need those parentheses if we don't want to use them.

50:30.060 --> 50:37.980
Lambdas, on the other hand, that is to say lambda abstraction or functions, bind all

50:37.980 --> 50:41.260
the way to the right.

50:41.260 --> 50:50.260
What that means is that when we have lambda x dot lambda y dot lambda z dot E, this outside

50:50.260 --> 50:56.220
lambda x goes all the way to the end of the E.

50:56.220 --> 50:59.700
We're going to go into a lot of examples of how to use this rule.

50:59.700 --> 51:04.260
So I'm not going to get too far into it now.

51:04.260 --> 51:11.740
But the trick is that you stop the, like, bounds of your lambda when you find an unmatched

51:11.740 --> 51:13.540
closing parentheses.

51:13.540 --> 51:18.500
You can think of this as the same algorithm with curly braces.

51:18.500 --> 51:24.620
When you open a curly brace at the start of a function, that function contains the scope

51:24.620 --> 51:32.740
of everything until you close the curly brace for it.

51:32.740 --> 51:36.580
Okay.

51:36.580 --> 51:43.500
So where do parentheses go in this expression?

51:43.500 --> 51:47.060
Lambda x dot x, x.

51:47.060 --> 51:56.780
Do they go around the body, the xx, or around the lambda abstraction?

51:56.780 --> 51:58.140
Chat with a neighbor.

51:58.140 --> 51:59.340
Try and come up with an answer.

51:59.340 --> 52:13.340
And a reason why.

52:43.340 --> 52:58.860
How many people say A is correct?

52:58.860 --> 53:01.740
How many people say B is correct?

53:01.740 --> 53:03.420
All right.

53:03.420 --> 53:07.420
Why is A correct?

53:07.420 --> 53:09.340
Who's got a reason for me?

53:09.340 --> 53:10.340
Yeah.

53:10.340 --> 53:15.500
Exactly.

53:15.500 --> 53:19.960
So lambdas bind all the way to the right until an unmatched closing parentheses.

53:19.960 --> 53:21.440
There are no parentheses.

53:21.440 --> 53:23.200
So lambdas go all the way.

53:23.200 --> 53:27.660
That means everything in the body is part of the lambda.

53:27.660 --> 53:28.700
Is this other...

53:28.700 --> 53:32.380
Is B a valid expression in lambda calculus?

53:32.380 --> 53:33.820
Yes?

53:33.820 --> 53:35.140
No.

53:35.140 --> 53:38.820
All right.

53:38.820 --> 53:39.820
Let's do it again.

53:40.300 --> 53:43.300
Is B a valid term in lambda calculus?

53:43.300 --> 53:44.300
Yes?

53:44.300 --> 53:45.300
No.

53:45.300 --> 53:46.300
All right.

53:46.300 --> 53:47.300
It is.

53:47.300 --> 53:49.460
It is valid.

53:49.460 --> 53:56.420
We could replace lambda x dot x using the second rule into E and turn x into E as well.

53:56.420 --> 53:57.540
E1, E2.

53:57.540 --> 53:58.540
So it's valid.

53:58.540 --> 54:00.460
It's just different.

54:00.460 --> 54:03.300
It's not what we were saying when we wrote that top term.

54:03.300 --> 54:09.140
Yeah.

54:09.140 --> 54:12.500
So if we didn't have...

54:12.500 --> 54:15.180
Oops.

54:15.180 --> 54:21.100
If we didn't have these two rules, it would be ambiguous to say...

54:21.100 --> 54:22.860
To give that term up top.

54:22.860 --> 54:26.540
We wouldn't know which one this is being represented by.

54:26.540 --> 54:31.900
But because we have these two rules, we know what that term means.

54:31.900 --> 54:32.900
Yeah.

54:32.900 --> 54:33.900
All right.

54:33.900 --> 54:36.860
What about this one?

54:36.860 --> 54:52.940
Lambda y dot lambda x, x, x.

54:52.940 --> 54:55.940
How many people vote A?

54:55.940 --> 54:58.180
How many people vote B?

54:58.180 --> 55:00.500
How many people vote C?

55:00.500 --> 55:01.500
How many people vote...

55:01.500 --> 55:02.740
We've spent too much time on it.

55:02.740 --> 55:03.740
All right.

55:03.740 --> 55:04.740
I mean, you guys all got it.

55:04.740 --> 55:05.740
This is great.

55:05.740 --> 55:06.740
Yeah.

55:06.740 --> 55:12.420
So B here, by the same logic as the previous slide, lambdas go all the way until they find

55:12.420 --> 55:14.740
a nonmatched closing parenthesis.

55:14.740 --> 55:17.180
All right.

55:17.180 --> 55:19.620
I think this is the last one of these.

55:19.620 --> 55:25.620
Are these two equivalent?

55:26.620 --> 55:33.620
Yes.

55:33.620 --> 55:34.620
They are equivalent.

55:34.620 --> 55:35.620
No.

55:35.620 --> 55:36.620
They are not equivalent.

55:36.620 --> 55:37.620
No.

55:37.620 --> 55:38.620
They are not equivalent.

55:38.620 --> 55:39.620
Great.

55:39.620 --> 55:41.300
You guys seem to be getting it.

55:41.300 --> 55:43.020
This is awesome.

55:43.020 --> 55:46.500
So the summarized rules...

55:46.500 --> 55:48.460
Applications are left associative.

55:48.460 --> 55:52.460
And precedence-wise, application happens before lambda calculus.

55:52.980 --> 55:58.660
I mean, lambda abstractions, sorry.

55:58.660 --> 56:03.940
One more way that we can make these things more compact is if we have lambda x dot lambda

56:03.940 --> 56:08.680
y dot lambda z dot e, we can just say lambda x, y, z.

56:08.680 --> 56:12.940
We aren't giving it one parameter called x, y, z.

56:12.940 --> 56:17.580
We're giving it three parameters, x, y, and z.

56:17.580 --> 56:23.660
So it's kind of the difference between this function over here, where we have two parameters

56:23.660 --> 56:24.900
at once.

56:24.900 --> 56:28.500
And if we rewrote that to be taking f, then taking x.

56:28.500 --> 56:29.500
Yeah?

56:29.500 --> 56:39.500
If you did just want one parameter called x, y, z, would you just, like, put a parenthesis

56:39.500 --> 56:40.500
around it?

56:40.500 --> 56:43.460
You wouldn't really be a mathematician then, would you?

56:43.980 --> 56:46.380
Honestly, I don't know what the notation...

56:46.380 --> 56:49.300
Like, the standard thing to do there is.

56:49.300 --> 56:53.660
People just always use single-letter variable names.

56:53.660 --> 56:54.660
Which is horrible practice.

56:54.660 --> 56:58.140
It's, like, exactly what you learn not to do in intro programming.

56:58.140 --> 57:01.020
Like, give your variables descriptive names.

57:01.020 --> 57:03.720
But because it's kind of math, it's, like...

57:03.720 --> 57:07.020
We use x, y much more often.

57:07.020 --> 57:09.380
I don't know.

57:09.380 --> 57:14.580
If you wanted, maybe, multi-character names, you could do...

57:14.580 --> 57:15.820
Then you wouldn't do this.

57:15.820 --> 57:17.280
You would keep things all separate.

57:17.280 --> 57:26.420
You would keep it like the left-hand side, perhaps.

57:26.420 --> 57:33.420
Further questions on syntax?

57:33.420 --> 57:40.820
Great.

57:40.820 --> 57:41.820
We're done with syntax.

57:41.820 --> 57:43.660
Let's get to the exciting thing.

57:43.660 --> 57:45.840
Let's actually evaluate this.

57:45.840 --> 57:49.180
Let's get to the semantics.

57:49.180 --> 57:52.020
So the semantics of lambda calc.

57:52.020 --> 57:55.540
There's basically one rule.

57:55.540 --> 58:03.180
We're going to try to reduce a term into another term as often as we can.

58:03.180 --> 58:08.660
Once we can't reduce it, we're done.

58:08.660 --> 58:10.300
That's the one rule.

58:10.300 --> 58:16.020
We're going to reduce a term into another term.

58:16.020 --> 58:19.060
Once we're done, we're done.

58:19.060 --> 58:25.140
The way we reduce is by rewriting terms.

58:25.140 --> 58:29.620
Rewriting terms means that we are doing substitution.

58:29.620 --> 58:32.220
Oops.

58:32.220 --> 58:39.060
So now what we're going to look at is what substitution means in lambda calculus.

58:39.060 --> 58:42.500
This is the one rule of lambda calc.

58:42.500 --> 58:46.500
It's the one way to do things.

58:46.500 --> 58:48.140
But there's a lot to it.

58:48.140 --> 58:50.020
So let's go through.

58:50.020 --> 58:54.740
So we can go back to our example over here that we had on the board.

58:54.740 --> 58:58.780
Lambda X dot 2 plus X of 5.

58:58.780 --> 59:01.380
We could rewrite that to JavaScript.

59:01.380 --> 59:04.980
And we would expect in JavaScript the answer to be what?

59:04.980 --> 59:12.980
The output of this expression to be what?

59:12.980 --> 59:13.980
Not a trick question.

59:13.980 --> 59:14.980
7.

59:14.980 --> 59:18.220
I heard muttered.

59:18.220 --> 59:24.980
So we would get to 7 by substituting X, our parameter, with the value 5.

59:24.980 --> 59:28.860
Because we were calling the function with the value 5.

59:28.860 --> 59:31.140
The same thing is going to happen.

59:31.140 --> 59:32.140
Or I guess...

59:32.140 --> 59:33.460
Actually, I think we...

59:33.460 --> 59:34.940
Which one goes next?

59:34.940 --> 59:35.940
Yeah.

59:35.940 --> 59:36.940
Okay.

59:36.940 --> 59:39.300
So in lambda calc, the same thing is going to happen.

59:39.300 --> 59:42.900
We're going to pass that 5 into the X.

59:43.060 --> 59:48.860
And we're going to get 2 plus 5, which then reduces to 7.

59:48.860 --> 01:00:07.900
So what we've done up above, which I can draw, is that we've passed 5 in for the value X.

01:00:07.900 --> 01:00:12.740
So lambda X dot 2 plus X applied to 5.

01:00:12.740 --> 01:00:13.900
This is a function.

01:00:13.900 --> 01:00:15.900
That's the parameter name.

01:00:15.900 --> 01:00:18.980
We're going to pass 5 in for X.

01:00:18.980 --> 01:00:23.800
And we're gonna get 2 plus 5.

01:00:23.800 --> 01:00:28.340
More specifically, what we would write, as an intermediate stage, is we would say we

01:00:28.340 --> 01:00:34.880
get 2 plus X, where X is equal to 5.

01:00:34.880 --> 01:00:44.320
Then we would get 2 plus 5, 7.

01:00:44.320 --> 01:00:51.120
Okay.

01:00:51.120 --> 01:00:54.040
The more complicated expression.

01:00:54.040 --> 01:01:02.920
In JavaScript, we have our function here with an argument here.

01:01:02.960 --> 01:01:10.920
What we would do is we would pass that function argument in for the value F. So we would replace

01:01:10.920 --> 01:01:14.320
F with the function.

01:01:14.320 --> 01:01:18.320
And then we would pass the 3 in for the X.

01:01:18.320 --> 01:01:20.200
And we'd get an output of 4.

01:01:20.200 --> 01:01:24.920
This is what we would do in JavaScript.

01:01:24.920 --> 01:01:29.480
I hope I've convinced you at this point, lambda calculus, we aren't doing anything different.

01:01:29.480 --> 01:01:32.460
It's the same thing as what we would do in JavaScript.

01:01:32.500 --> 01:01:40.000
We will pass the function argument, lambda X dot X plus 1, in for F.

01:01:40.000 --> 01:01:43.620
So we replace F with that value.

01:01:43.620 --> 01:01:46.700
Then we pass in the 3 for the X.

01:01:46.700 --> 01:01:48.740
Replace X with 3.

01:01:48.740 --> 01:01:49.740
3 plus 1.

01:01:49.740 --> 01:01:50.740
4.

01:01:50.740 --> 01:02:01.740
I'll give you a second to digest that.

01:02:02.420 --> 01:02:09.420
If you have any questions, feel free to ask.

01:02:09.420 --> 01:02:16.420
Yeah?

01:02:16.420 --> 01:02:34.140
It is not F multiplied by 3.

01:02:34.140 --> 01:02:35.140
No.

01:02:35.140 --> 01:02:40.700
So F3, the F space 3 in the center of that body, is...

01:02:40.740 --> 01:02:52.060
If we pattern matched it to our rule, we would be matching that to the E equals E1, E2 rule.

01:02:52.060 --> 01:02:58.500
And this is saying E1 is a function, E2 is the argument to that function.

01:02:58.500 --> 01:03:14.220
So we would be passing the argument 3 to the function F. Yeah.

01:03:14.220 --> 01:03:18.940
Any other questions here?

01:03:18.940 --> 01:03:23.280
Okay.

01:03:23.280 --> 01:03:25.940
Let's keep getting into it.

01:03:25.940 --> 01:03:27.520
Maybe this looks easy for now.

01:03:27.520 --> 01:03:28.800
Maybe it looks hard.

01:03:28.800 --> 01:03:30.520
If it looks hard, that's fine.

01:03:30.520 --> 01:03:32.120
If it looks easy, that's also fine.

01:03:32.120 --> 01:03:35.240
We're gonna make it a little bit trickier, though.

01:03:35.240 --> 01:03:41.600
But the idea that we've done here is we really just replaced the left-hand variable name

01:03:41.600 --> 01:03:45.880
F with the input argument.

01:03:45.880 --> 01:03:47.600
That's all that the substitution was.

01:03:47.600 --> 01:03:54.340
So substitute the term you're applying to the function for the argument variable.

01:03:54.340 --> 01:03:56.600
This isn't quite right, though.

01:03:56.680 --> 01:04:04.620
But if we wanted to use this as, like, a base, which is what we'll do, we could define E1

01:04:04.620 --> 01:04:14.620
with the context X equals E2 to mean replace every occurrence of X in E1 with E2.

01:04:14.620 --> 01:04:16.720
And this is what I've written over here.

01:04:16.720 --> 01:04:19.740
E1 is 2 plus X.

01:04:19.740 --> 01:04:23.480
X equals 5 is our X equals E2.

01:04:23.480 --> 01:04:32.260
So what we're saying is replace every instance of X with the value 5.

01:04:32.260 --> 01:04:38.780
That's like the theory way of writing it.

01:04:38.780 --> 01:04:47.240
Our general rule of reduction, then, would be that lambdaX.E1 being applied to E2 reduces

01:04:47.240 --> 01:04:51.680
to E1 where X equals E2.

01:04:51.680 --> 01:04:57.120
So any time we have a function application, you take the parameter name, set it equal

01:04:57.120 --> 01:05:05.420
to the value E2.

01:05:05.420 --> 01:05:24.660
So function application means rewrite E1 with every instance of X replaced with E2.

01:05:24.660 --> 01:05:29.220
Questions here?

01:05:29.220 --> 01:05:33.820
It's just like function application in other languages.

01:05:33.820 --> 01:05:41.860
And that's actually by design, because function applications all look the same, for the most

01:05:41.860 --> 01:05:42.860
part.

01:05:42.860 --> 01:05:43.860
Okay.

01:05:43.860 --> 01:05:44.860
No questions.

01:05:44.860 --> 01:05:49.980
That means you guys can do them.

01:05:49.980 --> 01:05:50.980
Take a second.

01:05:50.980 --> 01:05:52.400
Or take two minutes.

01:05:52.400 --> 01:05:54.620
Do both of these with your neighbor.

01:07:24.620 --> 01:07:39.500
Let's do the first one.

01:07:39.500 --> 01:07:44.780
What do we get as our next step of evaluation over here?

01:07:44.780 --> 01:07:46.740
With intermediate stages.

01:07:46.740 --> 01:07:47.740
What do we get?

01:07:47.740 --> 01:07:48.740
Yeah.

01:07:48.740 --> 01:07:49.740
Go for it.

01:07:49.740 --> 01:07:58.780
That will be...

01:07:58.780 --> 01:08:00.380
Give me the step right before that.

01:08:00.380 --> 01:08:05.500
Like the intermediate representation, which I've kind of written over there already.

01:08:05.500 --> 01:08:06.500
Yeah.

01:08:06.500 --> 01:08:07.500
Right.

01:08:07.500 --> 01:08:08.500
So same idea.

01:08:08.500 --> 01:08:13.140
2 plus X where X is equal to 5.

01:08:13.140 --> 01:08:16.540
And then that will reduce a second time.

01:08:16.540 --> 01:08:24.660
Where we can do this substitution, where we get 2 plus 5.

01:08:24.660 --> 01:08:29.020
Done.

01:08:29.020 --> 01:08:31.540
Let's do the second one.

01:08:31.540 --> 01:08:35.420
These are so fun.

01:08:35.420 --> 01:08:39.460
What can we do here?

01:08:39.460 --> 01:08:43.260
First of all, what's the order...

01:08:43.260 --> 01:08:47.700
Like, which one of these goes first?

01:08:47.700 --> 01:08:50.460
We got 4, 5, and 6.

01:08:50.460 --> 01:08:51.460
How many people...

01:08:51.460 --> 01:08:53.660
Well, so I guess...

01:08:53.660 --> 01:08:56.940
We want to figure out what goes into X.

01:08:56.940 --> 01:09:00.340
That's our outermost function variable.

01:09:00.340 --> 01:09:02.940
We have three options.

01:09:02.940 --> 01:09:05.860
How many people are gonna vote that it's 4?

01:09:05.860 --> 01:09:08.200
How many people are voting it's 5?

01:09:08.200 --> 01:09:10.560
How many people are voting it's 6?

01:09:10.560 --> 01:09:11.560
Okay.

01:09:11.560 --> 01:09:15.600
So we have mostly 4 with a little bit of 6.

01:09:15.600 --> 01:09:18.040
Why would it be 4?

01:09:18.040 --> 01:09:19.440
Yeah.

01:09:19.440 --> 01:09:26.920
Outside of parentheses, things go left to right.

01:09:26.920 --> 01:09:30.320
Function application is left associative.

01:09:30.320 --> 01:09:41.640
So that means E1, E2, E3 is equivalent to E1, E2 first, then the result of that with

01:09:41.640 --> 01:09:43.800
E3.

01:09:43.800 --> 01:09:49.220
So if we wanted to draw parentheses in here, we would do...

01:09:49.220 --> 01:10:02.780
If we call all of this E1, 4, 5, 6, it would be E1, 4, the result of that, 5, the result

01:10:02.780 --> 01:10:07.820
of that, 6.

01:10:07.820 --> 01:10:10.280
Okay?

01:10:10.280 --> 01:10:22.000
With that knowledge ahead of us, what can we do?

01:10:22.000 --> 01:10:23.480
How can we reduce this?

01:10:23.480 --> 01:10:31.480
Can you just do 1 plus 3 and then...

01:10:31.480 --> 01:10:33.520
You're skipping ahead a little bit.

01:10:33.520 --> 01:10:37.520
Give me all the simple steps in between.

01:10:37.520 --> 01:10:38.520
You got an idea?

01:10:38.520 --> 01:10:47.720
I don't know if it's just simple steps, but the...

01:10:47.720 --> 01:10:50.040
That's what it is.

01:10:50.040 --> 01:10:51.040
What do you mean?

01:10:51.040 --> 01:10:52.040
I mean...

01:10:52.040 --> 01:10:54.040
I might be misunderstanding.

01:10:54.040 --> 01:10:56.120
Oh, yeah, yeah.

01:10:56.120 --> 01:11:01.000
So we could rewrite this X, Y, Z, dot Y plus 3.

01:11:01.000 --> 01:11:04.520
4, 5, 6.

01:11:04.520 --> 01:11:06.120
These are equivalent.

01:11:06.120 --> 01:11:07.920
They're just different notation.

01:11:07.920 --> 01:11:12.520
We'll stick with the top one so that we can go one parameter at a time.

01:11:12.520 --> 01:11:13.960
Very clearly.

01:11:13.960 --> 01:11:14.960
But those are equivalent.

01:11:14.960 --> 01:11:15.960
Yeah?

01:11:15.960 --> 01:11:32.240
If you do Y, Y, dot Y plus 3, dot Y plus 3, where X is equal to 4, and 5, 6...

01:11:32.240 --> 01:11:33.240
Exactly.

01:11:33.240 --> 01:11:36.600
So we can pass just the 4 into our function.

01:11:36.600 --> 01:11:40.160
And what that means is that X is gonna take on the value 4.

01:11:40.160 --> 01:11:46.600
We're gonna be left with still a function, lambda Y, dot lambda Z, dot Y plus 3, with

01:11:46.600 --> 01:11:49.160
the two parameters still being passed in.

01:11:49.160 --> 01:11:51.880
And now we have some state that we've tacked on.

01:11:51.880 --> 01:11:53.600
X is equal to 4.

01:11:53.600 --> 01:11:57.600
What would we do next?

01:11:57.600 --> 01:12:00.600
Yeah?

01:12:00.600 --> 01:12:08.600
And what are we left with over here?

01:12:08.600 --> 01:12:12.120
Yep.

01:12:12.120 --> 01:12:16.000
So we'll keep lambda Z, dot Y plus 3 of 6.

01:12:16.000 --> 01:12:18.880
And now we have a state X is equal to 4.

01:12:18.880 --> 01:12:22.600
And Y is equal to 5.

01:12:22.600 --> 01:12:25.840
Okay?

01:12:25.840 --> 01:12:37.560
Last piece here.

01:12:37.560 --> 01:12:38.560
I know you guys know it.

01:12:38.560 --> 01:12:39.560
Oh!

01:12:39.560 --> 01:12:40.560
Yeah.

01:12:40.560 --> 01:12:45.320
Yep.

01:12:45.320 --> 01:12:47.320
So Y plus 3 is left.

01:12:47.320 --> 01:12:53.360
We have X equals 4, Y equals 5, and Z equals 6.

01:12:53.360 --> 01:13:01.200
We can do the last little step of 5 plus 3, because we know Y is 5.

01:13:01.200 --> 01:13:06.320
And we're done.

01:13:06.320 --> 01:13:07.600
That's what's on the slides.

01:13:07.600 --> 01:13:09.700
We've just done the same exact thing.

01:13:09.700 --> 01:13:15.440
And I've left off the state, but that's not too important.

01:13:15.440 --> 01:13:17.640
All right.

01:13:17.640 --> 01:13:20.640
One more before we finish.

01:13:20.920 --> 01:13:26.200
Actually, we probably don't have time before we finish.

01:13:26.200 --> 01:13:33.260
So we are going to continue on Wednesday doing more semantics of lambda calc.

01:13:33.260 --> 01:13:37.160
This is exactly what you're gonna be doing on the homework, where I will give you lambda

01:13:37.160 --> 01:13:42.520
calculus, you turn it into JavaScript, or I give you JavaScript, you turn it into lambda

01:13:42.520 --> 01:13:45.520
calculus.

01:13:45.520 --> 01:13:48.600
Yeah?

01:13:48.600 --> 01:14:10.120
So I wonder how can we go from here to this expression?

01:14:10.120 --> 01:14:12.440
So which one was this?

01:14:12.440 --> 01:14:17.080
Where we can go...

01:14:17.080 --> 01:14:18.080
So we have...

01:14:18.080 --> 01:14:21.960
What are we starting with?

01:14:21.960 --> 01:14:30.520
Lambda F dot F of 3 being applied to lambda X dot X plus 1.

01:14:30.520 --> 01:14:31.520
Right?

01:14:31.520 --> 01:14:32.520
Yeah.

01:14:32.520 --> 01:14:33.520
So...

01:14:33.520 --> 01:14:36.720
And we're turning them into our E1, E2, right?

01:14:36.720 --> 01:14:41.680
So we can turn 3 into an expression.

01:14:41.680 --> 01:14:43.840
Because that's just a complex expression.

01:14:43.840 --> 01:14:48.360
So we can say lambda F dot F of E1.

01:14:48.360 --> 01:14:51.800
Lambda X dot X plus 1.

01:14:51.800 --> 01:15:02.920
And then because of this rule here, E1, E2, we can turn these into E2, E1.

01:15:02.920 --> 01:15:05.840
Lambda F dot...

01:15:05.840 --> 01:15:09.040
Well, okay.

01:15:09.040 --> 01:15:12.800
I guess we're using this rule to turn F into E.

01:15:12.800 --> 01:15:19.920
Then we use that rule to turn E2, E1 into E3.

01:15:19.920 --> 01:15:24.920
And now we use the middle rule to turn that into E4.

01:15:24.920 --> 01:15:35.120
Yeah, that's right.

01:15:35.120 --> 01:15:39.940
So lambdas bind until they find an unmatched closed parenthesis.

01:15:39.940 --> 01:15:46.640
So this lambda here, if we take these out, this lambda here goes until it finds an unmatched

01:15:46.640 --> 01:15:47.880
closed parenthesis.

01:15:47.880 --> 01:15:49.920
So it's going...

01:15:49.920 --> 01:15:50.920
Unmatched closed parenthesis.

01:15:50.920 --> 01:15:52.640
Because it binds outside.

01:15:52.640 --> 01:15:56.000
So from here, goes and stops here.

01:15:56.000 --> 01:15:59.920
That means this is the body of the lambda.

01:15:59.920 --> 01:16:14.680
So that, like, this here goes all the way to that point.

01:16:14.680 --> 01:16:44.080
Which means we're allowed to then put in these parentheses if we want.

01:16:44.080 --> 01:16:46.320
Make sure you include the dot there.

01:16:46.320 --> 01:16:47.320
Yes.

01:16:47.320 --> 01:16:48.320
Yeah.

01:16:48.320 --> 01:16:53.520
I think it's...

01:16:53.520 --> 01:16:54.520
It's kind of faint there.

01:16:54.520 --> 01:16:55.560
I might have been...

01:16:55.560 --> 01:16:58.600
I might have forgotten it, but it needs to have a dot.

01:16:58.600 --> 01:16:59.600
Yeah.

01:16:59.600 --> 01:17:00.600
The dot needs to stick around.

01:17:00.600 --> 01:17:01.600
Yeah.

01:17:01.600 --> 01:17:02.600
Yep.

01:17:02.600 --> 01:17:03.600
Yep.

01:17:03.600 --> 01:17:12.720
So, like, I did this how I think it should be based on the load.json file.

01:17:12.720 --> 01:17:18.280
But it keeps only giving me a 2 out of 5, so I'm not sure if it's the cache being...

01:17:18.280 --> 01:17:19.280
Yeah.

01:17:19.280 --> 01:17:20.280
It looks like...

01:17:20.280 --> 01:17:24.080
So you need to create your own cache.

01:17:24.080 --> 01:17:30.480
So you want to check, like, after you do work, save that work to the cache so that the next

01:17:30.480 --> 01:17:36.160
time you then check to say if this work is already done in the cache, return whatever

01:17:36.160 --> 01:17:38.560
is in the cache.

01:17:38.560 --> 01:17:41.360
So you're setting cache, but you aren't checking cache.

01:17:41.360 --> 01:17:46.000
I think is one way to think of it.

01:17:46.000 --> 01:17:50.720
So if I have some...

01:17:50.720 --> 01:17:54.040
I'll just write Python, because that's, you know...

01:17:54.040 --> 01:18:03.000
Then what I can do is I can say if x in cache, return cache at x.

01:18:03.000 --> 01:18:04.000
Right?

01:18:04.000 --> 01:18:09.160
So all you need to do is check if obj is already in cache, and then just pass obj back.

01:18:09.160 --> 01:18:19.400
But then the important thing is also how we store that cache at x is equal to...

01:18:19.400 --> 01:18:20.400
Right.

01:18:20.400 --> 01:18:21.400
But yeah.

01:18:21.400 --> 01:18:25.960
So these are, like, the important before and after steps of the compute.

01:18:25.960 --> 01:18:29.040
But I just check first if obj is already in that.

01:18:29.040 --> 01:18:31.200
My hunch is that should resolve your issues.

01:18:31.200 --> 01:18:35.760
And then my other thing is it says that I have to use load.js file, but it's not...

01:18:35.760 --> 01:18:36.760
It doesn't believe that it exists.

01:18:36.760 --> 01:18:46.320
Like, any time I do load.js file, it says that function doesn't exist.

01:18:46.320 --> 01:18:47.920
Is it on...

01:18:47.920 --> 01:18:50.240
Is it, like, exported or something?

01:18:50.240 --> 01:18:54.360
No, because I'm just doing it like this, and it just says that's not...

01:18:54.360 --> 01:18:55.360
So have you...

01:18:55.360 --> 01:18:56.360
Wait.

01:18:56.360 --> 01:19:00.520
So you have a...

01:19:00.520 --> 01:19:10.520
So I believe with this one, you need to be giving it the information that it needs.

01:19:10.520 --> 01:19:15.320
So let me double-check on that.

01:19:15.320 --> 01:19:16.680
But yeah, my...

01:19:16.680 --> 01:19:17.680
So do we define...

01:19:17.680 --> 01:19:20.840
Load.js file is defined in require.

01:19:20.840 --> 01:19:23.440
And it's not exported for you to use somehow?

01:19:23.440 --> 01:19:27.560
Well, we have require saved, but even if I, like, require is as an object.

01:19:27.560 --> 01:19:28.560
Yeah.

01:19:28.560 --> 01:19:30.880
So if I use require, it doesn't exist.

01:19:30.880 --> 01:19:31.880
But it's exported on require.

01:19:31.880 --> 01:19:32.880
Like...

01:19:32.880 --> 01:19:33.880
You mean this?

01:19:33.880 --> 01:19:34.880
Yeah.

01:19:34.880 --> 01:19:35.880
Yeah.

01:19:35.880 --> 01:19:36.880
So you can't require underscore...

01:19:36.880 --> 01:19:37.880
Oh.

01:19:37.880 --> 01:19:38.880
Is load.js exported?

01:19:38.880 --> 01:19:39.880
No, it is not.

01:19:39.880 --> 01:19:40.880
I don't think so.

01:19:40.880 --> 01:19:41.880
Yeah.

01:19:41.880 --> 01:19:44.400
So I think...

01:19:44.400 --> 01:19:46.080
But it's on the loader.

01:19:46.080 --> 01:19:56.520
So the idea is we have some before where we have the normal, like, load function that

01:19:56.520 --> 01:19:57.520
we're running.

01:19:57.520 --> 01:19:58.720
Or loader function.

01:19:58.720 --> 01:19:59.720
And then the goal is that...

