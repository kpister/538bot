start	end	text
0	5000	This is a course on the principles and paradigms of programming languages.
30000	32000	This is a course on the principles and paradigms of programming languages.
60000	88880	This is a course on the principles and paradigms of programming languages.
89880	91160	Is there a fourth option?
91160	92120	Is that what you said?
92120	92840	Yeah, really hard.
92840	93340	Really hard.
100160	102160	This is anonymous, just so you guys know.
102160	104480	I'm not recording what you say.
108160	110160	Can you guys see two questions, by the way?
110160	112000	Or just one?
112000	112760	You see two?
112760	113260	Great.
113260	113760	Thank you.
118880	119840	I'm taking an exam.
119840	121840	I'm trying to figure out, like, what is it?
121840	123820	Are we going to do, like, a couple of them?
123820	124320	Yeah.
124320	125320	I don't know that.
125320	127800	Like, I feel like we're going to do a couple of those.
127800	129280	Yeah, professor, really hard.
129280	130760	They do this every day, right?
130760	132240	And then they're like, I don't know.
132240	133720	So I'm like, you're really weird.
133720	134720	I'm like, I don't know.
134720	135720	I'm like, I don't know.
135720	136720	I'm like, I don't know.
136720	137720	I'm like, I don't know.
137720	140720	I think my answer to that is I'm like, I'm not great.
140720	141720	I'm like, I don't know.
141720	142720	I'm like, I don't know.
142720	143720	I'm like, I don't know.
143720	144720	I'm like, I don't know.
144720	145720	Fair enough.
145720	146720	Yeah.
146720	159720	Can we get participation points from participating in class, or is that only in class?
159720	160720	Yes.
160720	166720	In class matters, but a lot of it is, like, if I can know your name.
166720	173000	I have a photo of everyone, and I match it with your name, and then based on how well
173000	175600	I remember you participating in class.
175600	177520	So it's a little bit of a loose system.
177520	181480	But it kind of works.
181480	182480	Bring a name tag.
182480	183480	It might work.
183480	184480	It might help.
184480	186160	All right, guys.
186160	190600	We have 27 responses here, so I think we are gonna close it out, because it looks like
190600	192360	there are roughly 30 people.
192360	195160	Those of you in the back, you should scoot forward.
195160	196160	Why not?
196160	197160	You know?
197160	199020	Come on up a little bit.
199020	204040	We will be looking at some code on the screen, and the code is a little bit small, so the
204040	207800	closer up you are, the better.
207800	210800	Can I show you the responses?
210800	212800	Responses.
212800	214800	Okay.
214800	217840	That sounds good.
217840	223180	So harder than it was medium, and definitely not easy.
223180	226680	And then in terms of fairness-ish.
226680	231920	All right.
231920	234200	So compared to last semester, maybe a bit harder.
234200	235200	Good to know.
235200	237700	I will take that into account as we go forward.
237700	241720	Thank you for your feedback.
241720	245560	Don't forget, we do drop the lowest midterm, so if that's this one, great.
245560	247560	If it's not this one, also great.
247560	249760	Up to you.
249760	252280	All right.
252280	257200	Welcome to a fun lecture in CS538.
257200	261520	I try and add these as much as I can, because I like to talk about things that aren't just
261520	268520	the stuff that's on the ACM, like, requirements for what principles and paradigms of programming
268520	270280	languages is.
270280	273200	Before we get into the fun stuff, some notes.
273200	275740	The PA and the homework are not going to be released.
275740	280240	If you already have a copy somehow, because you stole them while they were halfway released
280240	282040	or something, ignore them.
282040	283480	They are not released.
283480	286080	You don't have to do them until after spring break.
286080	289480	Have a fun spring break.
289480	290920	Midterms will be graded soon-ish.
291320	292320	I have them all scanned.
292320	295840	The TA and I will be grading them.
295840	300680	We will get those back to you hopefully within a week, and then once that is done, I will
300680	304880	be able to update Canvas with your current grade.
304880	314120	This will be unscaled, so it won't be â€“ if there is a curve, there's no curve on this
314120	319000	grade, but it will have your 10% bonus for submitting early.
319000	325760	It will have the individual weighting of each assignment versus the other assignments.
325760	330040	This should be a pretty accurate reflection of what your grade will be at this point in
330040	331400	time.
331400	334800	I'm hoping that that will be done before spring break ends.
334800	341640	It takes a while, so please be patient.
341640	348360	I have a coding project that is school-related, so it's not work, it's not industry stuff.
348360	349880	It's a coding project.
349880	356920	If somebody is a very proficient Python coder and interested in hacking on something, come
356920	362600	chat with me either after class or in office hours or send me an email.
362600	363600	It might be hard.
363600	364600	I don't know.
364600	365600	We'll figure it out.
365600	370320	There is a course eval that is the midterm course eval.
370320	373020	You got it from the school.
373020	374520	They ask you to fill it out.
374520	375520	Please do.
375960	381920	I appreciate it, because I take that information into all of the rest of my teaching.
381920	390000	Let me know if I'm doing anything poorly or well, and I will try and fix or stay the course.
390000	391000	Those are my notes.
391000	392380	There were a lot of them.
392380	399600	Any notes from you guys?
399600	402120	It's a fun lecture, so we can talk about anything.
402120	403120	Anything on your mind?
403120	404120	Yeah?
404120	408920	These lecture slides are called static analysis.
408920	409920	They are on Canvas.
409920	410920	Yep.
410920	411920	Yep.
411920	424080	I will post the solutions to the midterm.
424080	427760	I don't typically go over them, but we can do that in office hours if you want to stop
427760	432360	by.
432360	434640	Anything else?
434640	437960	All right.
437960	441200	Today's lecture is loosely based...
441200	442920	It was going to be something totally different.
442920	448480	And then I read this article this morning called fixing the next 10,000 aliasing bugs.
448480	451240	And just from the title, you know that's gonna be super exciting.
451240	452240	I was like, yes!
452240	455920	This is the thing I want to spend an hour and a half chatting about.
455920	457880	No, not actually.
457880	463600	It's a really boring looking title, and only a real PL nerd would get excited about that.
463600	468120	But that's because they missed out on the real title.
468120	474760	Which is using type inference to make $150.
474760	477200	Minor correction.
477200	481320	To steal $150 million.
481320	487920	So the algorithm that we have been covering, Hindley-Milner type inference, loosely can
487920	495800	be used to describe an attack that took place two years ago and resulted in somebody literally
495800	499120	stealing $150 million.
499120	503000	All of the material, or almost all of the material, comes from this blog post, the one
503000	505600	that I showed at the start there.
505600	507960	All the animations are my own.
507960	509800	All right.
509800	512880	So let's take a look at Java.
512880	517160	I'm certainly not proficient in Java, but I have a little piece of Java for you.
517160	523280	If you have your computer with you, feel free to go to my GitHub, to the CS538 snippets
523280	527520	repo and take a look at the code that is there.
527520	532120	Otherwise, I'm gonna put the code up on the screen so we can all look at it as a class.
532120	537800	But if you want it so you can play around with it, do so.
538800	541800	All right.
559800	560800	All right.
560800	569440	So in that folder, you should have a bug.java, if you can find it.
569440	571800	And when we look at this...
571800	574800	All right.
574800	579800	I can go one bigger, two bigger, three bigger.
579800	580800	Yeah.
580800	581800	Is that readable?
581800	585840	If it's not readable, there are plenty of seats up front.
585840	587800	So please do come up front.
587800	589500	All right.
589500	591500	We have Java code.
591500	597300	I have not written Java code since probably my sophomore year of college.
597300	601500	So even getting this to compile was like, what is going on?
601500	602820	But I did.
602820	605900	So that's good.
605900	607800	We have a class called MyList.
607800	613180	This might come out from you having to write a data structure in one of your intro CS classes.
613180	619100	You're told, write a data structure for a list in Java.
619100	624620	This list should be able to add items of arbitrary length.
624620	631300	So even though it started out as an array of ten items, once I add the eleventh item,
631300	636180	it should be able to restructure and become an array of length 11.
636180	637220	Or 20.
637220	638760	Or 100.
638760	642220	So it should be a dynamically lengthed list.
642220	646500	But we have to stick within Java, so we're going to use an array to do that.
646500	652100	And every time we go past our bounds, we will reallocate a new array, copy over all
652100	656180	the old elements, and be good to go.
656180	657320	Great.
657320	659780	So we have some code.
659780	665540	My challenge to you is identify the bug.
665540	669000	And I'll give you five to ten minutes to do so.
669000	676020	If you have code on your computer, feel free to download it, compile it, run it, and figure
676020	677420	out what's going on.
677420	680020	If you don't have code, talk to somebody next to you.
680020	682920	Or stare at this for a little while.
682920	686740	There is one piece at the very bottom that's not being shown.
686740	694720	All that is is the main function, where I create a list S, I create a list T, add elements,
694720	700020	and then, like, concatenate the two lists together.
700020	705700	All right.
705900	707900	So...
707900	708900	Find the bug.
708900	713500	I'll wander around and chat with you guys individually to see what you come up with.
713500	715780	But give it five or ten minutes of debugging.
735700	736700	And I'll see you guys later.
736700	737700	Bye.
737700	737700	
765700	766700	Bye.
766700	766700	
795700	796700	Bye.
796700	796700	
826700	827700	Bye.
827700	828700	Bye.
828700	828700	
855700	856700	Bye.
856700	856700	
886700	887700	Bye.
887700	888700	Bye.
888700	888700	
915700	916700	Bye.
916700	916700	
946700	947700	Bye.
947700	948700	Bye.
948700	948700	
976700	977700	Bye.
977700	978700	Bye.
978700	978700	
1005700	1006700	Bye.
1006700	1007700	Bye.
1007700	1007700	
1035700	1036700	Bye.
1036700	1037700	Bye.
1037700	1037700	
1066700	1067700	Bye.
1067700	1068700	Bye.
1068700	1068700	
1096700	1097700	Bye.
1097700	1098700	Bye.
1098700	1098700	
1125700	1149820	Okay.
1149820	1152540	So what did we come up with?
1152540	1153540	Who's got some ideas?
1153540	1157260	I heard a lot of different ideas floating around.
1157260	1159340	Did anybody get an actual error?
1159340	1164300	Was anybody able to compile this and run it with some sort of main?
1164300	1168900	Like changing this at all and getting an actual error?
1168900	1170300	Okay.
1170300	1173060	Fair enough.
1173060	1181180	Did anybody come up with something that might be going wrong?
1181180	1190660	All right.
1190660	1193140	I'd like to poll the class.
1193140	1199980	You have four functions, if you include the constructor as a function.
1199980	1202380	Where is the bug?
1202380	1204820	Could be based on your gut or just...
1204820	1205820	I don't know.
1205820	1206820	Something else.
1206820	1207820	But I'm curious.
1207820	1208820	Where do you think the bug is?
1208820	1212020	Choose one of the four functions.
1212020	1213100	The constructor.
1213100	1215980	My list.
1215980	1218980	Ensure capacity.
1218980	1220700	Add.
1220700	1221700	Add all.
1221700	1222700	Okay.
1222700	1225340	We got about a 50-50 split.
1225340	1228380	Add all and ensure capacity.
1228380	1229380	So which one is it?
1229580	1232860	First of all, let's double check that I haven't, like,
1232860	1237940	just cheated the whole time, and we can actually compile this thing.
1237940	1244820	Compiles, it gives us a warning for our types, but that's fine.
1244820	1247740	And then if we actually run it, we do actually run it.
1247740	1251300	So there's no bug.
1251300	1256300	That's gonna be annoying.
1256300	1258780	In this main.
1258780	1263300	In this version of main, where we create a list, we create a second list,
1263300	1266020	we add an element to the first list, or to the second list,
1266020	1269540	add an element to the second list, and then add them together.
1269540	1270620	This part's fine.
1270620	1271620	No bugs.
1271620	1272620	Compiles.
1272620	1273620	Runs.
1273620	1274620	Without issue.
1274620	1286700	I'm gonna make a one-character change.
1286700	1291180	That's all that we're gonna change.
1291180	1295980	This is what it was.
1295980	1307220	This is what I'm changing it to.
1307220	1309460	What happens?
1309460	1314220	What we are saying now is that we're taking a list S
1314220	1322740	and add all the elements from S to that list.
1322740	1323740	So what's gonna happen?
1323740	1324740	Yeah.
1324740	1334980	There's gonna be a problem with ensure capacity.
1334980	1337260	Let's run through it and see if there is.
1337260	1339540	So we hit add all.
1339540	1342860	Our parameter C is the list S.
1343380	1346780	We are in the scope of S itself.
1346780	1353100	So when we call ensure capacity, we're using the S version of ensure capacity,
1353100	1358460	with the length of S and the length of S.
1358460	1362060	So 2 times S.
1362060	1366980	When we call ensure capacity with 2 times the length of S,
1366980	1371460	which in this case is length 1, so it's a value of 2,
1371460	1376780	we would check to see is min capacity 2 greater than array.length?
1376780	1377780	Yes.
1377780	1381060	Array.length is 1.
1381060	1386060	So then we're going to set the new capacity equal to 2.
1386060	1389340	The max of 2 and 2.
1389340	1397020	Create a new list of length 2 and copy the old list into the new list.
1397020	1399700	Is there a bug there?
1399700	1406340	Did anything break?
1406340	1409420	I don't think anything did break.
1409420	1422340	And yet, so if we recompile and we rerun, we crash.
1422340	1426220	So ensure capacity did not have any issue,
1426220	1429780	but making this change did break something.
1429780	1432540	That leaves the second group.
1432540	1438340	The group that had the intuition that the issue is in add all.
1438340	1446020	Something has gone wrong in add all after our ensure capacity check.
1446020	1447020	What is it?
1447020	1448020	Yeah.
1448020	1465980	Right.
1465980	1474660	So in Java, we are referencing this S, the length variable on that S,
1474660	1477780	which we are incrementing inside of this for loop.
1478540	1488380	However, our for loop check is saying until we are less than the length of C.length.
1488380	1490900	While we are less than C.length.
1490900	1495820	C is S. And we are incrementing the value of S's length.
1495820	1499540	So we will continue going through this for loop over and over and over
1499540	1503580	until we actually hit the bounds of the entire loop,
1503580	1514460	which is when we get our final array index out of bounds exception.
1514460	1519660	So I've got some slides to make this a bit more step by step.
1519660	1527340	Let's go to those.
1527340	1531100	The thing that we have, actually, let's go back.
1531100	1532700	Let's do this backwards.
1532700	1537220	We start with add all.
1537220	1543180	And our first step of add all is saying let's ensure the capacity of the current list
1543180	1547800	is greater than the old list with the new list combined.
1547800	1551180	So make sure that we have enough space for whatever we're doing.
1551180	1555140	And this is the, like, we're calling this the correct way.
1555140	1560460	On the first iteration, I is zero, length of our list is two,
1560460	1566020	length of C.length, or C.length is one.
1566020	1570900	We execute the body of the loop, incrementing our length.
1570900	1576420	And then setting C.length, or C.length is still one.
1576420	1581940	Loop back through, am I on the right one?
1581940	1582940	I am on the right one.
1582940	1584260	We go back to the top.
1584260	1587380	We check is I less than C.length.
1587380	1588380	It's no longer.
1588380	1589380	So we're done.
1589380	1595700	This is if we ran it with the correct inputs, like not passing S. We don't run into any
1595700	1601660	issue because C.length has remained constant.
1601660	1609100	On the other hand, if we pass in S as our parameter, first we do that same ensure capacity
1609100	1610660	check.
1610660	1617940	Then we say I is equal to zero, length is equal to two, C.length is equal to two.
1617940	1625220	When we get to our length++, we increment not only our length, but also C.length.
1625220	1629860	Because C.length is the same as our length.
1629860	1635140	Which means that C.length increments with our own length.
1635140	1640380	We go back up to the next time, increment I. I is less than C.length.
1640380	1649660	And this will continue forever and ever and ever until we actually index into the array
1649660	1656540	at an invalid location.
1656540	1661340	So this is the bug that we have found.
1661340	1670300	Questions on the bug?
1670300	1672020	It's a bit involved.
1672020	1679740	I recognize that.
1679740	1685220	So if we go back to what went wrong, we had this implicit invariant.
1685220	1692260	And it was that the length of the input list does not change between the ensure capacity
1692260	1695380	call and the for loop.
1695380	1707060	Outside of our add list, or add all function, our input list length does not change.
1707060	1713420	And you might look at that and say, that's safe, so long as we aren't multithreading.
1713420	1718420	It makes sense that if we're multithreading, maybe somebody updated the list in between.
1718420	1721380	But if we aren't multithreading, maybe we're safe.
1721380	1723960	What we found is that no, that's not true.
1723960	1730520	If we pass in the same object itself, when we increment length, we're incrementing the
1730520	1732240	input length as well.
1732240	1742360	Which means we've broken our invariant.
1742360	1743360	Sound good?
1743360	1744360	Questions?
1744360	1749740	All right.
1749740	1755820	So how does this turn into $150 million?
1755820	1760140	How many of you are familiar with DAOs?
1760140	1761140	Some number of you.
1761140	1763340	Follow, like, news and whatnot.
1763340	1768260	So before we talk about what a DAO is, we should take a second to say, what is a smart
1768260	1769260	contract?
1769260	1771700	How many of you know what smart contracts are?
1771700	1772700	Very few.
1772700	1773700	How many of you have written a smart contract?
1773700	1774700	All right.
1774700	1777060	One or two.
1777060	1787140	So a smart contract is a small piece of public code, very similar to an API endpoint.
1787140	1794220	However, different than an API endpoint is that it's run on a distributed cloud.
1794220	1800020	Typically associated with what's called a blockchain.
1800020	1806260	And the way that you purchase credits so that you can run code on this distributed
1806260	1812020	cloud is that you pay with a digital currency.
1812020	1816020	Such as Doge.
1816020	1821060	What this code is, though, is effectively anything.
1821060	1828340	We can write whatever web app we want and run it on a distributed cloud.
1828340	1829660	For example, ETH.
1829660	1833600	Or I guess Doge doesn't actually have smart contracts, but that's beside the point.
1833600	1837900	So there are languages designed to write smart contracts.
1837900	1841540	One of them, for example, is called Solidity.
1841540	1843780	Solidity looks something like this.
1843780	1847380	We create a contract and we give it a name.
1847380	1850140	And it has some stored data.
1850140	1853260	And then we define functions on that contract.
1853260	1856500	Set and get, for example.
1856500	1862980	Someone can then call these functions and provided they pay the gas to make them happen,
1862980	1867380	they will execute that code.
1867380	1873420	This is a really convenient model compared to the idea of having to spin up your own
1873420	1879020	EC2 box, where you're running all of your functions and having it all handled there.
1879020	1885060	You just deploy your code and pay other people to run it for you when you want it to be run.
1885060	1886060	Very cool.
1886060	1893820	In theory, crypto and Web3 have kind of spiraled into insanity at this point.
1893820	1901660	But fundamentally, cool idea.
1901660	1903540	You guys like seeing real code?
1903540	1914220	So this is a smart contract that I wrote that creates, like, NFTs of those audio snippets
1914380	1916620	that I showed you from before.
1916620	1922220	So not only do you put one line of HTML and I turn your web page into a podcast, I also
1922220	1927660	mint an NFT that you can then put on OpenSea.
1927660	1929140	This feature never deployed.
1929140	1931460	It was just more of a meme.
1931460	1935740	And then to show investors and be like, hey, yeah, we're Web3.
1935740	1939900	Anyway, back to the DAO.
1939900	1944340	So what is a DAO?
1944340	1953220	The original DAO was this relatively reasonable idea that we could build a smart contract
1953220	1959100	and have it be used as a distributed investment fund.
1959100	1962780	Remove the idea of a hedge fund.
1962780	1964660	Remove big banks.
1964660	1965660	They suck.
1965660	1968220	They only help the very wealthy.
1968220	1972540	Let's have a distributed hedge fund, effectively.
1972540	1974060	The functionality is very simple.
1974060	1976060	You put money in.
1976060	1978460	The money grows over time.
1978460	1981460	You vote on what the fund should invest in.
1981460	1982900	And you vote...
1982900	1988940	Your weight of your vote is corresponding to your percent ownership of the DAO.
1988940	1992780	And then obviously you get to pull money out.
1992780	1998540	Once it has grown and accumulated value.
1998540	2000860	Power to the people.
2000860	2001860	Distribute finances.
2001860	2003860	It's great.
2003860	2005860	Oops.
2005860	2009060	So...
2009060	2011700	It's a great idea.
2011700	2018900	But now we're starting to put real money in code where what if there's a bug in your code
2018900	2023620	and you can never pull out your money again?
2023620	2030300	This is an abbreviated version of the real DAO smart contract where you would be able
2030300	2032340	to withdraw money.
2032340	2036700	So when you had put in your money and it had grown and you decided it's time to pull this
2036700	2043140	money out so I can use it again, you would call this function and you would say...
2043140	2044700	Here's my ID.
2044700	2048420	This is how much money I want to withdraw.
2048420	2051220	And simplified, it would boil down...
2051220	2053940	The function boils down to roughly this.
2053940	2055260	Step one.
2055260	2061260	Calculate how many funds, how much of the money that you have in the DAO do you want
2061260	2062260	to remove?
2062260	2065260	Do you want to remove 5 ETH?
2065260	2067300	Do you want to remove 10 ETH?
2067300	2068500	0.1 ETH?
2068500	2072700	So calculate how much money you want to move.
2072700	2074340	Step two.
2074340	2076420	Prepare to move that money.
2076420	2080700	And check to see if there's an error when you remove that money.
2080700	2086060	So if they're trying to move more money than they have, for example, check.
2086060	2088940	If they are, don't do it.
2088940	2094460	Don't let somebody withdraw 10 ETH when they only have 5 ETH in their bank.
2094460	2101140	So that's what this if error or if no error, then withdraw the actual money.
2101140	2102300	They're asking for their money.
2102300	2103620	Give them the money.
2103660	2106540	Finally, zero the user's balance.
2110300	2110800	All right.
2110800	2111800	What goes wrong?
2122660	2123660	Yeah?
2123660	2129780	What if they're not withdrawing all their money?
2129780	2130780	Yep.
2130780	2131780	What do you mean?
2131780	2135260	At the bottom, that would be zero, right?
2135260	2136100	Oh, sure.
2136100	2138020	Yeah.
2138020	2141260	That's me simplifying code.
2141260	2144100	We set it to be whatever is remaining.
2144100	2147100	Or we could pretend this is full withdrawal.
2147100	2147600	Yeah.
2147600	2148100	Either way.
2158020	2158520	Yeah.
2158600	2162480	This createToken.value is basically our check to say,
2162480	2166440	will this thing, when we withdraw this amount of money,
2166440	2169080	will it cause an error?
2169080	2172480	What it's really doing is it's preparing a separate coin
2172480	2176080	for that user under the hood and all of this
2176080	2178440	that we will transfer to that user.
2178440	2180680	So there's a bit more complexity hidden behind there.
2180680	2184020	But we can think of it as an error check.
2184020	2187600	We're checking to validate, is this thing OK to do?
2188520	2189020	Yeah?
2193980	2194480	Yeah?
2194480	2198440	What's a HashMap?
2198440	2199320	It's a dictionary.
2199320	2200940	HashMap, whatever you want to call it.
2204120	2207480	Consider that we're on a distributed cloud.
2207480	2211760	It's one of the actual main purposes of smart contracts.
2211760	2213080	Yeah?
2213080	2216320	Does that do something with atomic operations
2216320	2217760	in parallel?
2217760	2218280	Sure.
2219040	2222800	So what does that mean?
2222800	2224400	What part of this is not atomic?
2224400	2227100	What part of it would you want to be atomic?
2227100	2227600	Yeah?
2248480	2250120	Or something?
2250120	2255480	That is exactly what these guys exploited.
2255480	2259040	If we have multiple of these processes running
2259040	2264160	at the same time, and they check that they're
2264160	2268160	valid all at the same time, before we
2268160	2272240	have set our actual value to zero,
2272240	2276480	then they will all say, you have 5 ETH in your bank.
2276480	2281080	Then when we withdraw 5 ETH from five different processes
2281080	2284440	running the same thing, you get 25 ETH.
2284440	2287920	While at the end, you're only ever set down to zero.
2287920	2293040	You can't have negative 20 ETH in your account.
2293040	2299740	So because these are not atomic in this check withdraw set,
2299740	2302640	we're running into this concurrency problem
2302640	2305880	where the attackers were able to literally withdraw
2305880	2307040	$150 million.
2312040	2313600	So what's going wrong?
2313600	2316920	Once again, we have this implied invariant
2316920	2320880	that at all times, the balance for a user
2320880	2326140	matches the actual money that they are owed.
2326140	2330760	And we're trying to approximate that by saying, if no error,
2330760	2333200	throw, and then withdraw.
2333200	2337480	But because that's not atomic, we don't actually
2337480	2341160	have that invariant for the two lines of code
2341160	2342120	that it really matters.
2346200	2349360	So just like in the MyList example,
2349360	2353900	we are temporarily invalidating our invariant
2353900	2355960	while our function is running.
2355960	2359520	Once we've finished running, our invariant's back and restored,
2359520	2362760	and we're fine, unless somebody was able to exploit it
2362760	2363720	in the meantime.
2372480	2378280	So atomic to the rescue?
2383280	2386620	Can we just wrap all of our code in mutexes
2386620	2393100	and basically check, lock this piece, unlock this piece?
2393100	2394820	The idea here would be to take learnings
2394820	2396700	from databases or operating systems
2396700	2399660	where we do this all the time.
2399660	2403740	And maybe atomic actions will fix this.
2403740	2406460	But not quite.
2406460	2411460	So Uber published a lengthy blog post
2411460	2413420	roughly talking about all of this.
2413420	2415460	Uber does a ton of their development
2415460	2420280	in the language Golang, which is very similar to C,
2420280	2424900	but has a lot better guarantees, generally.
2424900	2427780	And what we're doing here is we want to take,
2427780	2430460	we can think of it very similar.
2430460	2432180	The square brackets are lists.
2432180	2434980	Effectively, they're called slices in Go.
2434980	2435580	No big deal.
2435580	2437220	They're basically just lists.
2437220	2439160	So we have a list of strings.
2439160	2441900	And then we have a safe append function.
2441900	2446100	And that function is going to lock our,
2446100	2451860	set our locks so that we can update the my results slice,
2451860	2454540	which is technically, or it's technically a slice,
2454540	2455980	but it looks like a list.
2455980	2462700	So we're only going to write to our list with the lock.
2462700	2465660	And then we can set up multiple threads.
2465660	2467540	One of the amazing things about Go
2467540	2470800	is that you can just say Go function,
2470800	2472560	and then it will spin up a thread
2472560	2476280	to run that function for you asynchronously.
2476280	2482320	So we can set 10 threads going all at once to take our string
2482320	2489680	and split it up and append it to our list of strings.
2489680	2492840	But what's going to go wrong is that even though we only
2492840	2496640	can write one at a time to safe atomic,
2496640	2500120	we can read concurrently.
2500120	2504040	And so we might be halfway through a write
2504040	2506000	and then start reading.
2506000	2508800	And because we've only written half of the content,
2508800	2511800	we might not have copied the correct length,
2511800	2515040	or we might not have grabbed the entire list.
2515040	2518120	Any number of things could go wrong.
2518120	2521920	So when we do the read right here,
2521920	2527840	and we request my results, this is undetermined.
2527840	2532160	It could be any value within reason.
2535480	2538360	So maybe what we could do is we could wrap literally everything
2538360	2542000	in mutexes, but now we're in single-threaded land,
2542000	2545760	and that kind of sucks for its own reasons.
2545760	2547560	Nobody wants to write single-threaded code.
2547560	2552120	It's super slow, especially with the death of Moore's law.
2552120	2557200	So the shared issue here, we have
2557200	2563600	this idea of invariance being violated repeatedly
2563600	2567480	to multiple aliased references.
2567480	2570960	Aliasing means we have multiple references to the same memory.
2570960	2573960	Here, we have multiple references of my results
2573960	2575520	up here and in the append.
2575520	2582440	In this place, we have multiple references
2582440	2589520	to the actual balances feature that stores our information.
2589520	2594560	And the last one, we have multiple references
2594560	2600040	to our length, or to our array, which has the length variable.
2600040	2604800	So we have aliases of the same important memory.
2604800	2605800	Question?
2605800	2607800	Yeah, this might not be relevant,
2607800	2612780	but regarding the mutex and any distributed system,
2612780	2615280	how does a mutex work with something
2615280	2619720	that's like a blockchain distributed system?
2619720	2621280	Oh, it certainly wouldn't.
2621280	2623760	So you can't do, like, mutexes as far as possible
2623760	2624960	to contribute it?
2624960	2632920	So mutex needs to operate at the underlying level for it to work.
2632920	2637240	You need to have some sort of supervisor saying,
2637240	2640160	lock this thing, and then unlock this thing.
2640160	2643000	And if you don't have something like that, it's not going to work.
2643000	2645880	If you could build that into your chain,
2645880	2647920	you could make something like it work.
2647920	2650480	But by default in ETH, you'd probably
2650480	2651840	have some trouble with that.
2659720	2661840	All right, lots of things.
2661840	2668880	All right, so our invariants have been violated by multiple.
2668880	2670640	Did I say inviolated?
2670640	2675440	Invariants are violated by multiple aliased references.
2675440	2679480	An alias is when we have multiple references to the same memory.
2685000	2687560	Let's try and fix that.
2687560	2690840	So to the original title of the blog post,
2690840	2696160	solving the next or fixing the next 10,000 aliasing bugs,
2696160	2697040	or whatever it was.
2699680	2702560	The author makes the point that this is not new.
2702560	2705880	Tony Hoare gave a presentation about 10 years ago
2705880	2709080	called Null References, the Billion Dollar Mistake,
2709080	2711720	where he talks about, in ALGOL, the language
2711720	2713880	that he developed in the 60s, he included
2713880	2716420	the idea of a null reference.
2716420	2718680	And every other language since then
2718680	2721400	has said, null is a good idea.
2721400	2723680	Let's also have null.
2723680	2728040	But how many bugs come up because of null?
2728040	2730360	Maybe a billion dollars worth of bugs.
2730360	2731000	Maybe more.
2731000	2733960	Maybe it's even crazier.
2733960	2736600	So over the last 20 years, people
2736600	2740560	have started saying, how can we fix null pointers?
2740560	2745920	The issue fundamentally is that every variable can be null.
2745920	2748280	Developers then have what options?
2748280	2751480	What can a developer do to handle null?
2751480	2753440	You're writing C code.
2753440	2756360	What do you do when you're worried
2756360	2757760	about this sort of stuff?
2757760	2760400	Yeah.
2760400	2761860	Put if statements everywhere.
2761860	2763200	That is the first one.
2763200	2763840	Excellent.
2763840	2765000	Good order.
2765000	2769600	We can always do a null check and say, if the thing is null,
2769600	2770120	do this.
2770120	2772600	Otherwise, do whatever else.
2772600	2775360	What else can we do?
2775360	2777440	Yeah.
2777440	2781000	We can use union types in C.
2781000	2782960	OK, I haven't used union types in C.
2782960	2786040	In other languages, definitely.
2786040	2788160	And that's what I will talk about on the next slide.
2791080	2791880	What else can we do?
2791880	2792380	Yeah.
2792380	2794440	Exception handling.
2794440	2797680	C doesn't have exceptions.
2797680	2799200	Right?
2799200	2799700	Am I wrong?
2799700	2800960	New versions of C might.
2800960	2802880	I don't think C has exceptions.
2802880	2805680	But in other languages, we have exception handling.
2805680	2807360	We can capture null pointers.
2807360	2807860	Sure.
2813160	2819760	We can also just be very careful and try not to mess up.
2819760	2823080	And I would say the last option is segfile.
2827440	2831340	But these are antiquated ideas.
2831340	2833840	You should not have to do any one of these.
2833840	2835600	You shouldn't have to do null checks.
2835600	2837320	You shouldn't have to be very careful.
2837320	2839480	And you shouldn't be segfaulting.
2839480	2841280	And instead, what we should do is
2841280	2843360	we should fix it at the language level
2843360	2847640	with things like union types, which I guess are in C,
2847640	2850000	but are only more recently in C for sure.
2853040	2854160	Either way.
2854160	2856880	But a ton of other languages have this idea
2856880	2862040	that things, you can tag them as either being never null
2862040	2865200	or possibly null.
2865200	2866880	So you have something like TypeScript,
2866880	2868640	where you put this little question mark
2868640	2870360	after your variable name.
2870360	2873400	And what you're saying there is, this thing is a number, maybe.
2873400	2875040	It also might be null.
2875040	2878720	And whenever you use it, you should check to see is it null.
2878720	2880640	But if it doesn't have a question mark,
2880640	2885680	the name property is never null.
2885680	2887680	And you never have to worry that that thing
2887680	2891180	might be uninitialized.
2891180	2892760	So a bunch of languages are doing this.
2892760	2893560	TypeScript does it.
2893560	2896000	You can do front-end or back-end dev with that.
2896000	2896920	Rust does it.
2896920	2898440	You can do systems dev with that.
2898440	2899160	Swift does it.
2899160	2901120	You can write iOS apps with that.
2901120	2902240	Kotlin does it.
2902240	2903760	I don't know if anybody uses Kotlin.
2906360	2908280	So that's null pointers that have been
2908280	2910200	addressed at the compiler level.
2910200	2913100	These languages now solve this problem for you.
2913100	2917140	When you accidentally use a possibly null value
2917140	2920080	and don't check if it's null, the compiler
2920080	2922160	will tell you that's an error.
2922160	2922680	Don't do that.
2926160	2928160	Can we treat aliasing the same way?
2928160	2928660	Oh, yeah.
2928660	2929160	Yeah.
2929160	2936040	So in SQL, I think they have something like some.
2936040	2939080	Oh, SQL's a nightmare with null.
2939080	2941480	Yeah, but no, it's interesting.
2941480	2948240	SQL has null, but it also has empty and other very weird
2948240	2950400	states that it can be in.
2950400	2952360	But it also depends on the variant in SQL.
2952360	2956840	So SQL has some null handling, but then it also
2956840	2961120	has some not null handling that gets into issues.
2965800	2969240	Other questions or ideas about null pointers?
2976000	2976500	Yeah.
2981400	2984880	Why are null pointers bad?
2984880	2989360	Why are null pointers good and bad?
2989360	2992840	Sometimes, they're useful, but not always.
2992840	2994320	They have some use, right?
2994320	2995800	Sometimes, they're not.
2995800	2998280	Sometimes, they're not always.
2998280	3000240	Sometimes, they're not always.
3000240	3000920	Yeah.
3000920	3003680	So why are null pointers bad?
3003680	3007480	And I think that's, to some extent,
3007480	3010600	a philosophical question.
3010600	3013000	Should you ever use a null pointer?
3013000	3020040	But it's also very much just an engineering problem.
3020040	3025640	When you are trying to learn C, you run into a lot of segfaults.
3025640	3027720	When you are trying to learn JavaScript,
3027720	3031480	you run into a lot of undefined is not a function.
3031480	3035440	You guys have probably hit that one a lot in this class.
3035440	3039200	When you try and learn a language like Python, though,
3039200	3043920	I guess you also still get none can't be used like that.
3043920	3048440	But you can't ever call a non-function.
3048440	3051800	You can't ever reference something and use something
3051800	3054280	if it's a null pointer.
3054280	3057760	You're not getting segfaults.
3057760	3060760	Or if you're in TypeScript, even better,
3060760	3064320	you're being forced to handle null.
3064320	3066640	So it's not that you don't have null.
3066640	3070000	It's that you only have to think about it on the things
3070000	3071400	where it's relevant.
3071400	3073960	I can still initialize my thing to be empty.
3073960	3076120	But in doing so, I have to specify
3076120	3079880	that it can be empty, which means everybody else knows
3079880	3081560	that's potentially empty.
3081560	3083880	But not everything is empty.
3083880	3086080	Name is always going to be a string.
3086080	3087840	And I never have to put an if statement
3087840	3090960	to check, is name undefined?
3095320	3101800	Which leads to cleaner code, and it leads to fewer mistakes.
3101800	3103800	Fewer bugs.
3108240	3110200	Cool.
3110200	3112080	So what can we do about aliasing?
3112080	3117000	Because we found this issue that aliasing presents bugs
3117000	3118400	in our code as well.
3118400	3119800	It's not just null pointers.
3119800	3122480	It's aliasing, too.
3123320	3126440	Well, inherently, in most languages,
3126440	3129960	every reference is implicitly aliasable.
3129960	3138280	We can always say x equals y and create an alias of y with x
3138280	3142280	so that x and y both point to the same thing.
3142280	3147280	No language outside of the one that we're about to discuss
3147280	3149280	prevents you from being able to do that.
3152600	3155760	What this means is that what developers
3155760	3159120	can do to prevent aliasing is what?
3159120	3162840	How can we stop aliasing bugs, such as the ones
3162840	3163680	that we've just seen?
3164680	3165160	Yeah?
3177080	3179560	If we only have an immutable copy of something,
3179560	3184640	wouldn't that, like, start to do, like, a bad thing?
3184640	3188280	If we only have an immutable copy,
3188280	3191560	what would stop me from saying x equals y?
3192240	3196520	It's best practice to say x equals set y.
3196520	3202880	Yeah, so I think that definitely gets to the right idea.
3202880	3204400	Have you written Rust?
3204400	3205840	Yeah, OK.
3205840	3212000	So in JavaScript, we started using the immutable list
3212000	3215560	library, where we couldn't update any of the variables.
3215560	3218680	But that didn't actually stop us from having two references
3218680	3220000	to those immutable lists.
3220000	3222680	So there's nothing inherent in immutability
3222680	3226480	that says we can't have multiple references, which
3226480	3230280	is why there's nothing here.
3230280	3234040	There's not really any way for the developer
3234040	3238080	to prevent aliasing of memory that they think
3238080	3240880	that they exclusively own.
3240880	3245200	Because maybe somebody else is also copying it.
3245200	3248920	But what if we were able to create a fixed language where
3248920	3253480	we can flag references as being exclusive,
3253480	3256480	meaning they have no aliasing allowed,
3256480	3259160	or they could be shared, which means
3259160	3262320	they can be aliased as normal.
3262320	3264480	So shared memory, shared references
3264480	3268960	would be just like every other variable you've ever used.
3268960	3272480	Exclusive references, you would not
3272480	3276400	be able to have two pointers to that same memory.
3276400	3280960	So for example, we might say foo is an exclusive XCL,
3280960	3283800	exclusive new foo.
3283800	3286040	And then if we tried to say bar is
3286040	3290280	equal to foo, which would create two references to that memory,
3290280	3292280	we would get a compile error.
3292280	3294800	Well, I guess we'd get a compile error here
3294800	3296560	when we tried to use foo.
3296560	3299080	Because foo is no longer a reference to our thing,
3299080	3301120	we've transferred the reference.
3302120	3307960	So what we're doing is we're adding a new alias type
3307960	3310480	modifier to all of our variables.
3310480	3316560	Our variables are now either shared or they're exclusive.
3316560	3320080	And we can use the compiler to perform type inference
3320080	3325920	on our code and say, are we misusing exclusive pointers
3325920	3329740	or misusing shared pointers in any of our places?
3329740	3332660	We will run type inference and type checking
3332660	3334500	to find those sorts of bugs.
3337980	3343180	So if we wrote a slightly larger function, increment,
3343180	3347860	it could take a parameter x, which is exclusive.
3347860	3352440	So x is an exclusive non-zero number.
3352440	3354660	Then we could convert it to an int.
3354660	3356220	We could increment it.
3356220	3357660	We can do whatever we want.
3357660	3363620	Anything inside of our increment function,
3363620	3366420	we have exclusive control over x.
3366420	3370900	Nobody else is going to be updating x.
3370900	3374180	And the compiler will tell us that based on the types
3374180	3378180	that we've annotated the rest of our code with.
3378180	3383100	So the xcl flag guarantees that no one else
3383100	3384500	is accessing the variable.
3384500	3388400	And we can safely invalidate our invariants.
3388400	3392900	If we had something like this in Solidity or in Java
3392900	3396200	or, what was the other one, in Go,
3396200	3400540	we could prevent the errors that we were seeing before.
3400540	3405460	And the reveal of all of this is that this
3405460	3408300	isn't some crazy new concept.
3408300	3413500	This is what Rust does with its borrow checker.
3413500	3415760	Rust checks to make sure that you're
3415760	3418540	treating your exclusive variables as exclusive
3418540	3421700	and your shared variables as shared.
3421700	3424620	And so it has the borrow checker,
3424620	3426420	not just for memory management.
3426420	3428260	It also does aliasing.
3431140	3433140	All right.
3433140	3436020	Questions on any of those last slides?
3436020	3438780	Borrow checker, Rust, things of this nature, exclusive?
3438940	3443660	Even with that fix in Rust, to go back to the dowel example,
3443660	3448380	that doesn't fix that issue, does it?
3448380	3451980	In the exact solution, does it?
3451980	3456100	Because that's a problem with parallel operations
3456100	3459780	on not one central piece.
3459780	3460260	Right.
3460260	3462660	So you would need your underlying system
3462660	3466980	to be written in Rust and to have these sorts of things
3467020	3470500	be part of your exclusive memory.
3470500	3473340	So nobody else should be able to access balance
3473340	3476020	while I am accessing balance.
3476020	3479260	Inside of this function, where I'm running this,
3479260	3482500	no one else should be able to run that function while I
3482500	3483980	am running this function.
3483980	3487580	And my smart contract, if it were written in Rust,
3487580	3490980	should prevent other people running the same smart
3490980	3492620	contract.
3492620	3494300	Because we're all trying to update.
3494300	3496500	The issue is that we're updating balances.
3496500	3498980	We're checking balances and updating balances.
3498980	3503220	If we make that exclusive, we should be fine.
3503220	3507660	You can make that exclusive across distributed
3507660	3508620	and correct?
3508620	3509120	Right.
3509120	3512380	How does that component come into play?
3512380	3519900	So there's, I'm blanking on the term, for consistency.
3519900	3521940	That is a problem for consistency
3521940	3524900	of distributed systems.
3524900	3527940	I mean, the heart of all of crypto stuff
3527940	3532540	is built on consensus algorithms, such as like Paxos
3532540	3538860	or what's the cool one?
3538860	3539940	Blanking on that as well.
3539940	3542460	It's been too long since I've done distributed.
3542460	3545180	But there are protocols that allow
3545180	3549500	you to achieve consistency for your data store, which
3549500	3550700	is the blockchain.
3550700	3553200	So the blockchain is always consistent.
3553200	3556240	So you just need a language on top of it where you can say,
3556240	3558920	no one should be updating this part of the blockchain
3558920	3560720	at the same time as me.
3560720	3561220	Yeah?
3561220	3564720	So what's the difference between a mutex on balances
3564720	3567680	versus a reference on mutex on balances?
3573360	3577080	So the difference between a mutex on balances
3577080	3580720	here is addressing this at the application level,
3580720	3586440	where I'm saying, no one can be running inside of my scope
3586440	3588080	this same stuff.
3588080	3591920	You would want a mutex for the entire protocol,
3591920	3595480	for the entire blockchain, to do that.
3595480	3598900	And that would be probably prohibitively slow
3598900	3599840	on the chain.
3599840	3601720	Because you'd say, no one else can, like,
3601720	3606240	operate on the chain while I am operating on the chain.
3606240	3607080	Does that make sense?
3607080	3607580	Yeah.
3607580	3610440	What is the reference on the reference here?
3610440	3613340	I'm not quite sure how you would bring in the exclusive reference
3613340	3613840	here.
3613840	3617380	But it would have to be at a more fundamental layer
3617380	3618320	than this piece.
3618320	3618820	Yeah.
3618820	3620280	I don't know what the reference is.
3620280	3622140	I don't know what the reference is in that.
3622140	3624800	But I think it's similar to the reference
3624800	3627500	that was used for graphing the data.
3627500	3628000	No.
3628000	3634420	So this is part of the language.
3634420	3636840	This is a new feature for the language
3636880	3639240	that the compiler is going to be enforcing.
3639240	3642960	There's no actual runtime implication of exclusive.
3642960	3644880	Oh, OK.
3644880	3647840	This is a piece that's saying, I'm going to check your code
3647840	3650800	and make sure no one else can operate on this thing
3650800	3654240	while you are operating on this thing.
3654240	3660400	Here, with mutexes, we have very much runtime implication,
3660400	3662520	and checks, and stuff of that sort.
3662520	3665280	So you still want to have mutexes in a world
3665280	3668880	where you'd have exclusive references.
3668880	3670560	I could see that still playing a part.
3679800	3681040	Other questions?
3688000	3688500	Yeah.
3688500	3690120	If you're not writing in Rust, you're
3690120	3692680	risking that problem?
3692680	3694400	Even if you're writing in Rust, sometimes
3694400	3696840	you're risking that problem.
3696840	3697340	But yeah.
3697340	3697840	No.
3697840	3700440	I mean, actually, while we're on this slide,
3700440	3703840	this is a reasonable piece of Go code,
3703840	3707480	where the whole point of me writing code in Go
3707480	3712680	is because I want to distribute all of my tasks concurrently
3712680	3715720	and just say, everyone go do this thing,
3715720	3717880	and come back and tell me once it's done.
3717880	3720520	So the idea of writing a for loop,
3720520	3723560	where I'm running a bunch of threads
3723560	3727920	in parallel across some shared memory,
3727920	3731240	that probably happens all the time.
3731240	3734440	And you would run into, potentially, this problem,
3734440	3738480	even if you're trying to solve it with mutexes.
3738480	3739980	Yeah.
3739980	3741940	Do you get the couple when you do the product?
3741940	3744000	Like, are you doing the product?
3744000	3746080	But then, do you get any parallelism?
3746960	3751920	Like, you don't get any benefit of all of the cores
3751920	3756160	on your CPU, if you put read-write locks everywhere
3756160	3758160	on here.
3758160	3759880	But yeah, you can.
3759880	3761360	It's just then you kind of lose out.
3766000	3766500	Yeah.
3766660	3770140	So what's it exactly like that I'm going to use the mute?
3770140	3772580	Like, if you were in Rust, is that
3772580	3774500	the type-checking you're doing when you're doing
3774500	3777140	do-able registers and non-do-able registers?
3777140	3781460	Or is there something else that you're not doing?
3781460	3790940	So in Rust, if we say, let x equal mem,
3790940	3793940	we allocate some space on the heap.
3793940	3795780	We say x is equal to that mem.
3795820	3799140	And then we say y equal x, or let y equal x.
3802740	3805900	Then we try to access y.
3805900	3806860	We're good to go.
3806860	3809300	If we try to access x, all right,
3809300	3812140	I've chosen a poor letter, we are not good to go.
3812140	3814460	We run into an issue.
3814460	3817140	And this is a compile issue that says, hey,
3817140	3820260	you don't have access to x anymore.
3820260	3823940	And that's just the default behavior.
3823940	3827780	That's what the borrow checker will ensure for any memory
3827780	3830460	that you create.
3830460	3833180	Then you can create mutable references and stuff
3833180	3834420	on top of that.
3834420	3838140	But that's kind of a layer above.
3840860	3845020	We will all start working on Rust quite soon.
3845020	3846580	I think PA6.
3846580	3851980	So it'll be in two weeks, or two weeks after spring break,
3851980	3853700	where you'll write your first Rust code,
3853700	3854620	if you haven't before.
3857700	3859820	With some intro to it, so don't worry too much.
3863260	3864540	Any other questions?
3864540	3865540	Yeah?
3865540	3868020	But this way, you're kind of pushing the problem
3868020	3869980	to the compiler side.
3869980	3872460	So you probably have a lot of errors
3872460	3874940	showing up about concurrency issues,
3874940	3877220	what you do to it in general.
3877220	3878180	Definitely.
3878180	3881180	This is now the compiler's job to tell you
3881180	3882980	when you are right and wrong.
3882980	3885140	And just like comparing JavaScript
3885140	3890260	to a language like Java, with types,
3890260	3895180	sometimes JavaScript works, even though the types are weird.
3895180	3899100	And you're trying to call an integer
3899100	3900300	as though it were a function.
3900300	3903180	So long as you never use that piece of code,
3903180	3905260	it's not going to crash.
3905260	3907700	But Java would say, hey, that's a type error.
3907700	3910180	You can't do that.
3910180	3913460	Here, Rust is going to give you compile errors
3913460	3915500	for all of the places where you're doing something
3915500	3917780	potentially wrong, even if it wouldn't have caused
3917780	3919620	a problem in the first place.
3919620	3922020	So it's more restrictive.
3922020	3928100	But as a result, it's always safe,
3928100	3931100	unless you specifically say unsafe.
3931100	3932540	Then it's not always safe.
3932540	3936020	Yeah?
3936020	3939020	So is it like, at compile time, I
3939020	3942500	should be able to figure out how should I
3942500	3945980	access the concurrency as a shared memory?
3945980	3950980	Rather than dedicate that problem to the compile time,
3950980	3953980	where if I don't, I don't need it.
3953980	3954820	Exactly.
3954820	3958100	So the big benefit here is that now we're
3958100	3960420	able to do this stuff at compile time.
3960500	3964100	And what we are doing is effectively type inference,
3964100	3966740	where we're saying, track the type,
3966740	3971220	the exclusive or shared type of this variable,
3971220	3973100	and infer it as it goes along.
3973100	3977180	Anytime we run into a conflict, raise an error.
3977180	3982660	So wouldn't that reduce the parallelism even more?
3982660	3985140	Because in the new text, it kind of
3985140	3987620	allows being optimistic about it.
3987620	3990100	And you just let all the threads run.
3990100	3992100	And no matter who gets the, yeah,
3992100	3995100	you can use runtime checks to do that.
3995100	3997100	But at compile time, you're preemptively
3997100	4004100	forcing the order of threads getting used to it.
4004100	4006020	I think that's a fair argument.
4006020	4010820	Is this not potentially slower?
4010820	4016660	But counter-argument, right?
4016660	4020340	So it is more restrictive in what you can write.
4020340	4022660	What that means is either you have to write,
4022660	4025460	what you end up is with something slower,
4025460	4028300	or you have to write the code correct
4028300	4031420	so that it's equally fast, or potentially faster,
4031420	4034420	and you're never going to get cycles.
4034420	4035340	Yeah.
4035340	4038540	But it's maybe harder to write that mid-tier
4038540	4042820	where it's fast sometimes, and it crashes sometimes.
4042820	4045140	But that's probably a good thing.
4045140	4046620	Yeah.
4046620	4049580	I'm going back to the slow example.
4049580	4054540	Was there a reason for that?
4054540	4056500	Or is it all coming down to power?
4056500	4060980	Is that the fact that it's high performance?
4060980	4061940	Do I have to make it?
4061940	4065740	I would have to think about it.
4065740	4069060	We can think about it in Office Hours together, if you want.
4069060	4073300	If you want to learn more about the piece
4073300	4080660	that we were just talking about, considerations on code
4080660	4083740	crafting, finding the next 10,000 aliasing bugs.
4083740	4086420	I'll post it on Piazza as well, if you want to read it.
4086420	4091780	They basically walk through a lot of the same ideas.
4091780	4095700	I did not generate all of these ideas myself.
4095700	4098820	Mostly I read about them this morning.
4098820	4101860	So they go into more about the types,
4101860	4103100	if you want to look at that.
4103900	4108260	And the idea of permissions with exclusive types.
4108260	4109940	Things of this nature.
4109940	4111740	All right.
4111740	4114620	From there, though, I think we will call it a day.
4114620	4116860	Seven minutes early.
4116860	4119340	Feel free to drop by Office Hours.
4119340	4121700	If you want to write some Python code.
4137420	4138820	Yeah, yeah, yeah.
4138820	4140620	Let me.
4629340	4630900	I'll do it.
4630900	4632140	I'll do it.
4632140	4641740	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
4641740	4648980	13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
4648980	4655820	26, 27, 28, 29, 30, 31, 32, 33, 34, 34, 35, 36, 37,
4655940	4665420	38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
4665420	4678620	52, 53, 54, 55, 56, 57, 58, 59, 60.
4678620	4694300	59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 78,
4694300	4704060	79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 93, 94, 94, 93, 94,
