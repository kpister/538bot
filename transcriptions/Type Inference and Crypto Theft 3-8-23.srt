1
00:00:00,000 --> 00:00:05,000
This is a course on the principles and paradigms of programming languages.

2
00:00:30,000 --> 00:00:32,000
This is a course on the principles and paradigms of programming languages.

3
00:01:00,000 --> 00:01:28,880
This is a course on the principles and paradigms of programming languages.

4
00:01:29,880 --> 00:01:31,160
Is there a fourth option?

5
00:01:31,160 --> 00:01:32,120
Is that what you said?

6
00:01:32,120 --> 00:01:32,840
Yeah, really hard.

7
00:01:32,840 --> 00:01:33,340
Really hard.

8
00:01:40,160 --> 00:01:42,160
This is anonymous, just so you guys know.

9
00:01:42,160 --> 00:01:44,480
I'm not recording what you say.

10
00:01:48,160 --> 00:01:50,160
Can you guys see two questions, by the way?

11
00:01:50,160 --> 00:01:52,000
Or just one?

12
00:01:52,000 --> 00:01:52,760
You see two?

13
00:01:52,760 --> 00:01:53,260
Great.

14
00:01:53,260 --> 00:01:53,760
Thank you.

15
00:01:58,880 --> 00:01:59,840
I'm taking an exam.

16
00:01:59,840 --> 00:02:01,840
I'm trying to figure out, like, what is it?

17
00:02:01,840 --> 00:02:03,820
Are we going to do, like, a couple of them?

18
00:02:03,820 --> 00:02:04,320
Yeah.

19
00:02:04,320 --> 00:02:05,320
I don't know that.

20
00:02:05,320 --> 00:02:07,800
Like, I feel like we're going to do a couple of those.

21
00:02:07,800 --> 00:02:09,280
Yeah, professor, really hard.

22
00:02:09,280 --> 00:02:10,760
They do this every day, right?

23
00:02:10,760 --> 00:02:12,240
And then they're like, I don't know.

24
00:02:12,240 --> 00:02:13,720
So I'm like, you're really weird.

25
00:02:13,720 --> 00:02:14,720
I'm like, I don't know.

26
00:02:14,720 --> 00:02:15,720
I'm like, I don't know.

27
00:02:15,720 --> 00:02:16,720
I'm like, I don't know.

28
00:02:16,720 --> 00:02:17,720
I'm like, I don't know.

29
00:02:17,720 --> 00:02:20,720
I think my answer to that is I'm like, I'm not great.

30
00:02:20,720 --> 00:02:21,720
I'm like, I don't know.

31
00:02:21,720 --> 00:02:22,720
I'm like, I don't know.

32
00:02:22,720 --> 00:02:23,720
I'm like, I don't know.

33
00:02:23,720 --> 00:02:24,720
I'm like, I don't know.

34
00:02:24,720 --> 00:02:25,720
Fair enough.

35
00:02:25,720 --> 00:02:26,720
Yeah.

36
00:02:26,720 --> 00:02:39,720
Can we get participation points from participating in class, or is that only in class?

37
00:02:39,720 --> 00:02:40,720
Yes.

38
00:02:40,720 --> 00:02:46,720
In class matters, but a lot of it is, like, if I can know your name.

39
00:02:46,720 --> 00:02:53,000
I have a photo of everyone, and I match it with your name, and then based on how well

40
00:02:53,000 --> 00:02:55,600
I remember you participating in class.

41
00:02:55,600 --> 00:02:57,520
So it's a little bit of a loose system.

42
00:02:57,520 --> 00:03:01,480
But it kind of works.

43
00:03:01,480 --> 00:03:02,480
Bring a name tag.

44
00:03:02,480 --> 00:03:03,480
It might work.

45
00:03:03,480 --> 00:03:04,480
It might help.

46
00:03:04,480 --> 00:03:06,160
All right, guys.

47
00:03:06,160 --> 00:03:10,600
We have 27 responses here, so I think we are gonna close it out, because it looks like

48
00:03:10,600 --> 00:03:12,360
there are roughly 30 people.

49
00:03:12,360 --> 00:03:15,160
Those of you in the back, you should scoot forward.

50
00:03:15,160 --> 00:03:16,160
Why not?

51
00:03:16,160 --> 00:03:17,160
You know?

52
00:03:17,160 --> 00:03:19,020
Come on up a little bit.

53
00:03:19,020 --> 00:03:24,040
We will be looking at some code on the screen, and the code is a little bit small, so the

54
00:03:24,040 --> 00:03:27,800
closer up you are, the better.

55
00:03:27,800 --> 00:03:30,800
Can I show you the responses?

56
00:03:30,800 --> 00:03:32,800
Responses.

57
00:03:32,800 --> 00:03:34,800
Okay.

58
00:03:34,800 --> 00:03:37,840
That sounds good.

59
00:03:37,840 --> 00:03:43,180
So harder than it was medium, and definitely not easy.

60
00:03:43,180 --> 00:03:46,680
And then in terms of fairness-ish.

61
00:03:46,680 --> 00:03:51,920
All right.

62
00:03:51,920 --> 00:03:54,200
So compared to last semester, maybe a bit harder.

63
00:03:54,200 --> 00:03:55,200
Good to know.

64
00:03:55,200 --> 00:03:57,700
I will take that into account as we go forward.

65
00:03:57,700 --> 00:04:01,720
Thank you for your feedback.

66
00:04:01,720 --> 00:04:05,560
Don't forget, we do drop the lowest midterm, so if that's this one, great.

67
00:04:05,560 --> 00:04:07,560
If it's not this one, also great.

68
00:04:07,560 --> 00:04:09,760
Up to you.

69
00:04:09,760 --> 00:04:12,280
All right.

70
00:04:12,280 --> 00:04:17,200
Welcome to a fun lecture in CS538.

71
00:04:17,200 --> 00:04:21,520
I try and add these as much as I can, because I like to talk about things that aren't just

72
00:04:21,520 --> 00:04:28,520
the stuff that's on the ACM, like, requirements for what principles and paradigms of programming

73
00:04:28,520 --> 00:04:30,280
languages is.

74
00:04:30,280 --> 00:04:33,200
Before we get into the fun stuff, some notes.

75
00:04:33,200 --> 00:04:35,740
The PA and the homework are not going to be released.

76
00:04:35,740 --> 00:04:40,240
If you already have a copy somehow, because you stole them while they were halfway released

77
00:04:40,240 --> 00:04:42,040
or something, ignore them.

78
00:04:42,040 --> 00:04:43,480
They are not released.

79
00:04:43,480 --> 00:04:46,080
You don't have to do them until after spring break.

80
00:04:46,080 --> 00:04:49,480
Have a fun spring break.

81
00:04:49,480 --> 00:04:50,920
Midterms will be graded soon-ish.

82
00:04:51,320 --> 00:04:52,320
I have them all scanned.

83
00:04:52,320 --> 00:04:55,840
The TA and I will be grading them.

84
00:04:55,840 --> 00:05:00,680
We will get those back to you hopefully within a week, and then once that is done, I will

85
00:05:00,680 --> 00:05:04,880
be able to update Canvas with your current grade.

86
00:05:04,880 --> 00:05:14,120
This will be unscaled, so it won't be â€“ if there is a curve, there's no curve on this

87
00:05:14,120 --> 00:05:19,000
grade, but it will have your 10% bonus for submitting early.

88
00:05:19,000 --> 00:05:25,760
It will have the individual weighting of each assignment versus the other assignments.

89
00:05:25,760 --> 00:05:30,040
This should be a pretty accurate reflection of what your grade will be at this point in

90
00:05:30,040 --> 00:05:31,400
time.

91
00:05:31,400 --> 00:05:34,800
I'm hoping that that will be done before spring break ends.

92
00:05:34,800 --> 00:05:41,640
It takes a while, so please be patient.

93
00:05:41,640 --> 00:05:48,360
I have a coding project that is school-related, so it's not work, it's not industry stuff.

94
00:05:48,360 --> 00:05:49,880
It's a coding project.

95
00:05:49,880 --> 00:05:56,920
If somebody is a very proficient Python coder and interested in hacking on something, come

96
00:05:56,920 --> 00:06:02,600
chat with me either after class or in office hours or send me an email.

97
00:06:02,600 --> 00:06:03,600
It might be hard.

98
00:06:03,600 --> 00:06:04,600
I don't know.

99
00:06:04,600 --> 00:06:05,600
We'll figure it out.

100
00:06:05,600 --> 00:06:10,320
There is a course eval that is the midterm course eval.

101
00:06:10,320 --> 00:06:13,020
You got it from the school.

102
00:06:13,020 --> 00:06:14,520
They ask you to fill it out.

103
00:06:14,520 --> 00:06:15,520
Please do.

104
00:06:15,960 --> 00:06:21,920
I appreciate it, because I take that information into all of the rest of my teaching.

105
00:06:21,920 --> 00:06:30,000
Let me know if I'm doing anything poorly or well, and I will try and fix or stay the course.

106
00:06:30,000 --> 00:06:31,000
Those are my notes.

107
00:06:31,000 --> 00:06:32,380
There were a lot of them.

108
00:06:32,380 --> 00:06:39,600
Any notes from you guys?

109
00:06:39,600 --> 00:06:42,120
It's a fun lecture, so we can talk about anything.

110
00:06:42,120 --> 00:06:43,120
Anything on your mind?

111
00:06:43,120 --> 00:06:44,120
Yeah?

112
00:06:44,120 --> 00:06:48,920
These lecture slides are called static analysis.

113
00:06:48,920 --> 00:06:49,920
They are on Canvas.

114
00:06:49,920 --> 00:06:50,920
Yep.

115
00:06:50,920 --> 00:06:51,920
Yep.

116
00:06:51,920 --> 00:07:04,080
I will post the solutions to the midterm.

117
00:07:04,080 --> 00:07:07,760
I don't typically go over them, but we can do that in office hours if you want to stop

118
00:07:07,760 --> 00:07:12,360
by.

119
00:07:12,360 --> 00:07:14,640
Anything else?

120
00:07:14,640 --> 00:07:17,960
All right.

121
00:07:17,960 --> 00:07:21,200
Today's lecture is loosely based...

122
00:07:21,200 --> 00:07:22,920
It was going to be something totally different.

123
00:07:22,920 --> 00:07:28,480
And then I read this article this morning called fixing the next 10,000 aliasing bugs.

124
00:07:28,480 --> 00:07:31,240
And just from the title, you know that's gonna be super exciting.

125
00:07:31,240 --> 00:07:32,240
I was like, yes!

126
00:07:32,240 --> 00:07:35,920
This is the thing I want to spend an hour and a half chatting about.

127
00:07:35,920 --> 00:07:37,880
No, not actually.

128
00:07:37,880 --> 00:07:43,600
It's a really boring looking title, and only a real PL nerd would get excited about that.

129
00:07:43,600 --> 00:07:48,120
But that's because they missed out on the real title.

130
00:07:48,120 --> 00:07:54,760
Which is using type inference to make $150.

131
00:07:54,760 --> 00:07:57,200
Minor correction.

132
00:07:57,200 --> 00:08:01,320
To steal $150 million.

133
00:08:01,320 --> 00:08:07,920
So the algorithm that we have been covering, Hindley-Milner type inference, loosely can

134
00:08:07,920 --> 00:08:15,800
be used to describe an attack that took place two years ago and resulted in somebody literally

135
00:08:15,800 --> 00:08:19,120
stealing $150 million.

136
00:08:19,120 --> 00:08:23,000
All of the material, or almost all of the material, comes from this blog post, the one

137
00:08:23,000 --> 00:08:25,600
that I showed at the start there.

138
00:08:25,600 --> 00:08:27,960
All the animations are my own.

139
00:08:27,960 --> 00:08:29,800
All right.

140
00:08:29,800 --> 00:08:32,880
So let's take a look at Java.

141
00:08:32,880 --> 00:08:37,160
I'm certainly not proficient in Java, but I have a little piece of Java for you.

142
00:08:37,160 --> 00:08:43,280
If you have your computer with you, feel free to go to my GitHub, to the CS538 snippets

143
00:08:43,280 --> 00:08:47,520
repo and take a look at the code that is there.

144
00:08:47,520 --> 00:08:52,120
Otherwise, I'm gonna put the code up on the screen so we can all look at it as a class.

145
00:08:52,120 --> 00:08:57,800
But if you want it so you can play around with it, do so.

146
00:08:58,800 --> 00:09:01,800
All right.

147
00:09:19,800 --> 00:09:20,800
All right.

148
00:09:20,800 --> 00:09:29,440
So in that folder, you should have a bug.java, if you can find it.

149
00:09:29,440 --> 00:09:31,800
And when we look at this...

150
00:09:31,800 --> 00:09:34,800
All right.

151
00:09:34,800 --> 00:09:39,800
I can go one bigger, two bigger, three bigger.

152
00:09:39,800 --> 00:09:40,800
Yeah.

153
00:09:40,800 --> 00:09:41,800
Is that readable?

154
00:09:41,800 --> 00:09:45,840
If it's not readable, there are plenty of seats up front.

155
00:09:45,840 --> 00:09:47,800
So please do come up front.

156
00:09:47,800 --> 00:09:49,500
All right.

157
00:09:49,500 --> 00:09:51,500
We have Java code.

158
00:09:51,500 --> 00:09:57,300
I have not written Java code since probably my sophomore year of college.

159
00:09:57,300 --> 00:10:01,500
So even getting this to compile was like, what is going on?

160
00:10:01,500 --> 00:10:02,820
But I did.

161
00:10:02,820 --> 00:10:05,900
So that's good.

162
00:10:05,900 --> 00:10:07,800
We have a class called MyList.

163
00:10:07,800 --> 00:10:13,180
This might come out from you having to write a data structure in one of your intro CS classes.

164
00:10:13,180 --> 00:10:19,100
You're told, write a data structure for a list in Java.

165
00:10:19,100 --> 00:10:24,620
This list should be able to add items of arbitrary length.

166
00:10:24,620 --> 00:10:31,300
So even though it started out as an array of ten items, once I add the eleventh item,

167
00:10:31,300 --> 00:10:36,180
it should be able to restructure and become an array of length 11.

168
00:10:36,180 --> 00:10:37,220
Or 20.

169
00:10:37,220 --> 00:10:38,760
Or 100.

170
00:10:38,760 --> 00:10:42,220
So it should be a dynamically lengthed list.

171
00:10:42,220 --> 00:10:46,500
But we have to stick within Java, so we're going to use an array to do that.

172
00:10:46,500 --> 00:10:52,100
And every time we go past our bounds, we will reallocate a new array, copy over all

173
00:10:52,100 --> 00:10:56,180
the old elements, and be good to go.

174
00:10:56,180 --> 00:10:57,320
Great.

175
00:10:57,320 --> 00:10:59,780
So we have some code.

176
00:10:59,780 --> 00:11:05,540
My challenge to you is identify the bug.

177
00:11:05,540 --> 00:11:09,000
And I'll give you five to ten minutes to do so.

178
00:11:09,000 --> 00:11:16,020
If you have code on your computer, feel free to download it, compile it, run it, and figure

179
00:11:16,020 --> 00:11:17,420
out what's going on.

180
00:11:17,420 --> 00:11:20,020
If you don't have code, talk to somebody next to you.

181
00:11:20,020 --> 00:11:22,920
Or stare at this for a little while.

182
00:11:22,920 --> 00:11:26,740
There is one piece at the very bottom that's not being shown.

183
00:11:26,740 --> 00:11:34,720
All that is is the main function, where I create a list S, I create a list T, add elements,

184
00:11:34,720 --> 00:11:40,020
and then, like, concatenate the two lists together.

185
00:11:40,020 --> 00:11:45,700
All right.

186
00:11:45,900 --> 00:11:47,900
So...

187
00:11:47,900 --> 00:11:48,900
Find the bug.

188
00:11:48,900 --> 00:11:53,500
I'll wander around and chat with you guys individually to see what you come up with.

189
00:11:53,500 --> 00:11:55,780
But give it five or ten minutes of debugging.

190
00:12:15,700 --> 00:12:16,700
And I'll see you guys later.

191
00:12:16,700 --> 00:12:17,700
Bye.

192
00:12:17,700 --> 00:12:17,700


193
00:12:45,700 --> 00:12:46,700
Bye.

194
00:12:46,700 --> 00:12:46,700


195
00:13:15,700 --> 00:13:16,700
Bye.

196
00:13:16,700 --> 00:13:16,700


197
00:13:46,700 --> 00:13:47,700
Bye.

198
00:13:47,700 --> 00:13:48,700
Bye.

199
00:13:48,700 --> 00:13:48,700


200
00:14:15,700 --> 00:14:16,700
Bye.

201
00:14:16,700 --> 00:14:16,700


202
00:14:46,700 --> 00:14:47,700
Bye.

203
00:14:47,700 --> 00:14:48,700
Bye.

204
00:14:48,700 --> 00:14:48,700


205
00:15:15,700 --> 00:15:16,700
Bye.

206
00:15:16,700 --> 00:15:16,700


207
00:15:46,700 --> 00:15:47,700
Bye.

208
00:15:47,700 --> 00:15:48,700
Bye.

209
00:15:48,700 --> 00:15:48,700


210
00:16:16,700 --> 00:16:17,700
Bye.

211
00:16:17,700 --> 00:16:18,700
Bye.

212
00:16:18,700 --> 00:16:18,700


213
00:16:45,700 --> 00:16:46,700
Bye.

214
00:16:46,700 --> 00:16:47,700
Bye.

215
00:16:47,700 --> 00:16:47,700


216
00:17:15,700 --> 00:17:16,700
Bye.

217
00:17:16,700 --> 00:17:17,700
Bye.

218
00:17:17,700 --> 00:17:17,700


219
00:17:46,700 --> 00:17:47,700
Bye.

220
00:17:47,700 --> 00:17:48,700
Bye.

221
00:17:48,700 --> 00:17:48,700


222
00:18:16,700 --> 00:18:17,700
Bye.

223
00:18:17,700 --> 00:18:18,700
Bye.

224
00:18:18,700 --> 00:18:18,700


225
00:18:45,700 --> 00:19:09,820
Okay.

226
00:19:09,820 --> 00:19:12,540
So what did we come up with?

227
00:19:12,540 --> 00:19:13,540
Who's got some ideas?

228
00:19:13,540 --> 00:19:17,260
I heard a lot of different ideas floating around.

229
00:19:17,260 --> 00:19:19,340
Did anybody get an actual error?

230
00:19:19,340 --> 00:19:24,300
Was anybody able to compile this and run it with some sort of main?

231
00:19:24,300 --> 00:19:28,900
Like changing this at all and getting an actual error?

232
00:19:28,900 --> 00:19:30,300
Okay.

233
00:19:30,300 --> 00:19:33,060
Fair enough.

234
00:19:33,060 --> 00:19:41,180
Did anybody come up with something that might be going wrong?

235
00:19:41,180 --> 00:19:50,660
All right.

236
00:19:50,660 --> 00:19:53,140
I'd like to poll the class.

237
00:19:53,140 --> 00:19:59,980
You have four functions, if you include the constructor as a function.

238
00:19:59,980 --> 00:20:02,380
Where is the bug?

239
00:20:02,380 --> 00:20:04,820
Could be based on your gut or just...

240
00:20:04,820 --> 00:20:05,820
I don't know.

241
00:20:05,820 --> 00:20:06,820
Something else.

242
00:20:06,820 --> 00:20:07,820
But I'm curious.

243
00:20:07,820 --> 00:20:08,820
Where do you think the bug is?

244
00:20:08,820 --> 00:20:12,020
Choose one of the four functions.

245
00:20:12,020 --> 00:20:13,100
The constructor.

246
00:20:13,100 --> 00:20:15,980
My list.

247
00:20:15,980 --> 00:20:18,980
Ensure capacity.

248
00:20:18,980 --> 00:20:20,700
Add.

249
00:20:20,700 --> 00:20:21,700
Add all.

250
00:20:21,700 --> 00:20:22,700
Okay.

251
00:20:22,700 --> 00:20:25,340
We got about a 50-50 split.

252
00:20:25,340 --> 00:20:28,380
Add all and ensure capacity.

253
00:20:28,380 --> 00:20:29,380
So which one is it?

254
00:20:29,580 --> 00:20:32,860
First of all, let's double check that I haven't, like,

255
00:20:32,860 --> 00:20:37,940
just cheated the whole time, and we can actually compile this thing.

256
00:20:37,940 --> 00:20:44,820
Compiles, it gives us a warning for our types, but that's fine.

257
00:20:44,820 --> 00:20:47,740
And then if we actually run it, we do actually run it.

258
00:20:47,740 --> 00:20:51,300
So there's no bug.

259
00:20:51,300 --> 00:20:56,300
That's gonna be annoying.

260
00:20:56,300 --> 00:20:58,780
In this main.

261
00:20:58,780 --> 00:21:03,300
In this version of main, where we create a list, we create a second list,

262
00:21:03,300 --> 00:21:06,020
we add an element to the first list, or to the second list,

263
00:21:06,020 --> 00:21:09,540
add an element to the second list, and then add them together.

264
00:21:09,540 --> 00:21:10,620
This part's fine.

265
00:21:10,620 --> 00:21:11,620
No bugs.

266
00:21:11,620 --> 00:21:12,620
Compiles.

267
00:21:12,620 --> 00:21:13,620
Runs.

268
00:21:13,620 --> 00:21:14,620
Without issue.

269
00:21:14,620 --> 00:21:26,700
I'm gonna make a one-character change.

270
00:21:26,700 --> 00:21:31,180
That's all that we're gonna change.

271
00:21:31,180 --> 00:21:35,980
This is what it was.

272
00:21:35,980 --> 00:21:47,220
This is what I'm changing it to.

273
00:21:47,220 --> 00:21:49,460
What happens?

274
00:21:49,460 --> 00:21:54,220
What we are saying now is that we're taking a list S

275
00:21:54,220 --> 00:22:02,740
and add all the elements from S to that list.

276
00:22:02,740 --> 00:22:03,740
So what's gonna happen?

277
00:22:03,740 --> 00:22:04,740
Yeah.

278
00:22:04,740 --> 00:22:14,980
There's gonna be a problem with ensure capacity.

279
00:22:14,980 --> 00:22:17,260
Let's run through it and see if there is.

280
00:22:17,260 --> 00:22:19,540
So we hit add all.

281
00:22:19,540 --> 00:22:22,860
Our parameter C is the list S.

282
00:22:23,380 --> 00:22:26,780
We are in the scope of S itself.

283
00:22:26,780 --> 00:22:33,100
So when we call ensure capacity, we're using the S version of ensure capacity,

284
00:22:33,100 --> 00:22:38,460
with the length of S and the length of S.

285
00:22:38,460 --> 00:22:42,060
So 2 times S.

286
00:22:42,060 --> 00:22:46,980
When we call ensure capacity with 2 times the length of S,

287
00:22:46,980 --> 00:22:51,460
which in this case is length 1, so it's a value of 2,

288
00:22:51,460 --> 00:22:56,780
we would check to see is min capacity 2 greater than array.length?

289
00:22:56,780 --> 00:22:57,780
Yes.

290
00:22:57,780 --> 00:23:01,060
Array.length is 1.

291
00:23:01,060 --> 00:23:06,060
So then we're going to set the new capacity equal to 2.

292
00:23:06,060 --> 00:23:09,340
The max of 2 and 2.

293
00:23:09,340 --> 00:23:17,020
Create a new list of length 2 and copy the old list into the new list.

294
00:23:17,020 --> 00:23:19,700
Is there a bug there?

295
00:23:19,700 --> 00:23:26,340
Did anything break?

296
00:23:26,340 --> 00:23:29,420
I don't think anything did break.

297
00:23:29,420 --> 00:23:42,340
And yet, so if we recompile and we rerun, we crash.

298
00:23:42,340 --> 00:23:46,220
So ensure capacity did not have any issue,

299
00:23:46,220 --> 00:23:49,780
but making this change did break something.

300
00:23:49,780 --> 00:23:52,540
That leaves the second group.

301
00:23:52,540 --> 00:23:58,340
The group that had the intuition that the issue is in add all.

302
00:23:58,340 --> 00:24:06,020
Something has gone wrong in add all after our ensure capacity check.

303
00:24:06,020 --> 00:24:07,020
What is it?

304
00:24:07,020 --> 00:24:08,020
Yeah.

305
00:24:08,020 --> 00:24:25,980
Right.

306
00:24:25,980 --> 00:24:34,660
So in Java, we are referencing this S, the length variable on that S,

307
00:24:34,660 --> 00:24:37,780
which we are incrementing inside of this for loop.

308
00:24:38,540 --> 00:24:48,380
However, our for loop check is saying until we are less than the length of C.length.

309
00:24:48,380 --> 00:24:50,900
While we are less than C.length.

310
00:24:50,900 --> 00:24:55,820
C is S. And we are incrementing the value of S's length.

311
00:24:55,820 --> 00:24:59,540
So we will continue going through this for loop over and over and over

312
00:24:59,540 --> 00:25:03,580
until we actually hit the bounds of the entire loop,

313
00:25:03,580 --> 00:25:14,460
which is when we get our final array index out of bounds exception.

314
00:25:14,460 --> 00:25:19,660
So I've got some slides to make this a bit more step by step.

315
00:25:19,660 --> 00:25:27,340
Let's go to those.

316
00:25:27,340 --> 00:25:31,100
The thing that we have, actually, let's go back.

317
00:25:31,100 --> 00:25:32,700
Let's do this backwards.

318
00:25:32,700 --> 00:25:37,220
We start with add all.

319
00:25:37,220 --> 00:25:43,180
And our first step of add all is saying let's ensure the capacity of the current list

320
00:25:43,180 --> 00:25:47,800
is greater than the old list with the new list combined.

321
00:25:47,800 --> 00:25:51,180
So make sure that we have enough space for whatever we're doing.

322
00:25:51,180 --> 00:25:55,140
And this is the, like, we're calling this the correct way.

323
00:25:55,140 --> 00:26:00,460
On the first iteration, I is zero, length of our list is two,

324
00:26:00,460 --> 00:26:06,020
length of C.length, or C.length is one.

325
00:26:06,020 --> 00:26:10,900
We execute the body of the loop, incrementing our length.

326
00:26:10,900 --> 00:26:16,420
And then setting C.length, or C.length is still one.

327
00:26:16,420 --> 00:26:21,940
Loop back through, am I on the right one?

328
00:26:21,940 --> 00:26:22,940
I am on the right one.

329
00:26:22,940 --> 00:26:24,260
We go back to the top.

330
00:26:24,260 --> 00:26:27,380
We check is I less than C.length.

331
00:26:27,380 --> 00:26:28,380
It's no longer.

332
00:26:28,380 --> 00:26:29,380
So we're done.

333
00:26:29,380 --> 00:26:35,700
This is if we ran it with the correct inputs, like not passing S. We don't run into any

334
00:26:35,700 --> 00:26:41,660
issue because C.length has remained constant.

335
00:26:41,660 --> 00:26:49,100
On the other hand, if we pass in S as our parameter, first we do that same ensure capacity

336
00:26:49,100 --> 00:26:50,660
check.

337
00:26:50,660 --> 00:26:57,940
Then we say I is equal to zero, length is equal to two, C.length is equal to two.

338
00:26:57,940 --> 00:27:05,220
When we get to our length++, we increment not only our length, but also C.length.

339
00:27:05,220 --> 00:27:09,860
Because C.length is the same as our length.

340
00:27:09,860 --> 00:27:15,140
Which means that C.length increments with our own length.

341
00:27:15,140 --> 00:27:20,380
We go back up to the next time, increment I. I is less than C.length.

342
00:27:20,380 --> 00:27:29,660
And this will continue forever and ever and ever until we actually index into the array

343
00:27:29,660 --> 00:27:36,540
at an invalid location.

344
00:27:36,540 --> 00:27:41,340
So this is the bug that we have found.

345
00:27:41,340 --> 00:27:50,300
Questions on the bug?

346
00:27:50,300 --> 00:27:52,020
It's a bit involved.

347
00:27:52,020 --> 00:27:59,740
I recognize that.

348
00:27:59,740 --> 00:28:05,220
So if we go back to what went wrong, we had this implicit invariant.

349
00:28:05,220 --> 00:28:12,260
And it was that the length of the input list does not change between the ensure capacity

350
00:28:12,260 --> 00:28:15,380
call and the for loop.

351
00:28:15,380 --> 00:28:27,060
Outside of our add list, or add all function, our input list length does not change.

352
00:28:27,060 --> 00:28:33,420
And you might look at that and say, that's safe, so long as we aren't multithreading.

353
00:28:33,420 --> 00:28:38,420
It makes sense that if we're multithreading, maybe somebody updated the list in between.

354
00:28:38,420 --> 00:28:41,380
But if we aren't multithreading, maybe we're safe.

355
00:28:41,380 --> 00:28:43,960
What we found is that no, that's not true.

356
00:28:43,960 --> 00:28:50,520
If we pass in the same object itself, when we increment length, we're incrementing the

357
00:28:50,520 --> 00:28:52,240
input length as well.

358
00:28:52,240 --> 00:29:02,360
Which means we've broken our invariant.

359
00:29:02,360 --> 00:29:03,360
Sound good?

360
00:29:03,360 --> 00:29:04,360
Questions?

361
00:29:04,360 --> 00:29:09,740
All right.

362
00:29:09,740 --> 00:29:15,820
So how does this turn into $150 million?

363
00:29:15,820 --> 00:29:20,140
How many of you are familiar with DAOs?

364
00:29:20,140 --> 00:29:21,140
Some number of you.

365
00:29:21,140 --> 00:29:23,340
Follow, like, news and whatnot.

366
00:29:23,340 --> 00:29:28,260
So before we talk about what a DAO is, we should take a second to say, what is a smart

367
00:29:28,260 --> 00:29:29,260
contract?

368
00:29:29,260 --> 00:29:31,700
How many of you know what smart contracts are?

369
00:29:31,700 --> 00:29:32,700
Very few.

370
00:29:32,700 --> 00:29:33,700
How many of you have written a smart contract?

371
00:29:33,700 --> 00:29:34,700
All right.

372
00:29:34,700 --> 00:29:37,060
One or two.

373
00:29:37,060 --> 00:29:47,140
So a smart contract is a small piece of public code, very similar to an API endpoint.

374
00:29:47,140 --> 00:29:54,220
However, different than an API endpoint is that it's run on a distributed cloud.

375
00:29:54,220 --> 00:30:00,020
Typically associated with what's called a blockchain.

376
00:30:00,020 --> 00:30:06,260
And the way that you purchase credits so that you can run code on this distributed

377
00:30:06,260 --> 00:30:12,020
cloud is that you pay with a digital currency.

378
00:30:12,020 --> 00:30:16,020
Such as Doge.

379
00:30:16,020 --> 00:30:21,060
What this code is, though, is effectively anything.

380
00:30:21,060 --> 00:30:28,340
We can write whatever web app we want and run it on a distributed cloud.

381
00:30:28,340 --> 00:30:29,660
For example, ETH.

382
00:30:29,660 --> 00:30:33,600
Or I guess Doge doesn't actually have smart contracts, but that's beside the point.

383
00:30:33,600 --> 00:30:37,900
So there are languages designed to write smart contracts.

384
00:30:37,900 --> 00:30:41,540
One of them, for example, is called Solidity.

385
00:30:41,540 --> 00:30:43,780
Solidity looks something like this.

386
00:30:43,780 --> 00:30:47,380
We create a contract and we give it a name.

387
00:30:47,380 --> 00:30:50,140
And it has some stored data.

388
00:30:50,140 --> 00:30:53,260
And then we define functions on that contract.

389
00:30:53,260 --> 00:30:56,500
Set and get, for example.

390
00:30:56,500 --> 00:31:02,980
Someone can then call these functions and provided they pay the gas to make them happen,

391
00:31:02,980 --> 00:31:07,380
they will execute that code.

392
00:31:07,380 --> 00:31:13,420
This is a really convenient model compared to the idea of having to spin up your own

393
00:31:13,420 --> 00:31:19,020
EC2 box, where you're running all of your functions and having it all handled there.

394
00:31:19,020 --> 00:31:25,060
You just deploy your code and pay other people to run it for you when you want it to be run.

395
00:31:25,060 --> 00:31:26,060
Very cool.

396
00:31:26,060 --> 00:31:33,820
In theory, crypto and Web3 have kind of spiraled into insanity at this point.

397
00:31:33,820 --> 00:31:41,660
But fundamentally, cool idea.

398
00:31:41,660 --> 00:31:43,540
You guys like seeing real code?

399
00:31:43,540 --> 00:31:54,220
So this is a smart contract that I wrote that creates, like, NFTs of those audio snippets

400
00:31:54,380 --> 00:31:56,620
that I showed you from before.

401
00:31:56,620 --> 00:32:02,220
So not only do you put one line of HTML and I turn your web page into a podcast, I also

402
00:32:02,220 --> 00:32:07,660
mint an NFT that you can then put on OpenSea.

403
00:32:07,660 --> 00:32:09,140
This feature never deployed.

404
00:32:09,140 --> 00:32:11,460
It was just more of a meme.

405
00:32:11,460 --> 00:32:15,740
And then to show investors and be like, hey, yeah, we're Web3.

406
00:32:15,740 --> 00:32:19,900
Anyway, back to the DAO.

407
00:32:19,900 --> 00:32:24,340
So what is a DAO?

408
00:32:24,340 --> 00:32:33,220
The original DAO was this relatively reasonable idea that we could build a smart contract

409
00:32:33,220 --> 00:32:39,100
and have it be used as a distributed investment fund.

410
00:32:39,100 --> 00:32:42,780
Remove the idea of a hedge fund.

411
00:32:42,780 --> 00:32:44,660
Remove big banks.

412
00:32:44,660 --> 00:32:45,660
They suck.

413
00:32:45,660 --> 00:32:48,220
They only help the very wealthy.

414
00:32:48,220 --> 00:32:52,540
Let's have a distributed hedge fund, effectively.

415
00:32:52,540 --> 00:32:54,060
The functionality is very simple.

416
00:32:54,060 --> 00:32:56,060
You put money in.

417
00:32:56,060 --> 00:32:58,460
The money grows over time.

418
00:32:58,460 --> 00:33:01,460
You vote on what the fund should invest in.

419
00:33:01,460 --> 00:33:02,900
And you vote...

420
00:33:02,900 --> 00:33:08,940
Your weight of your vote is corresponding to your percent ownership of the DAO.

421
00:33:08,940 --> 00:33:12,780
And then obviously you get to pull money out.

422
00:33:12,780 --> 00:33:18,540
Once it has grown and accumulated value.

423
00:33:18,540 --> 00:33:20,860
Power to the people.

424
00:33:20,860 --> 00:33:21,860
Distribute finances.

425
00:33:21,860 --> 00:33:23,860
It's great.

426
00:33:23,860 --> 00:33:25,860
Oops.

427
00:33:25,860 --> 00:33:29,060
So...

428
00:33:29,060 --> 00:33:31,700
It's a great idea.

429
00:33:31,700 --> 00:33:38,900
But now we're starting to put real money in code where what if there's a bug in your code

430
00:33:38,900 --> 00:33:43,620
and you can never pull out your money again?

431
00:33:43,620 --> 00:33:50,300
This is an abbreviated version of the real DAO smart contract where you would be able

432
00:33:50,300 --> 00:33:52,340
to withdraw money.

433
00:33:52,340 --> 00:33:56,700
So when you had put in your money and it had grown and you decided it's time to pull this

434
00:33:56,700 --> 00:34:03,140
money out so I can use it again, you would call this function and you would say...

435
00:34:03,140 --> 00:34:04,700
Here's my ID.

436
00:34:04,700 --> 00:34:08,420
This is how much money I want to withdraw.

437
00:34:08,420 --> 00:34:11,220
And simplified, it would boil down...

438
00:34:11,220 --> 00:34:13,940
The function boils down to roughly this.

439
00:34:13,940 --> 00:34:15,260
Step one.

440
00:34:15,260 --> 00:34:21,260
Calculate how many funds, how much of the money that you have in the DAO do you want

441
00:34:21,260 --> 00:34:22,260
to remove?

442
00:34:22,260 --> 00:34:25,260
Do you want to remove 5 ETH?

443
00:34:25,260 --> 00:34:27,300
Do you want to remove 10 ETH?

444
00:34:27,300 --> 00:34:28,500
0.1 ETH?

445
00:34:28,500 --> 00:34:32,700
So calculate how much money you want to move.

446
00:34:32,700 --> 00:34:34,340
Step two.

447
00:34:34,340 --> 00:34:36,420
Prepare to move that money.

448
00:34:36,420 --> 00:34:40,700
And check to see if there's an error when you remove that money.

449
00:34:40,700 --> 00:34:46,060
So if they're trying to move more money than they have, for example, check.

450
00:34:46,060 --> 00:34:48,940
If they are, don't do it.

451
00:34:48,940 --> 00:34:54,460
Don't let somebody withdraw 10 ETH when they only have 5 ETH in their bank.

452
00:34:54,460 --> 00:35:01,140
So that's what this if error or if no error, then withdraw the actual money.

453
00:35:01,140 --> 00:35:02,300
They're asking for their money.

454
00:35:02,300 --> 00:35:03,620
Give them the money.

455
00:35:03,660 --> 00:35:06,540
Finally, zero the user's balance.

456
00:35:10,300 --> 00:35:10,800
All right.

457
00:35:10,800 --> 00:35:11,800
What goes wrong?

458
00:35:22,660 --> 00:35:23,660
Yeah?

459
00:35:23,660 --> 00:35:29,780
What if they're not withdrawing all their money?

460
00:35:29,780 --> 00:35:30,780
Yep.

461
00:35:30,780 --> 00:35:31,780
What do you mean?

462
00:35:31,780 --> 00:35:35,260
At the bottom, that would be zero, right?

463
00:35:35,260 --> 00:35:36,100
Oh, sure.

464
00:35:36,100 --> 00:35:38,020
Yeah.

465
00:35:38,020 --> 00:35:41,260
That's me simplifying code.

466
00:35:41,260 --> 00:35:44,100
We set it to be whatever is remaining.

467
00:35:44,100 --> 00:35:47,100
Or we could pretend this is full withdrawal.

468
00:35:47,100 --> 00:35:47,600
Yeah.

469
00:35:47,600 --> 00:35:48,100
Either way.

470
00:35:58,020 --> 00:35:58,520
Yeah.

471
00:35:58,600 --> 00:36:02,480
This createToken.value is basically our check to say,

472
00:36:02,480 --> 00:36:06,440
will this thing, when we withdraw this amount of money,

473
00:36:06,440 --> 00:36:09,080
will it cause an error?

474
00:36:09,080 --> 00:36:12,480
What it's really doing is it's preparing a separate coin

475
00:36:12,480 --> 00:36:16,080
for that user under the hood and all of this

476
00:36:16,080 --> 00:36:18,440
that we will transfer to that user.

477
00:36:18,440 --> 00:36:20,680
So there's a bit more complexity hidden behind there.

478
00:36:20,680 --> 00:36:24,020
But we can think of it as an error check.

479
00:36:24,020 --> 00:36:27,600
We're checking to validate, is this thing OK to do?

480
00:36:28,520 --> 00:36:29,020
Yeah?

481
00:36:33,980 --> 00:36:34,480
Yeah?

482
00:36:34,480 --> 00:36:38,440
What's a HashMap?

483
00:36:38,440 --> 00:36:39,320
It's a dictionary.

484
00:36:39,320 --> 00:36:40,940
HashMap, whatever you want to call it.

485
00:36:44,120 --> 00:36:47,480
Consider that we're on a distributed cloud.

486
00:36:47,480 --> 00:36:51,760
It's one of the actual main purposes of smart contracts.

487
00:36:51,760 --> 00:36:53,080
Yeah?

488
00:36:53,080 --> 00:36:56,320
Does that do something with atomic operations

489
00:36:56,320 --> 00:36:57,760
in parallel?

490
00:36:57,760 --> 00:36:58,280
Sure.

491
00:36:59,040 --> 00:37:02,800
So what does that mean?

492
00:37:02,800 --> 00:37:04,400
What part of this is not atomic?

493
00:37:04,400 --> 00:37:07,100
What part of it would you want to be atomic?

494
00:37:07,100 --> 00:37:07,600
Yeah?

495
00:37:28,480 --> 00:37:30,120
Or something?

496
00:37:30,120 --> 00:37:35,480
That is exactly what these guys exploited.

497
00:37:35,480 --> 00:37:39,040
If we have multiple of these processes running

498
00:37:39,040 --> 00:37:44,160
at the same time, and they check that they're

499
00:37:44,160 --> 00:37:48,160
valid all at the same time, before we

500
00:37:48,160 --> 00:37:52,240
have set our actual value to zero,

501
00:37:52,240 --> 00:37:56,480
then they will all say, you have 5 ETH in your bank.

502
00:37:56,480 --> 00:38:01,080
Then when we withdraw 5 ETH from five different processes

503
00:38:01,080 --> 00:38:04,440
running the same thing, you get 25 ETH.

504
00:38:04,440 --> 00:38:07,920
While at the end, you're only ever set down to zero.

505
00:38:07,920 --> 00:38:13,040
You can't have negative 20 ETH in your account.

506
00:38:13,040 --> 00:38:19,740
So because these are not atomic in this check withdraw set,

507
00:38:19,740 --> 00:38:22,640
we're running into this concurrency problem

508
00:38:22,640 --> 00:38:25,880
where the attackers were able to literally withdraw

509
00:38:25,880 --> 00:38:27,040
$150 million.

510
00:38:32,040 --> 00:38:33,600
So what's going wrong?

511
00:38:33,600 --> 00:38:36,920
Once again, we have this implied invariant

512
00:38:36,920 --> 00:38:40,880
that at all times, the balance for a user

513
00:38:40,880 --> 00:38:46,140
matches the actual money that they are owed.

514
00:38:46,140 --> 00:38:50,760
And we're trying to approximate that by saying, if no error,

515
00:38:50,760 --> 00:38:53,200
throw, and then withdraw.

516
00:38:53,200 --> 00:38:57,480
But because that's not atomic, we don't actually

517
00:38:57,480 --> 00:39:01,160
have that invariant for the two lines of code

518
00:39:01,160 --> 00:39:02,120
that it really matters.

519
00:39:06,200 --> 00:39:09,360
So just like in the MyList example,

520
00:39:09,360 --> 00:39:13,900
we are temporarily invalidating our invariant

521
00:39:13,900 --> 00:39:15,960
while our function is running.

522
00:39:15,960 --> 00:39:19,520
Once we've finished running, our invariant's back and restored,

523
00:39:19,520 --> 00:39:22,760
and we're fine, unless somebody was able to exploit it

524
00:39:22,760 --> 00:39:23,720
in the meantime.

525
00:39:32,480 --> 00:39:38,280
So atomic to the rescue?

526
00:39:43,280 --> 00:39:46,620
Can we just wrap all of our code in mutexes

527
00:39:46,620 --> 00:39:53,100
and basically check, lock this piece, unlock this piece?

528
00:39:53,100 --> 00:39:54,820
The idea here would be to take learnings

529
00:39:54,820 --> 00:39:56,700
from databases or operating systems

530
00:39:56,700 --> 00:39:59,660
where we do this all the time.

531
00:39:59,660 --> 00:40:03,740
And maybe atomic actions will fix this.

532
00:40:03,740 --> 00:40:06,460
But not quite.

533
00:40:06,460 --> 00:40:11,460
So Uber published a lengthy blog post

534
00:40:11,460 --> 00:40:13,420
roughly talking about all of this.

535
00:40:13,420 --> 00:40:15,460
Uber does a ton of their development

536
00:40:15,460 --> 00:40:20,280
in the language Golang, which is very similar to C,

537
00:40:20,280 --> 00:40:24,900
but has a lot better guarantees, generally.

538
00:40:24,900 --> 00:40:27,780
And what we're doing here is we want to take,

539
00:40:27,780 --> 00:40:30,460
we can think of it very similar.

540
00:40:30,460 --> 00:40:32,180
The square brackets are lists.

541
00:40:32,180 --> 00:40:34,980
Effectively, they're called slices in Go.

542
00:40:34,980 --> 00:40:35,580
No big deal.

543
00:40:35,580 --> 00:40:37,220
They're basically just lists.

544
00:40:37,220 --> 00:40:39,160
So we have a list of strings.

545
00:40:39,160 --> 00:40:41,900
And then we have a safe append function.

546
00:40:41,900 --> 00:40:46,100
And that function is going to lock our,

547
00:40:46,100 --> 00:40:51,860
set our locks so that we can update the my results slice,

548
00:40:51,860 --> 00:40:54,540
which is technically, or it's technically a slice,

549
00:40:54,540 --> 00:40:55,980
but it looks like a list.

550
00:40:55,980 --> 00:41:02,700
So we're only going to write to our list with the lock.

551
00:41:02,700 --> 00:41:05,660
And then we can set up multiple threads.

552
00:41:05,660 --> 00:41:07,540
One of the amazing things about Go

553
00:41:07,540 --> 00:41:10,800
is that you can just say Go function,

554
00:41:10,800 --> 00:41:12,560
and then it will spin up a thread

555
00:41:12,560 --> 00:41:16,280
to run that function for you asynchronously.

556
00:41:16,280 --> 00:41:22,320
So we can set 10 threads going all at once to take our string

557
00:41:22,320 --> 00:41:29,680
and split it up and append it to our list of strings.

558
00:41:29,680 --> 00:41:32,840
But what's going to go wrong is that even though we only

559
00:41:32,840 --> 00:41:36,640
can write one at a time to safe atomic,

560
00:41:36,640 --> 00:41:40,120
we can read concurrently.

561
00:41:40,120 --> 00:41:44,040
And so we might be halfway through a write

562
00:41:44,040 --> 00:41:46,000
and then start reading.

563
00:41:46,000 --> 00:41:48,800
And because we've only written half of the content,

564
00:41:48,800 --> 00:41:51,800
we might not have copied the correct length,

565
00:41:51,800 --> 00:41:55,040
or we might not have grabbed the entire list.

566
00:41:55,040 --> 00:41:58,120
Any number of things could go wrong.

567
00:41:58,120 --> 00:42:01,920
So when we do the read right here,

568
00:42:01,920 --> 00:42:07,840
and we request my results, this is undetermined.

569
00:42:07,840 --> 00:42:12,160
It could be any value within reason.

570
00:42:15,480 --> 00:42:18,360
So maybe what we could do is we could wrap literally everything

571
00:42:18,360 --> 00:42:22,000
in mutexes, but now we're in single-threaded land,

572
00:42:22,000 --> 00:42:25,760
and that kind of sucks for its own reasons.

573
00:42:25,760 --> 00:42:27,560
Nobody wants to write single-threaded code.

574
00:42:27,560 --> 00:42:32,120
It's super slow, especially with the death of Moore's law.

575
00:42:32,120 --> 00:42:37,200
So the shared issue here, we have

576
00:42:37,200 --> 00:42:43,600
this idea of invariance being violated repeatedly

577
00:42:43,600 --> 00:42:47,480
to multiple aliased references.

578
00:42:47,480 --> 00:42:50,960
Aliasing means we have multiple references to the same memory.

579
00:42:50,960 --> 00:42:53,960
Here, we have multiple references of my results

580
00:42:53,960 --> 00:42:55,520
up here and in the append.

581
00:42:55,520 --> 00:43:02,440
In this place, we have multiple references

582
00:43:02,440 --> 00:43:09,520
to the actual balances feature that stores our information.

583
00:43:09,520 --> 00:43:14,560
And the last one, we have multiple references

584
00:43:14,560 --> 00:43:20,040
to our length, or to our array, which has the length variable.

585
00:43:20,040 --> 00:43:24,800
So we have aliases of the same important memory.

586
00:43:24,800 --> 00:43:25,800
Question?

587
00:43:25,800 --> 00:43:27,800
Yeah, this might not be relevant,

588
00:43:27,800 --> 00:43:32,780
but regarding the mutex and any distributed system,

589
00:43:32,780 --> 00:43:35,280
how does a mutex work with something

590
00:43:35,280 --> 00:43:39,720
that's like a blockchain distributed system?

591
00:43:39,720 --> 00:43:41,280
Oh, it certainly wouldn't.

592
00:43:41,280 --> 00:43:43,760
So you can't do, like, mutexes as far as possible

593
00:43:43,760 --> 00:43:44,960
to contribute it?

594
00:43:44,960 --> 00:43:52,920
So mutex needs to operate at the underlying level for it to work.

595
00:43:52,920 --> 00:43:57,240
You need to have some sort of supervisor saying,

596
00:43:57,240 --> 00:44:00,160
lock this thing, and then unlock this thing.

597
00:44:00,160 --> 00:44:03,000
And if you don't have something like that, it's not going to work.

598
00:44:03,000 --> 00:44:05,880
If you could build that into your chain,

599
00:44:05,880 --> 00:44:07,920
you could make something like it work.

600
00:44:07,920 --> 00:44:10,480
But by default in ETH, you'd probably

601
00:44:10,480 --> 00:44:11,840
have some trouble with that.

602
00:44:19,720 --> 00:44:21,840
All right, lots of things.

603
00:44:21,840 --> 00:44:28,880
All right, so our invariants have been violated by multiple.

604
00:44:28,880 --> 00:44:30,640
Did I say inviolated?

605
00:44:30,640 --> 00:44:35,440
Invariants are violated by multiple aliased references.

606
00:44:35,440 --> 00:44:39,480
An alias is when we have multiple references to the same memory.

607
00:44:45,000 --> 00:44:47,560
Let's try and fix that.

608
00:44:47,560 --> 00:44:50,840
So to the original title of the blog post,

609
00:44:50,840 --> 00:44:56,160
solving the next or fixing the next 10,000 aliasing bugs,

610
00:44:56,160 --> 00:44:57,040
or whatever it was.

611
00:44:59,680 --> 00:45:02,560
The author makes the point that this is not new.

612
00:45:02,560 --> 00:45:05,880
Tony Hoare gave a presentation about 10 years ago

613
00:45:05,880 --> 00:45:09,080
called Null References, the Billion Dollar Mistake,

614
00:45:09,080 --> 00:45:11,720
where he talks about, in ALGOL, the language

615
00:45:11,720 --> 00:45:13,880
that he developed in the 60s, he included

616
00:45:13,880 --> 00:45:16,420
the idea of a null reference.

617
00:45:16,420 --> 00:45:18,680
And every other language since then

618
00:45:18,680 --> 00:45:21,400
has said, null is a good idea.

619
00:45:21,400 --> 00:45:23,680
Let's also have null.

620
00:45:23,680 --> 00:45:28,040
But how many bugs come up because of null?

621
00:45:28,040 --> 00:45:30,360
Maybe a billion dollars worth of bugs.

622
00:45:30,360 --> 00:45:31,000
Maybe more.

623
00:45:31,000 --> 00:45:33,960
Maybe it's even crazier.

624
00:45:33,960 --> 00:45:36,600
So over the last 20 years, people

625
00:45:36,600 --> 00:45:40,560
have started saying, how can we fix null pointers?

626
00:45:40,560 --> 00:45:45,920
The issue fundamentally is that every variable can be null.

627
00:45:45,920 --> 00:45:48,280
Developers then have what options?

628
00:45:48,280 --> 00:45:51,480
What can a developer do to handle null?

629
00:45:51,480 --> 00:45:53,440
You're writing C code.

630
00:45:53,440 --> 00:45:56,360
What do you do when you're worried

631
00:45:56,360 --> 00:45:57,760
about this sort of stuff?

632
00:45:57,760 --> 00:46:00,400
Yeah.

633
00:46:00,400 --> 00:46:01,860
Put if statements everywhere.

634
00:46:01,860 --> 00:46:03,200
That is the first one.

635
00:46:03,200 --> 00:46:03,840
Excellent.

636
00:46:03,840 --> 00:46:05,000
Good order.

637
00:46:05,000 --> 00:46:09,600
We can always do a null check and say, if the thing is null,

638
00:46:09,600 --> 00:46:10,120
do this.

639
00:46:10,120 --> 00:46:12,600
Otherwise, do whatever else.

640
00:46:12,600 --> 00:46:15,360
What else can we do?

641
00:46:15,360 --> 00:46:17,440
Yeah.

642
00:46:17,440 --> 00:46:21,000
We can use union types in C.

643
00:46:21,000 --> 00:46:22,960
OK, I haven't used union types in C.

644
00:46:22,960 --> 00:46:26,040
In other languages, definitely.

645
00:46:26,040 --> 00:46:28,160
And that's what I will talk about on the next slide.

646
00:46:31,080 --> 00:46:31,880
What else can we do?

647
00:46:31,880 --> 00:46:32,380
Yeah.

648
00:46:32,380 --> 00:46:34,440
Exception handling.

649
00:46:34,440 --> 00:46:37,680
C doesn't have exceptions.

650
00:46:37,680 --> 00:46:39,200
Right?

651
00:46:39,200 --> 00:46:39,700
Am I wrong?

652
00:46:39,700 --> 00:46:40,960
New versions of C might.

653
00:46:40,960 --> 00:46:42,880
I don't think C has exceptions.

654
00:46:42,880 --> 00:46:45,680
But in other languages, we have exception handling.

655
00:46:45,680 --> 00:46:47,360
We can capture null pointers.

656
00:46:47,360 --> 00:46:47,860
Sure.

657
00:46:53,160 --> 00:46:59,760
We can also just be very careful and try not to mess up.

658
00:46:59,760 --> 00:47:03,080
And I would say the last option is segfile.

659
00:47:07,440 --> 00:47:11,340
But these are antiquated ideas.

660
00:47:11,340 --> 00:47:13,840
You should not have to do any one of these.

661
00:47:13,840 --> 00:47:15,600
You shouldn't have to do null checks.

662
00:47:15,600 --> 00:47:17,320
You shouldn't have to be very careful.

663
00:47:17,320 --> 00:47:19,480
And you shouldn't be segfaulting.

664
00:47:19,480 --> 00:47:21,280
And instead, what we should do is

665
00:47:21,280 --> 00:47:23,360
we should fix it at the language level

666
00:47:23,360 --> 00:47:27,640
with things like union types, which I guess are in C,

667
00:47:27,640 --> 00:47:30,000
but are only more recently in C for sure.

668
00:47:33,040 --> 00:47:34,160
Either way.

669
00:47:34,160 --> 00:47:36,880
But a ton of other languages have this idea

670
00:47:36,880 --> 00:47:42,040
that things, you can tag them as either being never null

671
00:47:42,040 --> 00:47:45,200
or possibly null.

672
00:47:45,200 --> 00:47:46,880
So you have something like TypeScript,

673
00:47:46,880 --> 00:47:48,640
where you put this little question mark

674
00:47:48,640 --> 00:47:50,360
after your variable name.

675
00:47:50,360 --> 00:47:53,400
And what you're saying there is, this thing is a number, maybe.

676
00:47:53,400 --> 00:47:55,040
It also might be null.

677
00:47:55,040 --> 00:47:58,720
And whenever you use it, you should check to see is it null.

678
00:47:58,720 --> 00:48:00,640
But if it doesn't have a question mark,

679
00:48:00,640 --> 00:48:05,680
the name property is never null.

680
00:48:05,680 --> 00:48:07,680
And you never have to worry that that thing

681
00:48:07,680 --> 00:48:11,180
might be uninitialized.

682
00:48:11,180 --> 00:48:12,760
So a bunch of languages are doing this.

683
00:48:12,760 --> 00:48:13,560
TypeScript does it.

684
00:48:13,560 --> 00:48:16,000
You can do front-end or back-end dev with that.

685
00:48:16,000 --> 00:48:16,920
Rust does it.

686
00:48:16,920 --> 00:48:18,440
You can do systems dev with that.

687
00:48:18,440 --> 00:48:19,160
Swift does it.

688
00:48:19,160 --> 00:48:21,120
You can write iOS apps with that.

689
00:48:21,120 --> 00:48:22,240
Kotlin does it.

690
00:48:22,240 --> 00:48:23,760
I don't know if anybody uses Kotlin.

691
00:48:26,360 --> 00:48:28,280
So that's null pointers that have been

692
00:48:28,280 --> 00:48:30,200
addressed at the compiler level.

693
00:48:30,200 --> 00:48:33,100
These languages now solve this problem for you.

694
00:48:33,100 --> 00:48:37,140
When you accidentally use a possibly null value

695
00:48:37,140 --> 00:48:40,080
and don't check if it's null, the compiler

696
00:48:40,080 --> 00:48:42,160
will tell you that's an error.

697
00:48:42,160 --> 00:48:42,680
Don't do that.

698
00:48:46,160 --> 00:48:48,160
Can we treat aliasing the same way?

699
00:48:48,160 --> 00:48:48,660
Oh, yeah.

700
00:48:48,660 --> 00:48:49,160
Yeah.

701
00:48:49,160 --> 00:48:56,040
So in SQL, I think they have something like some.

702
00:48:56,040 --> 00:48:59,080
Oh, SQL's a nightmare with null.

703
00:48:59,080 --> 00:49:01,480
Yeah, but no, it's interesting.

704
00:49:01,480 --> 00:49:08,240
SQL has null, but it also has empty and other very weird

705
00:49:08,240 --> 00:49:10,400
states that it can be in.

706
00:49:10,400 --> 00:49:12,360
But it also depends on the variant in SQL.

707
00:49:12,360 --> 00:49:16,840
So SQL has some null handling, but then it also

708
00:49:16,840 --> 00:49:21,120
has some not null handling that gets into issues.

709
00:49:25,800 --> 00:49:29,240
Other questions or ideas about null pointers?

710
00:49:36,000 --> 00:49:36,500
Yeah.

711
00:49:41,400 --> 00:49:44,880
Why are null pointers bad?

712
00:49:44,880 --> 00:49:49,360
Why are null pointers good and bad?

713
00:49:49,360 --> 00:49:52,840
Sometimes, they're useful, but not always.

714
00:49:52,840 --> 00:49:54,320
They have some use, right?

715
00:49:54,320 --> 00:49:55,800
Sometimes, they're not.

716
00:49:55,800 --> 00:49:58,280
Sometimes, they're not always.

717
00:49:58,280 --> 00:50:00,240
Sometimes, they're not always.

718
00:50:00,240 --> 00:50:00,920
Yeah.

719
00:50:00,920 --> 00:50:03,680
So why are null pointers bad?

720
00:50:03,680 --> 00:50:07,480
And I think that's, to some extent,

721
00:50:07,480 --> 00:50:10,600
a philosophical question.

722
00:50:10,600 --> 00:50:13,000
Should you ever use a null pointer?

723
00:50:13,000 --> 00:50:20,040
But it's also very much just an engineering problem.

724
00:50:20,040 --> 00:50:25,640
When you are trying to learn C, you run into a lot of segfaults.

725
00:50:25,640 --> 00:50:27,720
When you are trying to learn JavaScript,

726
00:50:27,720 --> 00:50:31,480
you run into a lot of undefined is not a function.

727
00:50:31,480 --> 00:50:35,440
You guys have probably hit that one a lot in this class.

728
00:50:35,440 --> 00:50:39,200
When you try and learn a language like Python, though,

729
00:50:39,200 --> 00:50:43,920
I guess you also still get none can't be used like that.

730
00:50:43,920 --> 00:50:48,440
But you can't ever call a non-function.

731
00:50:48,440 --> 00:50:51,800
You can't ever reference something and use something

732
00:50:51,800 --> 00:50:54,280
if it's a null pointer.

733
00:50:54,280 --> 00:50:57,760
You're not getting segfaults.

734
00:50:57,760 --> 00:51:00,760
Or if you're in TypeScript, even better,

735
00:51:00,760 --> 00:51:04,320
you're being forced to handle null.

736
00:51:04,320 --> 00:51:06,640
So it's not that you don't have null.

737
00:51:06,640 --> 00:51:10,000
It's that you only have to think about it on the things

738
00:51:10,000 --> 00:51:11,400
where it's relevant.

739
00:51:11,400 --> 00:51:13,960
I can still initialize my thing to be empty.

740
00:51:13,960 --> 00:51:16,120
But in doing so, I have to specify

741
00:51:16,120 --> 00:51:19,880
that it can be empty, which means everybody else knows

742
00:51:19,880 --> 00:51:21,560
that's potentially empty.

743
00:51:21,560 --> 00:51:23,880
But not everything is empty.

744
00:51:23,880 --> 00:51:26,080
Name is always going to be a string.

745
00:51:26,080 --> 00:51:27,840
And I never have to put an if statement

746
00:51:27,840 --> 00:51:30,960
to check, is name undefined?

747
00:51:35,320 --> 00:51:41,800
Which leads to cleaner code, and it leads to fewer mistakes.

748
00:51:41,800 --> 00:51:43,800
Fewer bugs.

749
00:51:48,240 --> 00:51:50,200
Cool.

750
00:51:50,200 --> 00:51:52,080
So what can we do about aliasing?

751
00:51:52,080 --> 00:51:57,000
Because we found this issue that aliasing presents bugs

752
00:51:57,000 --> 00:51:58,400
in our code as well.

753
00:51:58,400 --> 00:51:59,800
It's not just null pointers.

754
00:51:59,800 --> 00:52:02,480
It's aliasing, too.

755
00:52:03,320 --> 00:52:06,440
Well, inherently, in most languages,

756
00:52:06,440 --> 00:52:09,960
every reference is implicitly aliasable.

757
00:52:09,960 --> 00:52:18,280
We can always say x equals y and create an alias of y with x

758
00:52:18,280 --> 00:52:22,280
so that x and y both point to the same thing.

759
00:52:22,280 --> 00:52:27,280
No language outside of the one that we're about to discuss

760
00:52:27,280 --> 00:52:29,280
prevents you from being able to do that.

761
00:52:32,600 --> 00:52:35,760
What this means is that what developers

762
00:52:35,760 --> 00:52:39,120
can do to prevent aliasing is what?

763
00:52:39,120 --> 00:52:42,840
How can we stop aliasing bugs, such as the ones

764
00:52:42,840 --> 00:52:43,680
that we've just seen?

765
00:52:44,680 --> 00:52:45,160
Yeah?

766
00:52:57,080 --> 00:52:59,560
If we only have an immutable copy of something,

767
00:52:59,560 --> 00:53:04,640
wouldn't that, like, start to do, like, a bad thing?

768
00:53:04,640 --> 00:53:08,280
If we only have an immutable copy,

769
00:53:08,280 --> 00:53:11,560
what would stop me from saying x equals y?

770
00:53:12,240 --> 00:53:16,520
It's best practice to say x equals set y.

771
00:53:16,520 --> 00:53:22,880
Yeah, so I think that definitely gets to the right idea.

772
00:53:22,880 --> 00:53:24,400
Have you written Rust?

773
00:53:24,400 --> 00:53:25,840
Yeah, OK.

774
00:53:25,840 --> 00:53:32,000
So in JavaScript, we started using the immutable list

775
00:53:32,000 --> 00:53:35,560
library, where we couldn't update any of the variables.

776
00:53:35,560 --> 00:53:38,680
But that didn't actually stop us from having two references

777
00:53:38,680 --> 00:53:40,000
to those immutable lists.

778
00:53:40,000 --> 00:53:42,680
So there's nothing inherent in immutability

779
00:53:42,680 --> 00:53:46,480
that says we can't have multiple references, which

780
00:53:46,480 --> 00:53:50,280
is why there's nothing here.

781
00:53:50,280 --> 00:53:54,040
There's not really any way for the developer

782
00:53:54,040 --> 00:53:58,080
to prevent aliasing of memory that they think

783
00:53:58,080 --> 00:54:00,880
that they exclusively own.

784
00:54:00,880 --> 00:54:05,200
Because maybe somebody else is also copying it.

785
00:54:05,200 --> 00:54:08,920
But what if we were able to create a fixed language where

786
00:54:08,920 --> 00:54:13,480
we can flag references as being exclusive,

787
00:54:13,480 --> 00:54:16,480
meaning they have no aliasing allowed,

788
00:54:16,480 --> 00:54:19,160
or they could be shared, which means

789
00:54:19,160 --> 00:54:22,320
they can be aliased as normal.

790
00:54:22,320 --> 00:54:24,480
So shared memory, shared references

791
00:54:24,480 --> 00:54:28,960
would be just like every other variable you've ever used.

792
00:54:28,960 --> 00:54:32,480
Exclusive references, you would not

793
00:54:32,480 --> 00:54:36,400
be able to have two pointers to that same memory.

794
00:54:36,400 --> 00:54:40,960
So for example, we might say foo is an exclusive XCL,

795
00:54:40,960 --> 00:54:43,800
exclusive new foo.

796
00:54:43,800 --> 00:54:46,040
And then if we tried to say bar is

797
00:54:46,040 --> 00:54:50,280
equal to foo, which would create two references to that memory,

798
00:54:50,280 --> 00:54:52,280
we would get a compile error.

799
00:54:52,280 --> 00:54:54,800
Well, I guess we'd get a compile error here

800
00:54:54,800 --> 00:54:56,560
when we tried to use foo.

801
00:54:56,560 --> 00:54:59,080
Because foo is no longer a reference to our thing,

802
00:54:59,080 --> 00:55:01,120
we've transferred the reference.

803
00:55:02,120 --> 00:55:07,960
So what we're doing is we're adding a new alias type

804
00:55:07,960 --> 00:55:10,480
modifier to all of our variables.

805
00:55:10,480 --> 00:55:16,560
Our variables are now either shared or they're exclusive.

806
00:55:16,560 --> 00:55:20,080
And we can use the compiler to perform type inference

807
00:55:20,080 --> 00:55:25,920
on our code and say, are we misusing exclusive pointers

808
00:55:25,920 --> 00:55:29,740
or misusing shared pointers in any of our places?

809
00:55:29,740 --> 00:55:32,660
We will run type inference and type checking

810
00:55:32,660 --> 00:55:34,500
to find those sorts of bugs.

811
00:55:37,980 --> 00:55:43,180
So if we wrote a slightly larger function, increment,

812
00:55:43,180 --> 00:55:47,860
it could take a parameter x, which is exclusive.

813
00:55:47,860 --> 00:55:52,440
So x is an exclusive non-zero number.

814
00:55:52,440 --> 00:55:54,660
Then we could convert it to an int.

815
00:55:54,660 --> 00:55:56,220
We could increment it.

816
00:55:56,220 --> 00:55:57,660
We can do whatever we want.

817
00:55:57,660 --> 00:56:03,620
Anything inside of our increment function,

818
00:56:03,620 --> 00:56:06,420
we have exclusive control over x.

819
00:56:06,420 --> 00:56:10,900
Nobody else is going to be updating x.

820
00:56:10,900 --> 00:56:14,180
And the compiler will tell us that based on the types

821
00:56:14,180 --> 00:56:18,180
that we've annotated the rest of our code with.

822
00:56:18,180 --> 00:56:23,100
So the xcl flag guarantees that no one else

823
00:56:23,100 --> 00:56:24,500
is accessing the variable.

824
00:56:24,500 --> 00:56:28,400
And we can safely invalidate our invariants.

825
00:56:28,400 --> 00:56:32,900
If we had something like this in Solidity or in Java

826
00:56:32,900 --> 00:56:36,200
or, what was the other one, in Go,

827
00:56:36,200 --> 00:56:40,540
we could prevent the errors that we were seeing before.

828
00:56:40,540 --> 00:56:45,460
And the reveal of all of this is that this

829
00:56:45,460 --> 00:56:48,300
isn't some crazy new concept.

830
00:56:48,300 --> 00:56:53,500
This is what Rust does with its borrow checker.

831
00:56:53,500 --> 00:56:55,760
Rust checks to make sure that you're

832
00:56:55,760 --> 00:56:58,540
treating your exclusive variables as exclusive

833
00:56:58,540 --> 00:57:01,700
and your shared variables as shared.

834
00:57:01,700 --> 00:57:04,620
And so it has the borrow checker,

835
00:57:04,620 --> 00:57:06,420
not just for memory management.

836
00:57:06,420 --> 00:57:08,260
It also does aliasing.

837
00:57:11,140 --> 00:57:13,140
All right.

838
00:57:13,140 --> 00:57:16,020
Questions on any of those last slides?

839
00:57:16,020 --> 00:57:18,780
Borrow checker, Rust, things of this nature, exclusive?

840
00:57:18,940 --> 00:57:23,660
Even with that fix in Rust, to go back to the dowel example,

841
00:57:23,660 --> 00:57:28,380
that doesn't fix that issue, does it?

842
00:57:28,380 --> 00:57:31,980
In the exact solution, does it?

843
00:57:31,980 --> 00:57:36,100
Because that's a problem with parallel operations

844
00:57:36,100 --> 00:57:39,780
on not one central piece.

845
00:57:39,780 --> 00:57:40,260
Right.

846
00:57:40,260 --> 00:57:42,660
So you would need your underlying system

847
00:57:42,660 --> 00:57:46,980
to be written in Rust and to have these sorts of things

848
00:57:47,020 --> 00:57:50,500
be part of your exclusive memory.

849
00:57:50,500 --> 00:57:53,340
So nobody else should be able to access balance

850
00:57:53,340 --> 00:57:56,020
while I am accessing balance.

851
00:57:56,020 --> 00:57:59,260
Inside of this function, where I'm running this,

852
00:57:59,260 --> 00:58:02,500
no one else should be able to run that function while I

853
00:58:02,500 --> 00:58:03,980
am running this function.

854
00:58:03,980 --> 00:58:07,580
And my smart contract, if it were written in Rust,

855
00:58:07,580 --> 00:58:10,980
should prevent other people running the same smart

856
00:58:10,980 --> 00:58:12,620
contract.

857
00:58:12,620 --> 00:58:14,300
Because we're all trying to update.

858
00:58:14,300 --> 00:58:16,500
The issue is that we're updating balances.

859
00:58:16,500 --> 00:58:18,980
We're checking balances and updating balances.

860
00:58:18,980 --> 00:58:23,220
If we make that exclusive, we should be fine.

861
00:58:23,220 --> 00:58:27,660
You can make that exclusive across distributed

862
00:58:27,660 --> 00:58:28,620
and correct?

863
00:58:28,620 --> 00:58:29,120
Right.

864
00:58:29,120 --> 00:58:32,380
How does that component come into play?

865
00:58:32,380 --> 00:58:39,900
So there's, I'm blanking on the term, for consistency.

866
00:58:39,900 --> 00:58:41,940
That is a problem for consistency

867
00:58:41,940 --> 00:58:44,900
of distributed systems.

868
00:58:44,900 --> 00:58:47,940
I mean, the heart of all of crypto stuff

869
00:58:47,940 --> 00:58:52,540
is built on consensus algorithms, such as like Paxos

870
00:58:52,540 --> 00:58:58,860
or what's the cool one?

871
00:58:58,860 --> 00:58:59,940
Blanking on that as well.

872
00:58:59,940 --> 00:59:02,460
It's been too long since I've done distributed.

873
00:59:02,460 --> 00:59:05,180
But there are protocols that allow

874
00:59:05,180 --> 00:59:09,500
you to achieve consistency for your data store, which

875
00:59:09,500 --> 00:59:10,700
is the blockchain.

876
00:59:10,700 --> 00:59:13,200
So the blockchain is always consistent.

877
00:59:13,200 --> 00:59:16,240
So you just need a language on top of it where you can say,

878
00:59:16,240 --> 00:59:18,920
no one should be updating this part of the blockchain

879
00:59:18,920 --> 00:59:20,720
at the same time as me.

880
00:59:20,720 --> 00:59:21,220
Yeah?

881
00:59:21,220 --> 00:59:24,720
So what's the difference between a mutex on balances

882
00:59:24,720 --> 00:59:27,680
versus a reference on mutex on balances?

883
00:59:33,360 --> 00:59:37,080
So the difference between a mutex on balances

884
00:59:37,080 --> 00:59:40,720
here is addressing this at the application level,

885
00:59:40,720 --> 00:59:46,440
where I'm saying, no one can be running inside of my scope

886
00:59:46,440 --> 00:59:48,080
this same stuff.

887
00:59:48,080 --> 00:59:51,920
You would want a mutex for the entire protocol,

888
00:59:51,920 --> 00:59:55,480
for the entire blockchain, to do that.

889
00:59:55,480 --> 00:59:58,900
And that would be probably prohibitively slow

890
00:59:58,900 --> 00:59:59,840
on the chain.

891
00:59:59,840 --> 01:00:01,720
Because you'd say, no one else can, like,

892
01:00:01,720 --> 01:00:06,240
operate on the chain while I am operating on the chain.

893
01:00:06,240 --> 01:00:07,080
Does that make sense?

894
01:00:07,080 --> 01:00:07,580
Yeah.

895
01:00:07,580 --> 01:00:10,440
What is the reference on the reference here?

896
01:00:10,440 --> 01:00:13,340
I'm not quite sure how you would bring in the exclusive reference

897
01:00:13,340 --> 01:00:13,840
here.

898
01:00:13,840 --> 01:00:17,380
But it would have to be at a more fundamental layer

899
01:00:17,380 --> 01:00:18,320
than this piece.

900
01:00:18,320 --> 01:00:18,820
Yeah.

901
01:00:18,820 --> 01:00:20,280
I don't know what the reference is.

902
01:00:20,280 --> 01:00:22,140
I don't know what the reference is in that.

903
01:00:22,140 --> 01:00:24,800
But I think it's similar to the reference

904
01:00:24,800 --> 01:00:27,500
that was used for graphing the data.

905
01:00:27,500 --> 01:00:28,000
No.

906
01:00:28,000 --> 01:00:34,420
So this is part of the language.

907
01:00:34,420 --> 01:00:36,840
This is a new feature for the language

908
01:00:36,880 --> 01:00:39,240
that the compiler is going to be enforcing.

909
01:00:39,240 --> 01:00:42,960
There's no actual runtime implication of exclusive.

910
01:00:42,960 --> 01:00:44,880
Oh, OK.

911
01:00:44,880 --> 01:00:47,840
This is a piece that's saying, I'm going to check your code

912
01:00:47,840 --> 01:00:50,800
and make sure no one else can operate on this thing

913
01:00:50,800 --> 01:00:54,240
while you are operating on this thing.

914
01:00:54,240 --> 01:01:00,400
Here, with mutexes, we have very much runtime implication,

915
01:01:00,400 --> 01:01:02,520
and checks, and stuff of that sort.

916
01:01:02,520 --> 01:01:05,280
So you still want to have mutexes in a world

917
01:01:05,280 --> 01:01:08,880
where you'd have exclusive references.

918
01:01:08,880 --> 01:01:10,560
I could see that still playing a part.

919
01:01:19,800 --> 01:01:21,040
Other questions?

920
01:01:28,000 --> 01:01:28,500
Yeah.

921
01:01:28,500 --> 01:01:30,120
If you're not writing in Rust, you're

922
01:01:30,120 --> 01:01:32,680
risking that problem?

923
01:01:32,680 --> 01:01:34,400
Even if you're writing in Rust, sometimes

924
01:01:34,400 --> 01:01:36,840
you're risking that problem.

925
01:01:36,840 --> 01:01:37,340
But yeah.

926
01:01:37,340 --> 01:01:37,840
No.

927
01:01:37,840 --> 01:01:40,440
I mean, actually, while we're on this slide,

928
01:01:40,440 --> 01:01:43,840
this is a reasonable piece of Go code,

929
01:01:43,840 --> 01:01:47,480
where the whole point of me writing code in Go

930
01:01:47,480 --> 01:01:52,680
is because I want to distribute all of my tasks concurrently

931
01:01:52,680 --> 01:01:55,720
and just say, everyone go do this thing,

932
01:01:55,720 --> 01:01:57,880
and come back and tell me once it's done.

933
01:01:57,880 --> 01:02:00,520
So the idea of writing a for loop,

934
01:02:00,520 --> 01:02:03,560
where I'm running a bunch of threads

935
01:02:03,560 --> 01:02:07,920
in parallel across some shared memory,

936
01:02:07,920 --> 01:02:11,240
that probably happens all the time.

937
01:02:11,240 --> 01:02:14,440
And you would run into, potentially, this problem,

938
01:02:14,440 --> 01:02:18,480
even if you're trying to solve it with mutexes.

939
01:02:18,480 --> 01:02:19,980
Yeah.

940
01:02:19,980 --> 01:02:21,940
Do you get the couple when you do the product?

941
01:02:21,940 --> 01:02:24,000
Like, are you doing the product?

942
01:02:24,000 --> 01:02:26,080
But then, do you get any parallelism?

943
01:02:26,960 --> 01:02:31,920
Like, you don't get any benefit of all of the cores

944
01:02:31,920 --> 01:02:36,160
on your CPU, if you put read-write locks everywhere

945
01:02:36,160 --> 01:02:38,160
on here.

946
01:02:38,160 --> 01:02:39,880
But yeah, you can.

947
01:02:39,880 --> 01:02:41,360
It's just then you kind of lose out.

948
01:02:46,000 --> 01:02:46,500
Yeah.

949
01:02:46,660 --> 01:02:50,140
So what's it exactly like that I'm going to use the mute?

950
01:02:50,140 --> 01:02:52,580
Like, if you were in Rust, is that

951
01:02:52,580 --> 01:02:54,500
the type-checking you're doing when you're doing

952
01:02:54,500 --> 01:02:57,140
do-able registers and non-do-able registers?

953
01:02:57,140 --> 01:03:01,460
Or is there something else that you're not doing?

954
01:03:01,460 --> 01:03:10,940
So in Rust, if we say, let x equal mem,

955
01:03:10,940 --> 01:03:13,940
we allocate some space on the heap.

956
01:03:13,940 --> 01:03:15,780
We say x is equal to that mem.

957
01:03:15,820 --> 01:03:19,140
And then we say y equal x, or let y equal x.

958
01:03:22,740 --> 01:03:25,900
Then we try to access y.

959
01:03:25,900 --> 01:03:26,860
We're good to go.

960
01:03:26,860 --> 01:03:29,300
If we try to access x, all right,

961
01:03:29,300 --> 01:03:32,140
I've chosen a poor letter, we are not good to go.

962
01:03:32,140 --> 01:03:34,460
We run into an issue.

963
01:03:34,460 --> 01:03:37,140
And this is a compile issue that says, hey,

964
01:03:37,140 --> 01:03:40,260
you don't have access to x anymore.

965
01:03:40,260 --> 01:03:43,940
And that's just the default behavior.

966
01:03:43,940 --> 01:03:47,780
That's what the borrow checker will ensure for any memory

967
01:03:47,780 --> 01:03:50,460
that you create.

968
01:03:50,460 --> 01:03:53,180
Then you can create mutable references and stuff

969
01:03:53,180 --> 01:03:54,420
on top of that.

970
01:03:54,420 --> 01:03:58,140
But that's kind of a layer above.

971
01:04:00,860 --> 01:04:05,020
We will all start working on Rust quite soon.

972
01:04:05,020 --> 01:04:06,580
I think PA6.

973
01:04:06,580 --> 01:04:11,980
So it'll be in two weeks, or two weeks after spring break,

974
01:04:11,980 --> 01:04:13,700
where you'll write your first Rust code,

975
01:04:13,700 --> 01:04:14,620
if you haven't before.

976
01:04:17,700 --> 01:04:19,820
With some intro to it, so don't worry too much.

977
01:04:23,260 --> 01:04:24,540
Any other questions?

978
01:04:24,540 --> 01:04:25,540
Yeah?

979
01:04:25,540 --> 01:04:28,020
But this way, you're kind of pushing the problem

980
01:04:28,020 --> 01:04:29,980
to the compiler side.

981
01:04:29,980 --> 01:04:32,460
So you probably have a lot of errors

982
01:04:32,460 --> 01:04:34,940
showing up about concurrency issues,

983
01:04:34,940 --> 01:04:37,220
what you do to it in general.

984
01:04:37,220 --> 01:04:38,180
Definitely.

985
01:04:38,180 --> 01:04:41,180
This is now the compiler's job to tell you

986
01:04:41,180 --> 01:04:42,980
when you are right and wrong.

987
01:04:42,980 --> 01:04:45,140
And just like comparing JavaScript

988
01:04:45,140 --> 01:04:50,260
to a language like Java, with types,

989
01:04:50,260 --> 01:04:55,180
sometimes JavaScript works, even though the types are weird.

990
01:04:55,180 --> 01:04:59,100
And you're trying to call an integer

991
01:04:59,100 --> 01:05:00,300
as though it were a function.

992
01:05:00,300 --> 01:05:03,180
So long as you never use that piece of code,

993
01:05:03,180 --> 01:05:05,260
it's not going to crash.

994
01:05:05,260 --> 01:05:07,700
But Java would say, hey, that's a type error.

995
01:05:07,700 --> 01:05:10,180
You can't do that.

996
01:05:10,180 --> 01:05:13,460
Here, Rust is going to give you compile errors

997
01:05:13,460 --> 01:05:15,500
for all of the places where you're doing something

998
01:05:15,500 --> 01:05:17,780
potentially wrong, even if it wouldn't have caused

999
01:05:17,780 --> 01:05:19,620
a problem in the first place.

1000
01:05:19,620 --> 01:05:22,020
So it's more restrictive.

1001
01:05:22,020 --> 01:05:28,100
But as a result, it's always safe,

1002
01:05:28,100 --> 01:05:31,100
unless you specifically say unsafe.

1003
01:05:31,100 --> 01:05:32,540
Then it's not always safe.

1004
01:05:32,540 --> 01:05:36,020
Yeah?

1005
01:05:36,020 --> 01:05:39,020
So is it like, at compile time, I

1006
01:05:39,020 --> 01:05:42,500
should be able to figure out how should I

1007
01:05:42,500 --> 01:05:45,980
access the concurrency as a shared memory?

1008
01:05:45,980 --> 01:05:50,980
Rather than dedicate that problem to the compile time,

1009
01:05:50,980 --> 01:05:53,980
where if I don't, I don't need it.

1010
01:05:53,980 --> 01:05:54,820
Exactly.

1011
01:05:54,820 --> 01:05:58,100
So the big benefit here is that now we're

1012
01:05:58,100 --> 01:06:00,420
able to do this stuff at compile time.

1013
01:06:00,500 --> 01:06:04,100
And what we are doing is effectively type inference,

1014
01:06:04,100 --> 01:06:06,740
where we're saying, track the type,

1015
01:06:06,740 --> 01:06:11,220
the exclusive or shared type of this variable,

1016
01:06:11,220 --> 01:06:13,100
and infer it as it goes along.

1017
01:06:13,100 --> 01:06:17,180
Anytime we run into a conflict, raise an error.

1018
01:06:17,180 --> 01:06:22,660
So wouldn't that reduce the parallelism even more?

1019
01:06:22,660 --> 01:06:25,140
Because in the new text, it kind of

1020
01:06:25,140 --> 01:06:27,620
allows being optimistic about it.

1021
01:06:27,620 --> 01:06:30,100
And you just let all the threads run.

1022
01:06:30,100 --> 01:06:32,100
And no matter who gets the, yeah,

1023
01:06:32,100 --> 01:06:35,100
you can use runtime checks to do that.

1024
01:06:35,100 --> 01:06:37,100
But at compile time, you're preemptively

1025
01:06:37,100 --> 01:06:44,100
forcing the order of threads getting used to it.

1026
01:06:44,100 --> 01:06:46,020
I think that's a fair argument.

1027
01:06:46,020 --> 01:06:50,820
Is this not potentially slower?

1028
01:06:50,820 --> 01:06:56,660
But counter-argument, right?

1029
01:06:56,660 --> 01:07:00,340
So it is more restrictive in what you can write.

1030
01:07:00,340 --> 01:07:02,660
What that means is either you have to write,

1031
01:07:02,660 --> 01:07:05,460
what you end up is with something slower,

1032
01:07:05,460 --> 01:07:08,300
or you have to write the code correct

1033
01:07:08,300 --> 01:07:11,420
so that it's equally fast, or potentially faster,

1034
01:07:11,420 --> 01:07:14,420
and you're never going to get cycles.

1035
01:07:14,420 --> 01:07:15,340
Yeah.

1036
01:07:15,340 --> 01:07:18,540
But it's maybe harder to write that mid-tier

1037
01:07:18,540 --> 01:07:22,820
where it's fast sometimes, and it crashes sometimes.

1038
01:07:22,820 --> 01:07:25,140
But that's probably a good thing.

1039
01:07:25,140 --> 01:07:26,620
Yeah.

1040
01:07:26,620 --> 01:07:29,580
I'm going back to the slow example.

1041
01:07:29,580 --> 01:07:34,540
Was there a reason for that?

1042
01:07:34,540 --> 01:07:36,500
Or is it all coming down to power?

1043
01:07:36,500 --> 01:07:40,980
Is that the fact that it's high performance?

1044
01:07:40,980 --> 01:07:41,940
Do I have to make it?

1045
01:07:41,940 --> 01:07:45,740
I would have to think about it.

1046
01:07:45,740 --> 01:07:49,060
We can think about it in Office Hours together, if you want.

1047
01:07:49,060 --> 01:07:53,300
If you want to learn more about the piece

1048
01:07:53,300 --> 01:08:00,660
that we were just talking about, considerations on code

1049
01:08:00,660 --> 01:08:03,740
crafting, finding the next 10,000 aliasing bugs.

1050
01:08:03,740 --> 01:08:06,420
I'll post it on Piazza as well, if you want to read it.

1051
01:08:06,420 --> 01:08:11,780
They basically walk through a lot of the same ideas.

1052
01:08:11,780 --> 01:08:15,700
I did not generate all of these ideas myself.

1053
01:08:15,700 --> 01:08:18,820
Mostly I read about them this morning.

1054
01:08:18,820 --> 01:08:21,860
So they go into more about the types,

1055
01:08:21,860 --> 01:08:23,100
if you want to look at that.

1056
01:08:23,900 --> 01:08:28,260
And the idea of permissions with exclusive types.

1057
01:08:28,260 --> 01:08:29,940
Things of this nature.

1058
01:08:29,940 --> 01:08:31,740
All right.

1059
01:08:31,740 --> 01:08:34,620
From there, though, I think we will call it a day.

1060
01:08:34,620 --> 01:08:36,860
Seven minutes early.

1061
01:08:36,860 --> 01:08:39,340
Feel free to drop by Office Hours.

1062
01:08:39,340 --> 01:08:41,700
If you want to write some Python code.

1063
01:08:57,420 --> 01:08:58,820
Yeah, yeah, yeah.

1064
01:08:58,820 --> 01:09:00,620
Let me.

1065
01:17:09,340 --> 01:17:10,900
I'll do it.

1066
01:17:10,900 --> 01:17:12,140
I'll do it.

1067
01:17:12,140 --> 01:17:21,740
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,

1068
01:17:21,740 --> 01:17:28,980
13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,

1069
01:17:28,980 --> 01:17:35,820
26, 27, 28, 29, 30, 31, 32, 33, 34, 34, 35, 36, 37,

1070
01:17:35,940 --> 01:17:45,420
38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,

1071
01:17:45,420 --> 01:17:58,620
52, 53, 54, 55, 56, 57, 58, 59, 60.

1072
01:17:58,620 --> 01:18:14,300
59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 78,

1073
01:18:14,300 --> 01:18:24,060
79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 93, 94, 94, 93, 94,

