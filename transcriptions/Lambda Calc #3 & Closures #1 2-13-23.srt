1
00:00:00,520 --> 00:00:02,520
So please get your laptop, please get your notepads,

2
00:00:03,780 --> 00:00:06,080
please get your laptops, please get your computers, please get

3
00:00:06,080 --> 00:00:08,080
your tablets, please get your pens and paper.

4
00:00:18,160 --> 00:00:20,160
So it's a nice major.

5
00:00:22,360 --> 00:00:24,360
We are trying to make virtual signaling easier on them.

6
00:00:27,300 --> 00:00:29,300
That's where we had helps a lot.

7
00:00:30,100 --> 00:00:32,100
But it wasn't there.

8
00:00:33,820 --> 00:00:35,820
It was more like an ARCO.

9
00:00:38,160 --> 00:00:40,160
It wasn't really that small of a balloon.

10
00:00:45,980 --> 00:00:47,980
But we got it bigger.

11
00:00:49,900 --> 00:00:51,900
And the thing is everything on Panasonic is square.

12
00:00:52,960 --> 00:00:54,960
So we were finally able to do it.

13
00:00:56,980 --> 00:00:58,980
But it took us like two weeks to get it up to here.

14
00:01:00,840 --> 00:01:02,840
All right, folks.

15
00:01:03,720 --> 00:01:05,720
Let's get started.

16
00:01:08,200 --> 00:01:12,080
Our bookkeeping before we begin lecture.

17
00:01:13,400 --> 00:01:18,180
As posted. So solutions for homeworks one and two are posted on Canvas.

18
00:01:18,820 --> 00:01:21,340
Go ahead and check them out. See how you did.

19
00:01:22,020 --> 00:01:24,000
Grading is on the way.

20
00:01:24,000 --> 00:01:28,200
For homework one, we're almost done. For homework two, we'll get there probably this week.

21
00:01:29,200 --> 00:01:37,200
PA3 and homework three are both posted to Canvas. You should have access.

22
00:01:39,200 --> 00:01:42,200
Homework three is primarily JavaScript.

23
00:01:42,200 --> 00:01:47,200
And it will be covered in the end of today's lecture and Wednesday's lecture.

24
00:01:48,200 --> 00:01:50,200
PA3 is entirely JavaScript as well.

25
00:01:50,200 --> 00:01:56,200
So over the course of the next two weeks, we're currently talking about lambda calculus.

26
00:01:56,200 --> 00:01:59,200
We're going to transition back to JavaScript for a little bit.

27
00:01:59,200 --> 00:02:03,200
And then we're going to power through to Haskell next week.

28
00:02:03,200 --> 00:02:07,200
We're going to be covering three pretty different languages in two weeks.

29
00:02:08,200 --> 00:02:12,200
If that feels confusing and hard, stop by office hours.

30
00:02:12,200 --> 00:02:17,200
In particular, Monday is generally light because the homework was just released.

31
00:02:17,200 --> 00:02:23,200
So if you want to chat about not just homework, come to my office hours after class today.

32
00:02:24,200 --> 00:02:25,200
Some general advice.

33
00:02:25,200 --> 00:02:30,200
There are a lot of people posting, my PA tests are failing on Gradescope.

34
00:02:30,200 --> 00:02:33,200
But they pass all of the local tests. What am I doing wrong?

35
00:02:34,200 --> 00:02:36,200
It's not everyone. I recognize that.

36
00:02:36,200 --> 00:02:43,200
But in general, the tests that I give you locally are not a complete test set.

37
00:02:43,200 --> 00:02:48,200
It's an idea to make sure you've written some idea of the correct function.

38
00:02:49,200 --> 00:02:53,200
The goal of Gradescope is to be the exam test.

39
00:02:53,200 --> 00:02:59,200
So you shouldn't be writing your code, submitting to Gradescope, iterating 500 times.

40
00:02:59,200 --> 00:03:05,200
It's more of write code so that it's probably done.

41
00:03:05,200 --> 00:03:08,200
Submit once. You need to fix one or two things.

42
00:03:08,200 --> 00:03:13,200
Write some more local test cases yourself to try and identify the problem.

43
00:03:13,200 --> 00:03:15,200
Then resubmit.

44
00:03:16,200 --> 00:03:19,200
So that's my advice there.

45
00:03:19,200 --> 00:03:23,200
Write local tests. Local tests, local tests, local tests.

46
00:03:23,200 --> 00:03:27,200
I don't give you everything. I just give you most things.

47
00:03:31,200 --> 00:03:36,200
Okay. Any questions for me?

48
00:03:36,200 --> 00:03:39,200
Anything that we should cover before we start class?

49
00:03:46,200 --> 00:03:49,200
Okay.

50
00:03:49,200 --> 00:03:53,200
Then hopefully today's the last lecture on LambdaCalc for a little while.

51
00:03:53,200 --> 00:03:55,200
So maybe that's good and you like that.

52
00:03:55,200 --> 00:03:57,200
Maybe that's bad because you've been loving it.

53
00:03:57,200 --> 00:03:59,200
Either way, we'll be wrapping it up.

54
00:03:59,200 --> 00:04:03,200
Starting off, we're going to talk about free variables again.

55
00:04:03,200 --> 00:04:07,200
We have three equations that we built out last time.

56
00:04:07,200 --> 00:04:13,200
I'd like for you guys to give me these two equations.

57
00:04:14,200 --> 00:04:20,200
What is the free variables of a complex expression LambdaX.E?

58
00:04:20,200 --> 00:04:23,200
What are the free variables?

59
00:04:23,200 --> 00:04:26,200
Who can tell me?

60
00:04:26,200 --> 00:04:29,200
Yeah.

61
00:04:29,200 --> 00:04:36,200
Yeah. They are the free variables of E minus X.

62
00:04:36,200 --> 00:04:40,200
We have bound X as one of the non-free variables.

63
00:04:40,200 --> 00:04:42,200
It's one of the bound variables.

64
00:04:42,200 --> 00:04:50,200
And then the free variables of a function application E1, E2 are what?

65
00:04:50,200 --> 00:04:53,200
Yeah.

66
00:04:53,200 --> 00:04:57,200
It's the union of what?

67
00:04:57,200 --> 00:04:59,200
Yeah. Definitely.

68
00:04:59,200 --> 00:05:02,200
So we find out whatever the free variables of E1 are.

69
00:05:02,200 --> 00:05:06,200
And then union that with whatever the free variables of E2 are.

70
00:05:06,200 --> 00:05:10,200
This is one set of equations that we care about in LambdaCalc.

71
00:05:11,200 --> 00:05:14,200
What are the free variables of our space?

72
00:05:14,200 --> 00:05:17,200
We did have a question on Wednesday saying,

73
00:05:17,200 --> 00:05:19,200
isn't it all of the variables?

74
00:05:19,200 --> 00:05:21,200
All variables ever?

75
00:05:21,200 --> 00:05:24,200
Not necessarily just the free variables of E.

76
00:05:24,200 --> 00:05:30,200
And to that, I would say a variable is only a variable if it's being used.

77
00:05:30,200 --> 00:05:32,200
So just for that point.

78
00:05:32,200 --> 00:05:35,200
Okay.

79
00:05:35,200 --> 00:05:38,200
This is our second set of equations.

80
00:05:38,200 --> 00:05:42,200
So our first set of equations, these ones to calculate the free variables.

81
00:05:42,200 --> 00:05:47,200
Our second set of equations are about how do we actually do substitution?

82
00:05:47,200 --> 00:05:50,200
How do we do capture avoiding substitution?

83
00:05:50,200 --> 00:05:52,200
And what do we do with these?

84
00:05:52,200 --> 00:05:58,200
What is X where X is E?

85
00:05:58,200 --> 00:06:08,200
How do we reduce the first statement?

86
00:06:08,200 --> 00:06:09,200
Who's got an answer?

87
00:06:09,200 --> 00:06:11,200
Yeah. Go for it.

88
00:06:11,200 --> 00:06:12,200
Just reduces to E.

89
00:06:12,200 --> 00:06:15,200
We get to do our replacement as you would expect.

90
00:06:15,200 --> 00:06:19,200
If X is the value 3, when we see X, we replace it with the value 3.

91
00:06:19,200 --> 00:06:21,200
For example.

92
00:06:21,200 --> 00:06:22,200
All right.

93
00:06:22,200 --> 00:06:25,200
Then we have the variable Y where X is equal to E.

94
00:06:25,200 --> 00:06:28,200
What's this reduced to?

95
00:06:28,200 --> 00:06:34,200
Who's got an answer?

96
00:06:34,200 --> 00:06:37,200
Yeah.

97
00:06:37,200 --> 00:06:41,200
Y if Y is not equal to X.

98
00:06:41,200 --> 00:06:48,200
So assuming these are two different variables, then we just get to ignore whatever we set X to be.

99
00:06:48,200 --> 00:06:50,200
Okay.

100
00:06:50,200 --> 00:06:52,200
What about E1, E2?

101
00:06:53,200 --> 00:06:56,200
Also known as a function application.

102
00:06:56,200 --> 00:07:00,200
E1, E2 where X is equal to E.

103
00:07:00,200 --> 00:07:10,200
How does this reduce?

104
00:07:10,200 --> 00:07:11,200
Yeah.

105
00:07:12,200 --> 00:07:15,200
Yeah.

106
00:07:15,200 --> 00:07:19,200
So we get to say all occurrences of X are replaced with E.

107
00:07:19,200 --> 00:07:27,200
But a little bit more generically, we say all occurrences of X in E1, we will replace with E.

108
00:07:27,200 --> 00:07:33,200
Or we'll continue to recursively substitute inside of E1, X is equal to E.

109
00:07:33,200 --> 00:07:40,200
And we will recursively substitute in E2, X is equal to E.

110
00:07:40,200 --> 00:07:41,200
All right.

111
00:07:41,200 --> 00:07:44,200
And then we have our function, our lambda abstraction.

112
00:07:44,200 --> 00:07:48,200
Lambda X.E1 where X is equal to E.

113
00:07:48,200 --> 00:08:02,200
What do we do here?

114
00:08:02,200 --> 00:08:04,200
Yeah.

115
00:08:04,200 --> 00:08:08,200
Just E1.

116
00:08:08,200 --> 00:08:11,200
Who agrees?

117
00:08:11,200 --> 00:08:13,200
So just E1.

118
00:08:13,200 --> 00:08:16,200
This is, I think, a common point of confusion.

119
00:08:16,200 --> 00:08:22,200
If I can find my pen.

120
00:08:22,200 --> 00:08:34,200
There's a meaningful difference here between lambda X.E1 with the state X is equal to E.

121
00:08:34,200 --> 00:08:44,200
And lambda X.E1 applied to E.

122
00:08:44,200 --> 00:08:52,200
This is an application, a function application, where this is an expression and this is an expression.

123
00:08:52,200 --> 00:08:56,200
This is the parameter to this function.

124
00:08:56,200 --> 00:08:59,200
Here what I'm saying is I have an expression.

125
00:08:59,200 --> 00:09:04,200
And I have some state that goes along with that expression.

126
00:09:04,200 --> 00:09:16,200
Where I can say X is equal to E inside of this expression here.

127
00:09:16,200 --> 00:09:22,200
So these are two different things that we're talking about.

128
00:09:22,200 --> 00:09:25,200
I'm looking up here.

129
00:09:25,200 --> 00:09:28,200
What do we do?

130
00:09:29,200 --> 00:09:42,200
You already got one.

131
00:09:42,200 --> 00:09:47,200
Yeah.

132
00:09:47,200 --> 00:09:56,200
E1 where X is evaluated to E.

133
00:09:56,200 --> 00:10:05,200
E1 where X is equal to E.

134
00:10:05,200 --> 00:10:10,200
What we've done here is we've lost this lambda.

135
00:10:10,200 --> 00:10:16,200
We aren't doing a function application in this expression here.

136
00:10:16,200 --> 00:10:18,200
There's no function application.

137
00:10:18,200 --> 00:10:21,200
So we should end up with a function at the end.

138
00:10:21,200 --> 00:10:26,200
We don't want to substitute in any value into this function.

139
00:10:26,200 --> 00:10:29,200
Because that's not what we're doing at this point.

140
00:10:29,200 --> 00:10:35,200
This here is what we would get if we had said, if I had kept the original thing.

141
00:10:35,200 --> 00:10:37,200
I don't know why I erased it.

142
00:10:37,200 --> 00:10:49,200
If we kept lambda X.E1, E, this would simplify to E1 where X is equal to E.

143
00:10:49,200 --> 00:10:51,200
This is our function application.

144
00:10:51,200 --> 00:10:54,200
E is a parameter to this function.

145
00:10:54,200 --> 00:10:59,200
So X is equal to E. And we get E1 where X is equal to E.

146
00:10:59,200 --> 00:11:01,200
Up here, we have an expression.

147
00:11:01,200 --> 00:11:05,200
And we have state that's going along with it.

148
00:11:05,200 --> 00:11:06,200
Yeah.

149
00:11:06,200 --> 00:11:09,200
Right.

150
00:11:09,200 --> 00:11:16,200
So when we are doing this step here, what we get to do is we get to actually drop our state entirely,

151
00:11:16,200 --> 00:11:21,200
like you've said, and get just lambda X.E1 out of it.

152
00:11:21,200 --> 00:11:27,200
Yeah, question.

153
00:11:27,200 --> 00:11:29,200
That's precisely correct.

154
00:11:29,200 --> 00:11:32,200
So this X is from an outer statement.

155
00:11:32,200 --> 00:11:36,200
It's a different X than this X.

156
00:11:36,200 --> 00:11:46,200
So one way that I personally look at this here, when I see that, I go backwards.

157
00:11:46,200 --> 00:11:50,200
And I say, how did we get here?

158
00:11:50,200 --> 00:11:57,200
We got here by having a lambda X.E.

159
00:11:57,200 --> 00:11:59,200
This is our inner expression.

160
00:11:59,200 --> 00:12:02,200
This corresponds to this piece.

161
00:12:02,200 --> 00:12:03,200
E1, sorry.

162
00:12:03,200 --> 00:12:08,200
And then we had an X, or that's an E.

163
00:12:08,200 --> 00:12:20,200
An E as a parameter to this outer function where we have X as our parameter name.

164
00:12:20,200 --> 00:12:28,200
So we can go backwards from this starting point to get to what it might have looked like before.

165
00:12:29,200 --> 00:12:30,200
Maybe it looked like this.

166
00:12:30,200 --> 00:12:33,200
Maybe it was more complicated.

167
00:12:33,200 --> 00:12:44,200
But if we simplify this line here, we would get to this point.

168
00:12:44,200 --> 00:12:48,200
OK.

169
00:12:48,200 --> 00:12:49,200
Other questions on this one?

170
00:12:49,200 --> 00:12:51,200
Because it definitely can be confusing.

171
00:12:51,200 --> 00:12:52,200
Yeah.

172
00:12:52,200 --> 00:13:20,200
So it can't be E1 and then E. What do you mean by that?

173
00:13:20,200 --> 00:13:21,200
Right.

174
00:13:21,200 --> 00:13:34,200
So why we can't say that this piece here becomes E1 where X is equal to E, or something of this sort, is because this isn't an application.

175
00:13:34,200 --> 00:13:38,200
We aren't making a function call here.

176
00:13:38,200 --> 00:13:42,200
We have an expression, and we have state that goes along with it.

177
00:13:42,200 --> 00:13:53,200
Any time you see square brackets in lambda calculus, we're talking about the state of our kind of world, of our program.

178
00:13:53,200 --> 00:13:57,200
Parentheses and all of this side, that's all the expression.

179
00:13:57,200 --> 00:14:00,200
That's the math that we're actually trying to solve.

180
00:14:00,200 --> 00:14:03,200
This is the accompanying state.

181
00:14:03,200 --> 00:14:05,200
It's not part of the expression.

182
00:14:05,200 --> 00:14:08,200
It's not something that we're going to ever substitute in.

183
00:14:08,200 --> 00:14:11,200
It's just saying this variable is equal to that.

184
00:14:11,200 --> 00:14:17,200
This variable is equal to that.

185
00:14:17,200 --> 00:14:18,200
Yeah.

186
00:14:18,200 --> 00:14:22,200
So basically, that's a bound variable, right?

187
00:14:22,200 --> 00:14:23,200
X.

188
00:14:23,200 --> 00:14:28,200
So wouldn't it be more comfortable for reading?

189
00:14:28,200 --> 00:14:30,200
We could, but we don't need to.

190
00:14:30,200 --> 00:14:31,200
Yeah.

191
00:14:31,200 --> 00:14:44,200
Yeah, so we could kind of accumulate as much state as we want.

192
00:14:44,200 --> 00:14:50,200
We could say X is equal to E, and then we'll replace this one with a Z so that eventually,

193
00:14:50,200 --> 00:14:52,200
we never rewrite this X.

194
00:14:52,200 --> 00:14:53,200
We never overwrite it.

195
00:14:53,200 --> 00:14:55,200
We could do that, but we don't need to.

196
00:14:55,200 --> 00:14:56,200
Yeah.

197
00:14:57,200 --> 00:15:04,200
So this next problem is basically the same sort of similar to this problem?

198
00:15:04,200 --> 00:15:05,200
Yes.

199
00:15:05,200 --> 00:15:08,200
So now, let's move on to this next one.

200
00:15:08,200 --> 00:15:15,200
Lambda Y dot E1, where X is equal to E2.

201
00:15:15,200 --> 00:15:20,200
How do we simplify this?

202
00:15:20,200 --> 00:15:31,200
First of all, what happens if Y is equal to X?

203
00:15:31,200 --> 00:15:34,200
Yeah.

204
00:15:34,200 --> 00:15:39,200
Right, if Y is equal to X, then we just use this rule.

205
00:15:39,200 --> 00:15:41,200
And we say, OK, Y is equal to X.

206
00:15:41,200 --> 00:15:46,200
Then we drop this state, and we'll get lambda X dot E1.

207
00:15:46,200 --> 00:15:49,200
So we can assume Y is not equal to X.

208
00:15:49,200 --> 00:15:53,200
Y is a different variable than X.

209
00:15:53,200 --> 00:16:18,200
What do we want to do now?

210
00:16:19,200 --> 00:16:22,200
Yeah, go for it.

211
00:16:22,200 --> 00:16:23,200
Drop the state.

212
00:16:23,200 --> 00:16:25,200
Well, not necessarily.

213
00:16:25,200 --> 00:16:27,200
What if E1 uses X?

214
00:16:27,200 --> 00:16:33,200
So I think let's actually take a second and look at what this would look like in JavaScript.

215
00:16:33,200 --> 00:16:39,200
You can turn this guy around.

216
00:16:40,200 --> 00:16:50,200
If I have a function that returns Y plus X, so there's a function in JavaScript.

217
00:16:50,200 --> 00:16:51,200
It takes in a parameter Y.

218
00:16:51,200 --> 00:16:55,200
It returns Y plus X.

219
00:16:55,200 --> 00:17:06,200
What if I have the state let X equal 3?

220
00:17:06,200 --> 00:17:25,200
What do I do to simplify my function here?

221
00:17:25,200 --> 00:17:31,200
Go for it.

222
00:17:31,200 --> 00:17:34,200
We can apply the state recursively to the expression.

223
00:17:34,200 --> 00:17:37,200
I love that answer for this generic thing.

224
00:17:37,200 --> 00:17:40,200
Yeah, yeah.

225
00:17:40,200 --> 00:17:42,200
So that is exactly how I would phrase it.

226
00:17:42,200 --> 00:17:44,200
I agree.

227
00:17:44,200 --> 00:17:52,200
In this example, what does that look like?

228
00:17:52,200 --> 00:17:55,200
Yeah.

229
00:17:55,200 --> 00:17:58,200
We can replace the X in our function with 3.

230
00:17:59,200 --> 00:18:05,200
So we can simplify our function to be this.

231
00:18:05,200 --> 00:18:14,200
Because we know the value of X, and we're using that variable X.

232
00:18:14,200 --> 00:18:39,200
So I want to argue that this example here is going to be identical to lambda Y dot Y plus X, where X is equal to 3.

233
00:18:39,200 --> 00:18:42,200
Here, what I have is a function that takes a parameter Y.

234
00:18:42,200 --> 00:18:44,200
It returns Y plus X.

235
00:18:44,200 --> 00:18:50,200
And I have some state that is telling me that X is equal to 3.

236
00:18:50,200 --> 00:18:59,200
This expression is equivalent to the JavaScript expression that I just showed you.

237
00:18:59,200 --> 00:19:08,200
So what we want to do is we have lambda Y dot E1, where E1 is Y plus X.

238
00:19:09,200 --> 00:19:17,200
And we have some state that X is equal to E2, where E2 is 3.

239
00:19:17,200 --> 00:19:28,200
Our goal is to get to lambda Y dot Y plus 3.

240
00:19:28,200 --> 00:19:43,200
And the way we do that is, as your classmate said, we recursively apply our substitution of X is equal to E2 inside of E1.

241
00:19:43,200 --> 00:19:52,200
So what that looks like is that we have lambda Y dot E1 with no parentheses, where X is equal to E2.

242
00:19:52,200 --> 00:19:56,200
So long as Y is not equal to X, which we already covered.

243
00:19:56,200 --> 00:20:12,200
And so long as Y is not in the free variables of E2.

244
00:20:12,200 --> 00:20:16,200
That's a confusing line of math code.

245
00:20:16,200 --> 00:20:21,200
And it might take multiple times staring at it to figure it out.

246
00:20:21,200 --> 00:20:22,200
And that's OK.

247
00:20:22,200 --> 00:20:30,200
That's expected.

248
00:20:30,200 --> 00:20:33,200
Questions on it at this point?

249
00:20:33,200 --> 00:20:34,200
Yeah?

250
00:20:35,200 --> 00:20:45,200
Well, because if Y is equal to X, we have a different rule for that, where we say just drop the state entirely.

251
00:20:45,200 --> 00:20:48,200
So we have that part covered somewhere else.

252
00:20:48,200 --> 00:20:50,200
Yeah?

253
00:20:50,200 --> 00:20:53,200
Other questions?

254
00:20:53,200 --> 00:21:08,200
Well, no, because if Y is equal to X, then we have that.

255
00:21:08,200 --> 00:21:15,200
So you would just, it's kind of like a, consider it like a case statement, where you're matching on these patterns.

256
00:21:15,200 --> 00:21:16,200
If it's this, do that.

257
00:21:16,200 --> 00:21:17,200
If it's this, do that.

258
00:21:17,200 --> 00:21:18,200
If it's this, do that.

259
00:21:18,200 --> 00:21:24,200
So maybe you could say this is redundant, because we've previously checked that Y is not equal to X.

260
00:21:24,200 --> 00:21:41,200
That's not too important to us.

261
00:21:41,200 --> 00:21:48,200
Yeah, so why don't we have this same check for this second-to-last expression?

262
00:21:48,200 --> 00:21:51,200
The reason is because we're entirely dropping the state.

263
00:21:51,200 --> 00:21:57,200
So we're never going to accidentally capture by substituting in E2.

264
00:21:57,200 --> 00:21:59,200
E2 is just kind of erased.

265
00:21:59,200 --> 00:22:02,200
Or E, in this case, is just erased.

266
00:22:02,200 --> 00:22:04,200
Yeah?

267
00:22:04,200 --> 00:22:09,200
Yeah?

268
00:22:09,200 --> 00:22:10,200
Ah, no, these are rules.

269
00:22:10,200 --> 00:22:12,200
Yes, yeah, good question.

270
00:22:12,200 --> 00:22:15,200
These are rules, not examples.

271
00:22:15,200 --> 00:22:28,200
This is the entire rule description of how we do substitution in lambda calculus.

272
00:22:28,200 --> 00:22:30,200
If it was or wasn't?

273
00:22:30,200 --> 00:22:31,200
If it was, yeah.

274
00:22:31,200 --> 00:22:42,200
So what if X is equal to, let's say, 3 plus Y?

275
00:22:42,200 --> 00:22:50,200
So now we have a complicated expression for X.

276
00:22:51,200 --> 00:22:58,200
If we perform the substitution without caring about the fact that, well, actually, first,

277
00:22:58,200 --> 00:23:03,200
is this Y free or is it bound?

278
00:23:03,200 --> 00:23:04,200
This is a free Y.

279
00:23:04,200 --> 00:23:08,200
This is a different Y than this Y.

280
00:23:08,200 --> 00:23:10,200
These two are the same Y.

281
00:23:10,200 --> 00:23:11,200
That's a different Y.

282
00:23:11,200 --> 00:23:12,200
This is a free Y.

283
00:23:12,200 --> 00:23:15,200
These are bound.

284
00:23:15,200 --> 00:23:22,200
So if we do our substitution without checking the free variables, then what we would get

285
00:23:22,200 --> 00:23:30,200
is we would get Y plus X, where X is 3 plus Y.

286
00:23:30,200 --> 00:23:38,200
And now when we look at this expression, which of these Y's is free?

287
00:23:38,200 --> 00:23:39,200
None of them.

288
00:23:39,200 --> 00:23:40,200
They're all bound.

289
00:23:40,200 --> 00:23:43,200
Or they're both bound to this Y.

290
00:23:43,200 --> 00:23:47,200
We've lost that free variable.

291
00:23:47,200 --> 00:23:50,200
And you can see this in JavaScript as well.

292
00:23:56,200 --> 00:24:05,200
If we said that X is equal to Y plus 3, this Y here is different than this Y, very clearly.

293
00:24:05,200 --> 00:24:10,200
We would have to have said somewhere else, let Y equal 7 or whatever we want.

294
00:24:10,200 --> 00:24:18,200
But if we tried to do the substitution that we did here and we said that it's instead equal to Y plus 3,

295
00:24:18,200 --> 00:24:22,200
now we've run into that same problem that we saw with lambda calculus.

296
00:24:22,200 --> 00:24:27,200
This Y is the same as this Y, even though it wasn't the same previously.

297
00:24:32,200 --> 00:24:35,200
So that's why we do this check.

298
00:24:35,200 --> 00:24:40,200
If we didn't, we would capture variables around us.

299
00:24:44,200 --> 00:24:45,200
Yeah, question.

300
00:24:59,200 --> 00:25:03,200
Yeah, no, we don't need to because it's being overwritten.

301
00:25:03,200 --> 00:25:09,200
So it's kind of what we can show this example as well with JavaScript,

302
00:25:09,200 --> 00:25:13,200
where we can say, let Y equal 3.

303
00:25:13,200 --> 00:25:19,200
And now we have a function with the parameter name Y goes to Y plus X.

304
00:25:19,200 --> 00:25:26,200
Inside of this function expression, we don't care that Y was previously equal to 3.

305
00:25:26,200 --> 00:25:29,200
We have shadowed that with our parameter name.

306
00:25:30,200 --> 00:25:37,200
So we get to ignore this previous state when we are evaluating this expression.

307
00:25:39,200 --> 00:25:42,200
That's what the second to last one is saying.

308
00:25:42,200 --> 00:25:43,200
Yeah.

309
00:25:49,200 --> 00:25:52,200
Does this make things more clear, seeing it with JavaScript?

310
00:25:52,200 --> 00:25:54,200
Is this a...

311
00:25:54,200 --> 00:25:55,200
OK, I'm seeing a lot of nods.

312
00:25:55,200 --> 00:25:57,200
That's good.

313
00:25:57,200 --> 00:26:02,200
Because I felt like Wednesday's lecture wasn't quite getting there.

314
00:26:02,200 --> 00:26:05,200
So, all right.

315
00:26:05,200 --> 00:26:08,200
At this point, we've covered the basics of LambdaCalc.

316
00:26:08,200 --> 00:26:10,200
That's everything.

317
00:26:10,200 --> 00:26:11,200
We have free variables.

318
00:26:11,200 --> 00:26:13,200
We have substitution.

319
00:26:13,200 --> 00:26:14,200
Great.

320
00:26:14,200 --> 00:26:15,200
Now, what can we do with it?

321
00:26:15,200 --> 00:26:19,200
Why did I spend two and a half lectures talking about all of this?

322
00:26:21,200 --> 00:26:24,200
Well, I guess, so first of all, the kind of specifics,

323
00:26:24,200 --> 00:26:27,200
we have the ability to do alpha renaming.

324
00:26:27,200 --> 00:26:30,200
Beta reduction is what we just defined.

325
00:26:30,200 --> 00:26:33,200
And then we have this last one, eta conversion,

326
00:26:33,200 --> 00:26:36,200
which is definitely the kind of like weird one.

327
00:26:39,200 --> 00:26:44,200
The way I think of it is, once again, with JavaScript,

328
00:26:46,200 --> 00:26:51,200
that if we have a function that takes in a variable X

329
00:26:51,200 --> 00:26:54,200
and it calls f of X,

330
00:26:56,200 --> 00:26:59,200
so if I have a function that looks like this,

331
00:26:59,200 --> 00:27:02,200
why didn't I just use f?

332
00:27:06,200 --> 00:27:10,200
Because all that I did was create a wrapper around my function f

333
00:27:10,200 --> 00:27:13,200
that took one parameter and passed it right into f.

334
00:27:13,200 --> 00:27:17,200
And I could have instead just used f.

335
00:27:17,200 --> 00:27:20,200
These are equivalent.

336
00:27:20,200 --> 00:27:23,200
That's exactly what the eta conversion is saying.

337
00:27:23,200 --> 00:27:30,200
That if we have a function that takes a single parameter

338
00:27:30,200 --> 00:27:33,200
and it has some complicated expression,

339
00:27:33,200 --> 00:27:36,200
but all that's happening is it takes in one parameter

340
00:27:36,200 --> 00:27:39,200
and passes it along to that expression,

341
00:27:39,200 --> 00:27:45,200
we can simplify that to the expression itself.

342
00:27:46,200 --> 00:27:51,200
This is not a huge thing to worry about.

343
00:27:51,200 --> 00:27:56,200
It's minorly convenient in some cases.

344
00:27:56,200 --> 00:27:59,200
So if it doesn't make full sense, that's fine.

345
00:27:59,200 --> 00:28:03,200
I would recommend just trying to play around with it a little bit,

346
00:28:03,200 --> 00:28:06,200
and that'll probably help.

347
00:28:06,200 --> 00:28:09,200
Okay.

348
00:28:09,200 --> 00:28:12,200
We did this example forever ago.

349
00:28:12,200 --> 00:28:14,200
Well, we can...

350
00:28:14,200 --> 00:28:16,200
Yeah, we can look at it again.

351
00:28:16,200 --> 00:28:18,200
So when we did this example before,

352
00:28:18,200 --> 00:28:23,200
what we found was that the A in the A plus 5

353
00:28:23,200 --> 00:28:26,200
went in for the X,

354
00:28:26,200 --> 00:28:28,200
and then we got into this problem

355
00:28:28,200 --> 00:28:35,200
where the A outside that's free was captured by the A inside.

356
00:28:35,200 --> 00:28:39,200
So what should we have done?

357
00:28:43,200 --> 00:28:45,200
What's our first step?

358
00:28:45,200 --> 00:28:48,200
Who knows?

359
00:28:48,200 --> 00:28:51,200
I heard it from someone.

360
00:28:51,200 --> 00:28:53,200
Raise your hand.

361
00:28:53,200 --> 00:28:54,200
Who was it?

362
00:28:54,200 --> 00:28:56,200
Yeah.

363
00:28:56,200 --> 00:28:58,200
We'll do an alpha rename.

364
00:28:58,200 --> 00:29:01,200
Yeah, an alpha rename of what?

365
00:29:01,200 --> 00:29:03,200
Exactly.

366
00:29:03,200 --> 00:29:05,200
We'll do an inner A,

367
00:29:05,200 --> 00:29:07,200
and we'll name it something else.

368
00:29:07,200 --> 00:29:09,200
In this case, I've called it B.

369
00:29:09,200 --> 00:29:13,200
So we just rename that inner A to be a B.

370
00:29:13,200 --> 00:29:16,200
Then we can do our substitution like normal,

371
00:29:16,200 --> 00:29:20,200
and we can pass in A plus 5 for X,

372
00:29:20,200 --> 00:29:23,200
and we can continue to beta substitute with the 7,

373
00:29:23,200 --> 00:29:30,200
and we'll end up with A plus 12.

374
00:29:30,200 --> 00:29:37,200
So that's what we should have done earlier.

375
00:29:37,200 --> 00:29:38,200
Okay.

376
00:29:38,200 --> 00:29:41,200
There's some more for the ones that,

377
00:29:41,200 --> 00:29:45,200
if you want to do them at home, feel free to.

378
00:29:45,200 --> 00:29:50,200
But that covers formal substitution,

379
00:29:50,200 --> 00:29:53,200
which leaves us with the fun part of LambdaCalc,

380
00:29:53,200 --> 00:29:56,200
why we actually talk about it.

381
00:29:56,200 --> 00:29:58,200
Well, one of the reasons that we actually talk about it

382
00:29:58,200 --> 00:30:03,200
is that we can use it to show off language paradigms.

383
00:30:03,200 --> 00:30:16,200
For example, evaluation order.

384
00:30:16,200 --> 00:30:21,200
This is a question for you guys.

385
00:30:21,200 --> 00:30:36,200
What should we reduce first in this expression?

386
00:30:36,200 --> 00:30:39,200
Yeah.

387
00:30:39,200 --> 00:30:41,200
What's that?

388
00:30:41,200 --> 00:30:42,200
The inner term.

389
00:30:42,200 --> 00:30:43,200
A.

390
00:30:43,200 --> 00:30:45,200
Who votes for A?

391
00:30:45,200 --> 00:30:49,200
Who votes for B?

392
00:30:50,200 --> 00:30:52,200
Like, mostly you guys didn't vote.

393
00:30:52,200 --> 00:30:57,200
It was like a lot of left-hand side voted for A.

394
00:30:57,200 --> 00:30:59,200
What's the reason?

395
00:30:59,200 --> 00:31:01,200
Somebody who voted,

396
00:31:01,200 --> 00:31:08,200
what's your reason for making the choice that you made?

397
00:31:08,200 --> 00:31:10,200
Did you want a third choice?

398
00:31:10,200 --> 00:31:13,200
Who wanted a third choice?

399
00:31:13,200 --> 00:31:17,200
Okay, a decent number of people wanted a third choice.

400
00:31:17,200 --> 00:31:22,200
Somebody back up your claim, whether it's A, B, or C.

401
00:31:22,200 --> 00:31:30,200
Why?

402
00:31:30,200 --> 00:31:43,200
Yeah.

403
00:31:43,200 --> 00:31:44,200
Yeah, sure.

404
00:31:44,200 --> 00:31:47,200
So one thing that we can do is we can actually solve it.

405
00:31:47,200 --> 00:31:50,200
If we take the first approach, the inner term,

406
00:31:50,200 --> 00:31:53,200
we pass z in for y.

407
00:31:53,200 --> 00:31:55,200
That reduces to z.

408
00:31:55,200 --> 00:31:57,200
Then we pass that into lambda x dot x,

409
00:31:57,200 --> 00:31:59,200
so that reduces to z.

410
00:31:59,200 --> 00:32:01,200
If we do it the other way,

411
00:32:01,200 --> 00:32:05,200
we'll pass lambda y dot yz into x,

412
00:32:05,200 --> 00:32:07,200
which gives us lambda y dot yz,

413
00:32:07,200 --> 00:32:10,200
which, when we reduce that one, also gives us z.

414
00:32:10,200 --> 00:32:13,200
They gave us the same thing either way.

415
00:32:13,200 --> 00:32:18,200
So does that mean that it doesn't matter?

416
00:32:18,200 --> 00:32:20,200
I'm seeing some nods.

417
00:32:20,200 --> 00:32:21,200
Yeah, I'm with you.

418
00:32:21,200 --> 00:32:22,200
It doesn't matter.

419
00:32:22,200 --> 00:32:24,200
They both reduce to z.

420
00:32:24,200 --> 00:32:25,200
We got the same thing.

421
00:32:25,200 --> 00:32:30,200
This is formally proved that all expressions

422
00:32:30,200 --> 00:32:33,200
will reduce to the same thing

423
00:32:33,200 --> 00:32:42,200
so long as they reduce to the same thing.

424
00:32:43,200 --> 00:32:47,200
More formally, if you reduce to a normal form,

425
00:32:47,200 --> 00:32:57,200
it doesn't matter what order you do your reductions in.

426
00:32:57,200 --> 00:32:58,200
Okay.

427
00:32:58,200 --> 00:33:03,200
So does that mean the reduction order doesn't matter?

428
00:33:03,200 --> 00:33:04,200
Yeah.

429
00:33:04,200 --> 00:33:15,200
All right.

430
00:33:15,200 --> 00:33:18,200
We have a vote for no.

431
00:33:18,200 --> 00:33:20,200
Anybody else vote for no?

432
00:33:20,200 --> 00:33:21,200
Oh, wait.

433
00:33:21,200 --> 00:33:22,200
That was a...

434
00:33:22,200 --> 00:33:24,200
Does it mean the reduction order...

435
00:33:24,200 --> 00:33:27,200
That was a vote for yes, it does matter.

436
00:33:27,200 --> 00:33:31,200
Who else votes for yes, it does matter?

437
00:33:31,200 --> 00:33:34,200
Who votes for no, it doesn't matter?

438
00:33:34,200 --> 00:33:36,200
Okay, we actually have a little bit of split.

439
00:33:36,200 --> 00:33:38,200
I do want you...

440
00:33:38,200 --> 00:33:40,200
I'll give you the answer.

441
00:33:40,200 --> 00:33:41,200
It does matter.

442
00:33:41,200 --> 00:33:44,200
No, it doesn't not matter.

443
00:33:44,200 --> 00:33:45,200
I don't know.

444
00:33:45,200 --> 00:33:47,200
It does matter.

445
00:33:47,200 --> 00:33:48,200
Why?

446
00:33:48,200 --> 00:33:49,200
You have an idea.

447
00:33:49,200 --> 00:33:51,200
Chat with the people next to you.

448
00:33:51,200 --> 00:33:55,200
Try and come up with a program that it does matter for,

449
00:33:55,200 --> 00:33:58,200
where you get a different result

450
00:33:58,200 --> 00:34:02,200
depending on how you evaluate your code.

451
00:34:02,200 --> 00:34:03,200
Chat with the people next to you.

452
00:34:03,200 --> 00:34:18,200
I'll give you like two or three minutes.

453
00:34:18,200 --> 00:34:20,200
I'm sorry to cut you off.

454
00:34:20,200 --> 00:34:22,200
You clearly have the right idea.

455
00:34:22,200 --> 00:34:25,200
I know the one, I just can't remember the exact formula.

456
00:34:25,200 --> 00:34:27,200
It's like the Y combinator.

457
00:34:27,200 --> 00:34:28,200
Yep, that's one.

458
00:34:28,200 --> 00:34:31,200
Yep, we'll cover those in a minute though.

459
00:34:57,200 --> 00:35:10,200
Okay, quieted down a bit.

460
00:35:10,200 --> 00:35:12,200
Does anybody have a good program?

461
00:35:12,200 --> 00:35:22,200
Something they want to try out?

462
00:35:22,200 --> 00:35:24,200
Who's got an idea?

463
00:35:24,200 --> 00:35:26,200
What can we try?

464
00:35:26,200 --> 00:35:35,200
For a program where it matters, what order are we going?

465
00:35:35,200 --> 00:35:53,200
You were pretty chatty 30 seconds ago.

466
00:35:54,200 --> 00:36:08,200
Something like that?

467
00:36:08,200 --> 00:36:12,200
Okay, how does evaluation order matter here?

468
00:36:12,200 --> 00:36:28,200
Ah, so let's, we're going to do proper substitution.

469
00:36:28,200 --> 00:36:31,200
So we will rename anything that we're supposed to rename.

470
00:36:31,200 --> 00:36:34,200
But definitely true that if we aren't doing proper substitution,

471
00:36:35,200 --> 00:36:45,200
we could get different results one way or the other.

472
00:36:45,200 --> 00:36:49,200
Any other ideas?

473
00:36:49,200 --> 00:36:50,200
Yeah.

474
00:36:50,200 --> 00:37:06,200
Yep.

475
00:37:06,200 --> 00:37:10,200
Yeah, so I like where you're starting here.

476
00:37:10,200 --> 00:37:14,200
The theorem there says, if you reduce to a normal form.

477
00:37:14,200 --> 00:37:18,200
So our goal is going to be trying to construct a function

478
00:37:18,200 --> 00:37:21,200
which is not reduced to a normal form.

479
00:37:21,200 --> 00:37:23,200
Not quite sure what you mean by the input-output though.

480
00:37:23,200 --> 00:37:36,200
What's, like, where they're independent?

481
00:37:36,200 --> 00:37:38,200
Won't that do what you're saying?

482
00:37:38,200 --> 00:37:41,200
But this actually is a normal form.

483
00:37:41,200 --> 00:37:44,200
Okay, so I think it's, to be honest,

484
00:37:44,200 --> 00:37:47,200
I wasn't fully expecting anyone to come up with an answer.

485
00:37:47,200 --> 00:37:49,200
But it's because it's kind of mind-boggling

486
00:37:49,200 --> 00:37:52,200
how you could come up with something

487
00:37:52,200 --> 00:37:55,200
that doesn't reduce to a normal form.

488
00:37:55,200 --> 00:38:00,200
So let's chat about a program that does this.

489
00:38:00,200 --> 00:38:03,200
The program is called Omega.

490
00:38:03,200 --> 00:38:08,200
And Omega is defined as an application of two expressions.

491
00:38:08,200 --> 00:38:12,200
You have the left-hand side, lambda x dot xx.

492
00:38:12,200 --> 00:38:17,200
And the right-hand side, lambda x dot xx.

493
00:38:17,200 --> 00:38:28,200
So what would be our first step in reducing this?

494
00:38:28,200 --> 00:38:31,200
Yeah.

495
00:38:31,200 --> 00:38:33,200
Sure, let's do an alpha rename.

496
00:38:33,200 --> 00:38:39,200
So we have lambda x, xx.

497
00:38:39,200 --> 00:38:41,200
What do you want to rename?

498
00:38:41,200 --> 00:38:45,200
I would basically give, I would number them 1, 2, 4.

499
00:38:45,200 --> 00:38:48,200
Ah, 1, 2, 3, 4.

500
00:38:48,200 --> 00:38:49,200
Yes.

501
00:38:49,200 --> 00:38:54,200
Can we do that?

502
00:38:54,200 --> 00:38:58,200
Which x is this bound by?

503
00:38:58,200 --> 00:38:59,200
The first x.

504
00:38:59,200 --> 00:39:00,200
The first x.

505
00:39:00,200 --> 00:39:01,200
Which x is this bound by?

506
00:39:01,200 --> 00:39:02,200
The first.

507
00:39:02,200 --> 00:39:03,200
Also the first one.

508
00:39:03,200 --> 00:39:05,200
So are these two x's the same?

509
00:39:05,200 --> 00:39:06,200
Yes.

510
00:39:06,200 --> 00:39:07,200
Yes.

511
00:39:07,200 --> 00:39:11,200
So we could rename these, but they have to be called the same thing.

512
00:39:11,200 --> 00:39:12,200
Yeah.

513
00:39:12,200 --> 00:39:15,200
So we could call this one x1, x1, x1.

514
00:39:15,200 --> 00:39:18,200
This one x2, x2, x2.

515
00:39:18,200 --> 00:39:19,200
Sure.

516
00:39:19,200 --> 00:39:31,200
Now what do we want to do?

517
00:39:31,200 --> 00:39:32,200
Beta reduce.

518
00:39:32,200 --> 00:39:46,200
What does beta look like?

519
00:39:46,200 --> 00:39:52,200
Yeah, so x1 is the parameter name where x1 is equal to this whole thing.

520
00:39:52,200 --> 00:39:55,200
So we will get x1, x1.

521
00:39:55,200 --> 00:39:58,200
That's our inner expression.

522
00:39:59,200 --> 00:40:09,200
x1 is equal to lambda x2 dot x2 x2.

523
00:40:09,200 --> 00:40:23,200
How do we simplify this?

524
00:40:23,200 --> 00:40:24,200
Yeah.

525
00:40:24,200 --> 00:40:25,200
Go back to where we started?

526
00:40:25,200 --> 00:40:27,200
We go back to where we started.

527
00:40:27,200 --> 00:40:33,200
Because x1 and x1 become lambda x2 dot x2 x2.

528
00:40:33,200 --> 00:40:37,200
Which we're back to the alpha renaming step again.

529
00:40:37,200 --> 00:40:42,200
Exactly.

530
00:40:42,200 --> 00:40:52,200
So if we replace this x1 with what x1 is, and we replace that x1 with what x1 is, what we end up with is this expression here.

531
00:40:52,200 --> 00:41:03,200
Which if we alpha rename, removing these numbers, is lambda x dot xx applied to lambda x dot xx.

532
00:41:03,200 --> 00:41:09,200
Which is precisely where we started.

533
00:41:09,200 --> 00:41:17,200
So if we simplify this, we end up back at omega.

534
00:41:17,200 --> 00:41:20,200
That means omega has no normal form.

535
00:41:20,200 --> 00:41:29,200
If you can beta reduce it as much as you want, you'll never end up done.

536
00:41:29,200 --> 00:41:37,200
So when we return to this question of does evaluation order matter, what if we had a function that ignores the input?

537
00:41:37,200 --> 00:41:40,200
And this is kind of what you were getting at, I feel like.

538
00:41:40,200 --> 00:41:43,200
Where we can just toss away the input.

539
00:41:43,200 --> 00:41:45,200
Lambda x dot y.

540
00:41:45,200 --> 00:41:52,200
What happens if we have lambda x dot y where the parameter is omega?

541
00:41:52,200 --> 00:41:59,200
What options do we have for reducing this expression here?

542
00:42:00,200 --> 00:42:18,200
What's one option that we have?

543
00:42:18,200 --> 00:42:23,200
Yeah.

544
00:42:23,200 --> 00:42:29,200
We could pass omega in for x and then return the result, which is y.

545
00:42:29,200 --> 00:42:30,200
We know the value.

546
00:42:30,200 --> 00:42:31,200
We're done.

547
00:42:31,200 --> 00:42:33,200
Y is the result.

548
00:42:33,200 --> 00:42:36,200
So we could return y.

549
00:42:36,200 --> 00:42:38,200
What else could we do?

550
00:42:38,200 --> 00:42:40,200
What's a different way of simplifying this problem?

551
00:42:40,200 --> 00:42:44,200
Yeah.

552
00:42:44,200 --> 00:42:45,200
Right.

553
00:42:45,200 --> 00:42:46,200
We could try and reduce omega.

554
00:42:46,200 --> 00:42:49,200
We could take a beta reduction on omega.

555
00:42:49,200 --> 00:42:55,200
What would that look like?

556
00:42:55,200 --> 00:42:57,200
We'll get the same thing.

557
00:42:57,200 --> 00:43:01,200
Reducing omega gives you omega back.

558
00:43:01,200 --> 00:43:04,200
OK, so now we're here.

559
00:43:04,200 --> 00:43:09,200
What could we do?

560
00:43:09,200 --> 00:43:12,200
What options do we have?

561
00:43:12,200 --> 00:43:14,200
The same thing.

562
00:43:14,200 --> 00:43:21,200
Once again, return y by passing omega in for x, and then ignoring x and returning y.

563
00:43:21,200 --> 00:43:25,200
Or we could try and reduce it again, and again, and again, and again.

564
00:43:25,200 --> 00:43:27,200
At each stage, we have a choice to make.

565
00:43:27,200 --> 00:43:33,200
If you're familiar with non-determinism in Turing machines, this might look pretty familiar.

566
00:43:33,200 --> 00:43:41,200
Where it's like we could take that jump, or we could just stay where we are and kind of sit doing nothing with our epsilon.

567
00:43:42,200 --> 00:43:47,200
So, does it matter?

568
00:43:47,200 --> 00:43:48,200
Yes.

569
00:43:48,200 --> 00:43:51,200
Does it not matter?

570
00:43:51,200 --> 00:43:52,200
No.

571
00:43:52,200 --> 00:43:54,200
It does matter.

572
00:43:54,200 --> 00:43:56,200
But it only matters sometimes.

573
00:43:56,200 --> 00:44:00,200
And most of the time, we can say whatever.

574
00:44:00,200 --> 00:44:04,200
Sometimes, in lambda calc, we have to be pretty precise.

575
00:44:04,200 --> 00:44:07,200
So we can come up with a few different strategies.

576
00:44:08,200 --> 00:44:12,200
The first of which is called call by value.

577
00:44:12,200 --> 00:44:17,200
This is JavaScript's and most languages' approach.

578
00:44:17,200 --> 00:44:22,200
Where we have a function application, E1, E2.

579
00:44:22,200 --> 00:44:26,200
What we will do is first reduce the function.

580
00:44:26,200 --> 00:44:29,200
Then reduce the arguments.

581
00:44:29,200 --> 00:44:31,200
Then apply.

582
00:44:31,200 --> 00:44:42,200
So, any time you're doing a function application, you simplify both sides before applying the actual function call.

583
00:44:42,200 --> 00:44:51,200
We can think of this as...

584
00:44:51,200 --> 00:45:00,200
If we have JavaScript goes to X plus 3, whatever.

585
00:45:00,200 --> 00:45:02,200
So, we have some function.

586
00:45:02,200 --> 00:45:07,200
And we're going to call it with 3 plus 4.

587
00:45:07,200 --> 00:45:11,200
We will simplify our function, which we can't do.

588
00:45:11,200 --> 00:45:13,200
There's no simplification to be made.

589
00:45:13,200 --> 00:45:15,200
Then we simplify the arguments.

590
00:45:15,200 --> 00:45:18,200
And we figure out that this is 7.

591
00:45:18,200 --> 00:45:23,200
Then we pass 7 in for X.

592
00:45:23,200 --> 00:45:29,200
We could instead pass the expression 3 plus 4 in for X.

593
00:45:29,200 --> 00:45:31,200
We would get the same thing here.

594
00:45:31,200 --> 00:45:33,200
But that's a different route that we could take.

595
00:45:33,200 --> 00:45:36,200
JavaScript says reduce the arguments.

596
00:45:36,200 --> 00:45:38,200
Then apply.

597
00:45:38,200 --> 00:45:41,200
So, if we...

598
00:45:41,200 --> 00:45:44,200
You know, like, following that, we simplify the red.

599
00:45:44,200 --> 00:45:46,200
Then we simplify the blue.

600
00:45:46,200 --> 00:45:51,200
Then we apply the thing.

601
00:45:51,200 --> 00:45:54,200
So, if we look at this JavaScript function.

602
00:45:55,200 --> 00:45:59,200
X goes to 33 with this parameter as input.

603
00:45:59,200 --> 00:46:07,200
What are we going to get as our result?

604
00:46:07,200 --> 00:46:19,200
You have to turn on your visual debugger.

605
00:46:19,200 --> 00:46:25,200
What do we get?

606
00:46:25,200 --> 00:46:28,200
Who's got an idea?

607
00:46:28,200 --> 00:46:29,200
One person.

608
00:46:29,200 --> 00:46:31,200
Chat with somebody next to you.

609
00:46:31,200 --> 00:46:32,200
Figure out.

610
00:46:32,200 --> 00:46:42,200
What does this give us?

611
00:47:03,200 --> 00:47:09,200
How many of you said this?

612
00:47:09,200 --> 00:47:13,200
Range error maximum call stack exceeded.

613
00:47:13,200 --> 00:47:14,200
Why?

614
00:47:14,200 --> 00:47:16,200
What happened here?

615
00:47:16,200 --> 00:47:18,200
Where did we go wrong?

616
00:47:18,200 --> 00:47:24,200
Yeah?

617
00:47:24,200 --> 00:47:25,200
Exactly.

618
00:47:25,200 --> 00:47:26,200
No, no, no.

619
00:47:26,200 --> 00:47:30,200
So, we're trying to reduce the right-hand side value in blue.

620
00:47:30,200 --> 00:47:32,200
And this is a recursive function.

621
00:47:32,200 --> 00:47:36,200
What is this function?

622
00:47:36,200 --> 00:47:38,200
What's another name for the blue part?

623
00:47:38,200 --> 00:47:39,200
Yeah.

624
00:47:39,200 --> 00:47:41,200
Omega.

625
00:47:41,200 --> 00:47:43,200
That's what we just saw.

626
00:47:43,200 --> 00:47:45,200
In lambda calculus.

627
00:47:45,200 --> 00:47:46,200
That's omega.

628
00:47:46,200 --> 00:47:50,200
In JavaScript.

629
00:47:50,200 --> 00:47:53,200
Yeah, so it's not gonna work.

630
00:47:53,200 --> 00:47:56,200
What if we wanted it to work?

631
00:47:56,200 --> 00:48:02,200
Haskell, which we will start studying soon, takes a different approach.

632
00:48:02,200 --> 00:48:05,200
That's more similar to call by name.

633
00:48:05,200 --> 00:48:08,200
Where what we do is we reduce the function.

634
00:48:08,200 --> 00:48:11,200
And then we apply.

635
00:48:11,200 --> 00:48:19,200
The only thing that's different than call by value is that we aren't reducing the argument.

636
00:48:19,200 --> 00:48:21,200
You don't reduce the argument ever.

637
00:48:21,200 --> 00:48:23,200
You only ever reduce the function.

638
00:48:24,200 --> 00:48:30,200
And what that means is we will only use a value if it's being used.

639
00:48:30,200 --> 00:48:38,200
To go to our example over here, which was bad JavaScript.

640
00:48:38,200 --> 00:48:50,200
If we have a function X goes to 3, and we pass in 3 plus 4, but we aren't using X, why would you evaluate 3 plus 4?

641
00:48:50,200 --> 00:48:52,200
We didn't need that.

642
00:48:52,200 --> 00:48:55,200
Wasted computation.

643
00:48:55,200 --> 00:48:58,200
Ice caps are melting and all that, you know?

644
00:48:58,200 --> 00:49:01,200
This 3 plus 4 is the fault.

645
00:49:01,200 --> 00:49:05,200
So we can just toss it out instead because it's never used.

646
00:49:05,200 --> 00:49:10,200
Never evaluate something if it's not gonna be used.

647
00:49:10,200 --> 00:49:16,200
So this is your first, for some of you, your first time ever seeing Haskell.

648
00:49:16,200 --> 00:49:20,200
But it looks surprisingly similar to lambda calculus.

649
00:49:20,200 --> 00:49:31,200
Where we have lambda X dot 33, lambda X dot XX, lambda X dot XX.

650
00:49:31,200 --> 00:49:34,200
What will this program evaluate to?

651
00:49:34,200 --> 00:49:38,200
If you know nothing about Haskell except for what I've just said up above.

652
00:49:38,200 --> 00:49:39,200
Yeah?

653
00:49:39,200 --> 00:49:40,200
33.

654
00:49:40,200 --> 00:49:49,200
Because we don't use our parameter X, this piece here being omega, we'll never reduce omega.

655
00:49:49,200 --> 00:49:59,200
Which means we'll never try to go into this infinite loop, and we'll end up with the value 33.

656
00:49:59,200 --> 00:50:03,200
Now you guys know Haskell.

657
00:50:03,200 --> 00:50:05,200
That wasn't so hard.

658
00:50:05,200 --> 00:50:06,200
All right.

659
00:50:06,200 --> 00:50:07,200
Questions?

660
00:50:07,200 --> 00:50:09,200
Is there any of this?

661
00:50:09,200 --> 00:50:10,200
Yeah.

662
00:50:10,200 --> 00:50:11,200
No.

663
00:50:11,200 --> 00:50:12,200
That's...

664
00:50:12,200 --> 00:50:13,200
Yeah?

665
00:50:13,200 --> 00:50:14,200
Yeah.

666
00:50:14,200 --> 00:50:15,200
No.

667
00:50:15,200 --> 00:50:29,640
So it'll do the beta reduction to pass this all in for X.

668
00:50:29,640 --> 00:50:32,040
And then it won't need to use X.

669
00:50:32,040 --> 00:50:35,360
So it will never evaluate that state.

670
00:50:35,360 --> 00:50:40,700
So up above what you can see, only the pointer worked.

671
00:50:40,700 --> 00:50:44,300
We evaluate the left-hand side, the red.

672
00:50:44,300 --> 00:50:46,420
Simplify that as much as we can.

673
00:50:46,420 --> 00:50:54,060
And then the beauty of it is that we get to this E1 prime 33, where X is equal to this

674
00:50:54,060 --> 00:50:55,620
omega.

675
00:50:55,620 --> 00:51:00,140
And since we never use X, we can just toss away the state.

676
00:51:00,140 --> 00:51:01,140
And we'll return 33.

677
00:51:01,140 --> 00:51:02,140
Yeah?

678
00:51:02,140 --> 00:51:03,140
What do you mean by sharing?

679
00:51:03,140 --> 00:51:05,460
Oh, yeah, yeah.

680
00:51:05,460 --> 00:51:12,600
So what if...

681
00:51:12,600 --> 00:51:19,060
What if we have a function that takes X and returns X plus X?

682
00:51:19,060 --> 00:51:22,520
Then it's great to precompute 3 plus 4.

683
00:51:22,520 --> 00:51:25,420
Now we're saving the polarized caps.

684
00:51:25,420 --> 00:51:31,620
Because we're doing 7 plus 7 instead of 3 plus 4 plus 3 plus 4.

685
00:51:31,620 --> 00:51:37,740
And if you do 3 plus 4 plus 3 plus 4, you've duplicated your computation.

686
00:51:37,740 --> 00:51:40,620
Which might seem trivial, but I promise you it's not.

687
00:51:40,620 --> 00:51:45,780
This is exactly what compilers are doing all the time to optimize your code.

688
00:51:45,780 --> 00:51:51,040
So what Haskell does is it says, until you need something, don't evaluate it.

689
00:51:51,040 --> 00:51:54,580
As soon as you need it, store it.

690
00:51:54,580 --> 00:51:57,420
So we're gonna compute 3 plus 4 for X.

691
00:51:57,420 --> 00:52:00,420
And then we're just gonna use that same value a second time.

692
00:52:00,420 --> 00:52:02,360
We don't need to recompute it.

693
00:52:02,360 --> 00:52:04,540
So that's what the sharing means.

694
00:52:04,540 --> 00:52:05,540
Yeah?

695
00:52:05,540 --> 00:52:19,040
So, no, that's part of the runtime environment.

696
00:52:19,040 --> 00:52:24,260
But well, to the extent it can do these things at compile time, it will.

697
00:52:24,260 --> 00:52:28,260
But it can't do everything.

698
00:52:29,100 --> 00:52:37,100
Other questions?

699
00:52:37,100 --> 00:52:39,660
Cool.

700
00:52:39,660 --> 00:52:48,700
So in summary, you can have the technical term redexes or some terms that can reduce.

701
00:52:48,700 --> 00:52:55,620
Your evaluation strategy tells you which term to evaluate and reduce.

702
00:52:55,620 --> 00:52:58,580
You aren't guaranteed to find a normal form.

703
00:52:58,580 --> 00:53:01,020
These are two different ways that you could...

704
00:53:01,020 --> 00:53:09,020
Two different strategies to solve lambda expressions.

705
00:53:09,020 --> 00:53:16,700
All right.

706
00:53:16,700 --> 00:53:19,820
That concludes lambda calc.

707
00:53:19,820 --> 00:53:27,100
However, in the slide deck, there are about 15 more slides about more fun things you can

708
00:53:27,100 --> 00:53:33,540
do with lambda calculus, such as creating booleans, creating numbers, creating functions

709
00:53:33,540 --> 00:53:45,460
we've already done, doing tuples, structs, and in particular, recursion, which is not

710
00:53:45,460 --> 00:53:58,020
required for the course and will not be part of standard exam points.

711
00:53:58,020 --> 00:53:59,340
There's some fun slides on it, too.

712
00:53:59,340 --> 00:54:05,020
We talked about the Y Combinator, but not the VC firm.

713
00:54:05,020 --> 00:54:10,500
So I would encourage you, if you have at all enjoyed lambda calc, or if it's just at all

714
00:54:10,500 --> 00:54:13,740
interesting to check it out.

715
00:54:13,740 --> 00:54:16,420
Those last few slides.

716
00:54:16,420 --> 00:54:25,100
But otherwise, we're going to be leaving lambda calc in its place and use it as a way of talking

717
00:54:25,100 --> 00:54:31,660
about some of these other ideas.

718
00:54:31,660 --> 00:54:35,940
So any lingering questions on lambda calc?

719
00:54:35,940 --> 00:54:38,260
Yeah.

720
00:54:38,260 --> 00:54:54,740
So what should you take away from lambda calc?

721
00:54:54,740 --> 00:54:57,860
I think it's a fair question.

722
00:54:57,860 --> 00:55:02,900
First of all, for the exam, but also more broadly speaking, the goal of a lot of the

723
00:55:02,900 --> 00:55:08,620
parts of this class are to improve your visual debugger, as I mentioned� as I brought up

724
00:55:08,620 --> 00:55:09,620
earlier.

725
00:55:09,620 --> 00:55:14,940
Where it's not necessarily that you're ever going to write lambda calc.

726
00:55:14,940 --> 00:55:18,980
But you will look at a lot of functions as software engineers.

727
00:55:18,980 --> 00:55:19,980
That's something that you will do.

728
00:55:19,980 --> 00:55:25,340
And being able to spot how they work and what they're doing and how things will evaluate

729
00:55:25,340 --> 00:55:27,860
is very important.

730
00:55:27,860 --> 00:55:36,780
With respect to your grade, you need to be able to evaluate a lambda calc expression.

731
00:55:36,780 --> 00:55:40,300
And say what are the free variables of this expression?

732
00:55:40,300 --> 00:55:41,860
What will it reduce to?

733
00:55:41,860 --> 00:55:42,900
Will it reduce?

734
00:55:42,900 --> 00:55:45,100
Or will it not reduce?

735
00:55:45,100 --> 00:55:48,660
That sort of thing.

736
00:55:48,660 --> 00:55:53,900
Or write a lambda calc expression that does X, Y, Z.

737
00:55:53,900 --> 00:55:58,780
That's the sum of it.

738
00:55:58,780 --> 00:56:00,100
Other last questions?

739
00:56:00,100 --> 00:56:04,340
Otherwise, feel free to bring up any other stuff during office hours as well.

740
00:56:04,340 --> 00:56:05,340
Yeah?

741
00:56:05,340 --> 00:56:15,620
In general, is it easier to start from the expression you go out?

742
00:56:15,620 --> 00:56:18,780
It really depends on the expression.

743
00:56:18,780 --> 00:56:20,780
Yeah.

744
00:56:20,780 --> 00:56:25,420
The fact that JavaScript does it one way and Haskell does it another way is kind of indicative

745
00:56:25,420 --> 00:56:27,060
of there's no right answer.

746
00:56:27,060 --> 00:56:30,340
It's not that one of the two of them is smarter and better.

747
00:56:30,340 --> 00:56:32,500
It's that they're different approaches.

748
00:56:32,500 --> 00:56:39,380
Either one might be better.

749
00:56:39,380 --> 00:56:42,420
Okay.

750
00:56:42,420 --> 00:56:48,380
So what we have been talking about is lambda calculus's substitution model.

751
00:56:48,380 --> 00:56:54,080
Where we said we could have a function with a function application and we can beta reduce

752
00:56:54,080 --> 00:57:01,220
it to some other expression.

753
00:57:01,220 --> 00:57:05,860
In JavaScript, that above function looks something like this.

754
00:57:05,860 --> 00:57:14,220
And why we care about it is because we can do this beta reduction at compile time.

755
00:57:14,220 --> 00:57:16,700
That's not a runtime evaluation.

756
00:57:16,700 --> 00:57:19,740
That's a compile time simplification of your code.

757
00:57:19,740 --> 00:57:25,260
So that at runtime, we don't need to compute it.

758
00:57:25,260 --> 00:57:31,660
And if you're gonna do this over and over, then compile once, run ten times, it's highly

759
00:57:31,660 --> 00:57:39,220
effective to beta reduce.

760
00:57:39,220 --> 00:57:42,500
But why would you not want to do that?

761
00:57:42,500 --> 00:57:47,740
If we tried to do beta reduction on� these slides are on Canvas, by the way, already.

762
00:57:47,740 --> 00:57:53,720
So if you do that and follow along, they are already up there.

763
00:57:53,720 --> 00:58:00,180
Why would you not want to do a beta reduction in a real language like JavaScript?

764
00:58:00,180 --> 00:58:09,420
Where we're trying to say set X equal to some parameter for all X in some scope.

765
00:58:09,420 --> 00:58:12,420
What can go wrong?

766
00:58:12,420 --> 00:58:14,420
Yeah.

767
00:58:14,420 --> 00:58:16,420
Yeah.

768
00:58:16,420 --> 00:58:22,820
In JavaScript, we can update the value of X.

769
00:58:22,820 --> 00:58:27,140
X might be something at the start of a function and change to be something else at the end

770
00:58:27,140 --> 00:58:31,020
of the function.

771
00:58:31,020 --> 00:58:35,860
We've been working with JavaScript that looks like this, but that's not actually all of

772
00:58:35,860 --> 00:58:37,940
JavaScript's power.

773
00:58:37,940 --> 00:58:43,100
We could say X equals X plus 1 on the second line of this function.

774
00:58:43,100 --> 00:58:51,160
And then if we've substituted everything, we're kind of, like, in a limbo land.

775
00:58:51,160 --> 00:58:53,180
It can also slow things down.

776
00:58:53,180 --> 00:58:55,660
We don't need to get into that.

777
00:58:55,660 --> 00:59:04,300
But to point out this idea of change and mutation in JavaScript, if we had a relatively simple

778
00:59:04,300 --> 00:59:12,220
function, let Y equal 1, Z equal 0, Z plus plus, log Z, what do we expect to be the output

779
00:59:12,220 --> 00:59:13,220
of console.log?

780
00:59:13,220 --> 00:59:14,220
1.

781
00:59:14,220 --> 00:59:15,220
1.

782
00:59:15,220 --> 00:59:16,220
Right?

783
00:59:16,220 --> 00:59:25,100
We've started Z as 0, we incremented Z, and then we output Z.

784
00:59:25,100 --> 00:59:32,260
If we did a beta reduction of all Z is equal to 0, then when we get to this log, we log

785
00:59:32,260 --> 00:59:45,060
0.

786
00:59:45,060 --> 00:59:52,300
So most languages support this idea of mutation.

787
00:59:52,300 --> 00:59:53,660
Variables are not static.

788
00:59:53,660 --> 00:59:54,660
They change.

789
00:59:54,660 --> 00:59:57,540
They're called variable for a reason.

790
00:59:57,540 --> 01:00:02,380
Pascal has a different idea and says variables aren't variable.

791
01:00:02,380 --> 01:00:04,140
They are static.

792
01:00:04,140 --> 01:00:13,200
And part of the reason for that is so that they can do more substitution.

793
01:00:13,200 --> 01:00:15,500
So what can we do about this?

794
01:00:15,500 --> 01:00:21,840
We're going to spend the next lecture and a half talking about how to translate from

795
01:00:21,840 --> 01:00:28,880
the kind of mathematician ivory tower of lambda calculus, not quite all the way down

796
01:00:28,880 --> 01:00:35,240
to the machine model, but talk about the environment model of JavaScript somewhere in between.

797
01:00:35,240 --> 01:00:40,240
Where we get some of the benefits of lambda calculus, but we aren't all the way in the

798
01:00:40,240 --> 01:00:45,840
nuts and bolts of things.

799
01:00:45,840 --> 01:00:46,840
It'll look like this.

800
01:00:46,840 --> 01:00:49,380
This is what we're going to kind of be covering.

801
01:00:49,380 --> 01:00:51,100
What does scope look like?

802
01:00:51,100 --> 01:00:55,060
How do first order functions� yeah.

803
01:00:55,060 --> 01:00:56,420
First order functions to start.

804
01:00:56,420 --> 01:00:58,220
How do those work with scope?

805
01:00:58,220 --> 01:01:00,300
How do free variables play into this?

806
01:01:00,300 --> 01:01:06,740
And then finally, how do high order functions work with scope?

807
01:01:06,740 --> 01:01:12,660
So to start, what is a scope?

808
01:01:12,660 --> 01:01:18,660
What's the point of a scope?

809
01:01:18,660 --> 01:01:27,220
What do you use it for?

810
01:01:27,220 --> 01:01:30,180
You guys have a lot of answers.

811
01:01:30,180 --> 01:01:38,940
Someone who hasn't brought something up.

812
01:01:38,940 --> 01:01:41,180
I do appreciate it, just to be clear.

813
01:01:41,180 --> 01:01:51,300
It's not bad that you guys answer a lot of questions.

814
01:01:51,300 --> 01:01:52,300
What's the point of a scope?

815
01:01:52,300 --> 01:01:54,140
You guys use these all the time.

816
01:01:54,140 --> 01:01:56,340
When was the last time you wrote code?

817
01:01:56,340 --> 01:01:57,340
It's like yesterday.

818
01:01:57,340 --> 01:01:58,340
Right?

819
01:01:58,340 --> 01:02:00,120
There was a PA.

820
01:02:00,120 --> 01:02:01,620
You had to use a scope in the PA.

821
01:02:01,620 --> 01:02:02,620
Yeah?

822
01:02:02,620 --> 01:02:18,620
No, definitely.

823
01:02:18,620 --> 01:02:24,100
So to make variables easier to use, I think, is a pretty concise summary of what's the

824
01:02:24,100 --> 01:02:25,800
point of a scope.

825
01:02:25,800 --> 01:02:32,120
We want to encapsulate and hide these variables live here.

826
01:02:32,120 --> 01:02:35,880
It doesn't care about, like, these variables don't matter anywhere else.

827
01:02:35,880 --> 01:02:40,240
Don't use the same X that I've defined here in some other place.

828
01:02:40,240 --> 01:02:41,600
Yeah?

829
01:02:41,600 --> 01:02:49,720
PA is due next week.

830
01:02:49,720 --> 01:02:52,280
PA2 should be due this Sunday.

831
01:02:52,280 --> 01:02:56,080
Is that not what grade scope says?

832
01:02:56,080 --> 01:02:57,080
I'll fix that.

833
01:02:57,080 --> 01:02:58,360
It should be this Sunday.

834
01:02:58,360 --> 01:03:04,560
PA2 and 3 are due, like, this upcoming Sunday.

835
01:03:04,560 --> 01:03:05,560
Not yesterday.

836
01:03:05,560 --> 01:03:06,560
No.

837
01:03:06,560 --> 01:03:07,560
Oh, yeah.

838
01:03:07,560 --> 01:03:08,560
I guess I did just say...

839
01:03:08,560 --> 01:03:09,560
Yeah, no.

840
01:03:09,560 --> 01:03:10,680
Some of you might have been writing code.

841
01:03:10,680 --> 01:03:11,680
I don't know.

842
01:03:11,680 --> 01:03:12,680
Whatever.

843
01:03:12,680 --> 01:03:16,920
You guys should probably be writing more code than you are currently writing.

844
01:03:16,920 --> 01:03:19,040
That's definitely true.

845
01:03:19,040 --> 01:03:24,040
For probably 99 of you.

846
01:03:24,040 --> 01:03:27,600
But PA is due in six days or something like that.

847
01:03:27,600 --> 01:03:28,600
Yep.

848
01:03:28,600 --> 01:03:32,440
Don't worry if you didn't submit it.

849
01:03:32,440 --> 01:03:34,440
Okay.

850
01:03:34,440 --> 01:03:35,640
So scopes.

851
01:03:35,640 --> 01:03:42,520
The point of them is to encapsulate state specific to the area of code that we're working

852
01:03:42,520 --> 01:03:43,520
on.

853
01:03:43,520 --> 01:03:44,520
Right?

854
01:03:44,520 --> 01:03:50,560
If we're saying X here is equal to this thing, this is where I'm gonna use X with this value.

855
01:03:50,560 --> 01:03:53,000
Not elsewhere in, like, a different library.

856
01:03:53,000 --> 01:03:56,080
I don't want that other implementation of X.

857
01:03:56,080 --> 01:04:00,000
I want my version of X.

858
01:04:00,000 --> 01:04:03,280
So how are we gonna capture that?

859
01:04:03,280 --> 01:04:04,780
We are...

860
01:04:04,780 --> 01:04:06,360
We're not going here.

861
01:04:06,360 --> 01:04:09,640
But we are gonna be somewhere in the middle here, where we're talking about, like, what

862
01:04:09,640 --> 01:04:15,320
do we need to actually use a scope?

863
01:04:15,320 --> 01:04:24,520
If we wanted to track this idea of the environment of our program over time, we're gonna need

864
01:04:24,840 --> 01:04:26,280
some information.

865
01:04:26,280 --> 01:04:33,280
So going to the previous example, we're going to create environments, which I call activation

866
01:04:33,280 --> 01:04:36,960
records of whatever we are currently executing.

867
01:04:36,960 --> 01:04:42,620
When we are inside of one scope, we want information about that scope.

868
01:04:42,620 --> 01:04:45,760
It's doing X in this scope.

869
01:04:45,760 --> 01:04:50,660
And we're going to contain all of our variables in this environment.

870
01:04:50,660 --> 01:04:54,300
And then we're also going to contain some extra information.

871
01:04:54,300 --> 01:05:00,780
If you've taken kind of lower level classes, where you've done Spark or MIPS or X86 or

872
01:05:00,780 --> 01:05:06,340
whatever, you have to keep track of things like the stack pointer, the return address,

873
01:05:06,340 --> 01:05:08,460
the frame pointer.

874
01:05:08,460 --> 01:05:15,740
This is environmental information about what we're currently executing.

875
01:05:15,740 --> 01:05:21,980
So what we might do is, for the current snippet, we could have our environment pointer point

876
01:05:21,980 --> 01:05:29,460
to this area of memory, where we've said Y is equal to 1, Z is equal to 0.

877
01:05:29,460 --> 01:05:30,780
This is our state.

878
01:05:30,780 --> 01:05:34,460
It's our square brackets from lambda calculus.

879
01:05:34,460 --> 01:05:53,620
As opposed to the code, the expressions that we're going to execute.

880
01:05:53,620 --> 01:06:05,500
Depends on the setup.

881
01:06:05,500 --> 01:06:10,340
Okay.

882
01:06:10,340 --> 01:06:16,340
One minor piece of this that we kind of ignore after this one slide.

883
01:06:16,340 --> 01:06:22,420
But there's the canonical idea of R values and L values.

884
01:06:22,420 --> 01:06:29,140
R values are true expressions where we can treat them like lambda calculus.

885
01:06:29,140 --> 01:06:30,500
They're very mathematical.

886
01:06:30,500 --> 01:06:33,060
We can simplify as much as we want.

887
01:06:33,060 --> 01:06:36,700
There's no backing environment to them.

888
01:06:36,700 --> 01:06:40,780
And L values are pointers to R values.

889
01:06:40,780 --> 01:06:47,700
They're like the buckets that you learn about with variables.

890
01:06:47,700 --> 01:06:53,260
So L values point to R value information.

891
01:06:53,260 --> 01:07:02,180
And when we look at something like plus plus, when we say Z plus plus or plus plus Z, we

892
01:07:02,180 --> 01:07:09,580
can't plus plus an R value, because plus plus is mutating the state.

893
01:07:09,580 --> 01:07:15,500
So you can only plus plus an L value so that it can update itself.

894
01:07:15,500 --> 01:07:24,860
So in our thing over here, the left-hand side, the YZ, those are our L values that

895
01:07:24,860 --> 01:07:27,900
are pointing to R values on the right-hand side.

896
01:07:27,900 --> 01:07:33,500
We can plus plus Z. You can't plus plus 0.

897
01:07:33,500 --> 01:07:37,060
Because plus plus 0, it's like, what does that even mean?

898
01:07:37,060 --> 01:07:38,760
Maybe it returns 1.

899
01:07:38,760 --> 01:07:39,760
Maybe it doesn't.

900
01:07:39,760 --> 01:07:44,060
But it certainly doesn't update the number 0 to be 1.

901
01:07:44,060 --> 01:07:45,060
That would be really weird.

902
01:07:45,620 --> 01:07:48,620
If later, you then, like, use 0 and got 1.

903
01:07:53,620 --> 01:07:54,620
Goodness.

904
01:07:54,620 --> 01:07:55,620
OK.

905
01:07:55,620 --> 01:08:01,180
So that's L values, R values, whatever.

906
01:08:01,180 --> 01:08:08,380
When we want to execute console.log Z, we will go look at our environment and say, what

907
01:08:08,380 --> 01:08:12,140
context are we evaluating console.log Z in?

908
01:08:12,140 --> 01:08:13,780
Oh, sorry.

909
01:08:13,780 --> 01:08:15,500
We're looking at the Z plus plus first.

910
01:08:15,500 --> 01:08:20,340
When we execute Z plus plus, we say, what environment are we executing that in?

911
01:08:20,340 --> 01:08:23,260
Our environment is the little square.

912
01:08:23,260 --> 01:08:25,900
We go look up the value of Z. Z is 0.

913
01:08:25,900 --> 01:08:29,460
We increment it to 1.

914
01:08:29,460 --> 01:08:31,420
So we find our environment.

915
01:08:31,420 --> 01:08:33,820
We check to see if we're inside of the environment.

916
01:08:33,820 --> 01:08:36,220
And then we use the environment.

917
01:08:36,220 --> 01:08:40,020
When we log Z, the process is the same.

918
01:08:40,020 --> 01:08:44,980
We find what our current environment is, which is whatever our environment pointer

919
01:08:44,980 --> 01:08:46,620
points to.

920
01:08:46,620 --> 01:08:53,700
We look up the value of Z. What's the value of Z?

921
01:08:53,700 --> 01:08:54,700
What's the value of Z?

922
01:08:54,700 --> 01:08:55,700
1.

923
01:08:55,700 --> 01:08:56,700
1.

924
01:08:56,700 --> 01:08:57,700
Yeah.

925
01:08:57,700 --> 01:09:00,900
It's in the table right there.

926
01:09:00,900 --> 01:09:06,700
So we print out 1.

927
01:09:06,700 --> 01:09:10,700
This algorithm sounds a little slow.

928
01:09:10,700 --> 01:09:12,500
That's because it is.

929
01:09:12,500 --> 01:09:16,820
It's not very convenient to continually look up the environment pointer, check what my

930
01:09:16,820 --> 01:09:18,180
variables are.

931
01:09:18,180 --> 01:09:19,300
Is my variable there?

932
01:09:19,300 --> 01:09:23,700
If it's not, go find it somewhere else.

933
01:09:23,700 --> 01:09:26,580
That's partially because we're not in the machine model.

934
01:09:26,580 --> 01:09:29,580
We aren't talking about x86 or Spark.

935
01:09:29,580 --> 01:09:33,300
But it's also just a kind of necessary evil.

936
01:09:33,300 --> 01:09:36,740
You have to be able to find what is my environment.

937
01:09:36,740 --> 01:09:41,500
So we can come up with kind of, like, speedy hacks around it.

938
01:09:41,500 --> 01:09:44,980
But at the end of the day, we have to do this approach.

939
01:09:44,980 --> 01:09:49,340
Anytime we're executing code, we have to know what environment are we executing that code

940
01:09:49,340 --> 01:09:50,340
in.

941
01:09:50,340 --> 01:09:55,980
Because it's very different to log Z here than in a totally different program where

942
01:09:55,980 --> 01:09:57,860
you said Z is 100.

943
01:09:57,860 --> 01:09:58,860
Or Z is omega.

944
01:09:58,860 --> 01:10:00,660
Or, you know, whatever.

945
01:10:00,660 --> 01:10:05,780
Those mean different things depending on the environment.

946
01:10:05,780 --> 01:10:10,020
OK.

947
01:10:10,020 --> 01:10:14,340
That's the anatomy of a scope.

948
01:10:14,340 --> 01:10:17,300
Which is not, like, it's not crazy.

949
01:10:17,300 --> 01:10:20,860
It's not supposed to be something totally new.

950
01:10:20,860 --> 01:10:21,940
Scopes are scopes.

951
01:10:21,940 --> 01:10:26,660
Scopes store variables.

952
01:10:26,660 --> 01:10:31,300
Right?

953
01:10:31,300 --> 01:10:33,660
When do we create environments?

954
01:10:33,660 --> 01:10:39,660
When do we create scopes?

955
01:10:39,660 --> 01:10:41,020
Chat with someone next to you.

956
01:10:41,020 --> 01:10:42,660
When do we need to do these?

957
01:10:42,660 --> 01:10:48,660
A, B, A and B, or never?

958
01:11:18,660 --> 01:11:34,860
How many people vote A?

959
01:11:34,860 --> 01:11:37,260
Every time we create a new block scope.

960
01:11:37,260 --> 01:11:39,820
Or every time we enter a new block scope.

961
01:11:39,820 --> 01:11:41,500
How many people vote B?

962
01:11:41,500 --> 01:11:45,020
Every time we enter a new function scope.

963
01:11:45,020 --> 01:11:47,060
How many people vote A and B?

964
01:11:48,060 --> 01:11:49,060
All right.

965
01:11:49,060 --> 01:11:50,060
We got a majority there.

966
01:11:50,060 --> 01:11:52,060
Anybody say we don't need new environments?

967
01:11:52,060 --> 01:11:53,060
OK.

968
01:11:53,060 --> 01:11:54,060
Nobody's really...

969
01:11:54,060 --> 01:11:57,180
Oh, maybe we have a jokester.

970
01:11:57,180 --> 01:12:02,540
There are some worlds where you might have a language that doesn't create new environments.

971
01:12:02,540 --> 01:12:04,700
It's not unreasonable.

972
01:12:04,700 --> 01:12:10,240
And there was a version of JavaScript where you didn't have new block scopes.

973
01:12:10,240 --> 01:12:12,820
Or new scope on a block scope.

974
01:12:12,820 --> 01:12:15,380
Because we only really cared about function scope.

975
01:12:15,380 --> 01:12:22,180
Nowadays, it's A and B. Whenever you create a new block scope or a new function scope.

976
01:12:22,180 --> 01:12:25,900
Then we create a new environment.

977
01:12:25,900 --> 01:12:30,900
So the approach we're gonna take, and we're gonna spend a lot of time drawing these diagrams,

978
01:12:30,900 --> 01:12:37,460
and this is basically what the homework looks like, is we will have a function.

979
01:12:37,460 --> 01:12:40,100
We will call that function.

980
01:12:40,100 --> 01:12:46,860
And then we're going to keep track of the environment as we execute that code.

981
01:12:46,860 --> 01:12:52,920
And one of the main points of this chunk of class is so that you can look at this code

982
01:12:52,920 --> 01:12:53,920
and say...

983
01:12:53,920 --> 01:12:55,500
I know what that's gonna do.

984
01:12:55,500 --> 01:12:56,500
Here it's pretty obvious.

985
01:12:56,500 --> 01:12:57,500
It's factorial.

986
01:12:57,500 --> 01:12:59,900
We called it fact.

987
01:12:59,900 --> 01:13:01,260
That's not always the case.

988
01:13:01,260 --> 01:13:03,300
Sometimes you're presented with code that looks like...

989
01:13:03,300 --> 01:13:04,820
What the heck is this doing?

990
01:13:04,820 --> 01:13:10,420
Being able to trace through it and understand what state is looking like as you are tracing

991
01:13:10,420 --> 01:13:12,780
through it is extremely valuable.

992
01:13:12,780 --> 01:13:14,700
It saves you a lot of time.

993
01:13:14,700 --> 01:13:20,140
Rather than having to put a bunch of console.log inside of the code and then run it and run

994
01:13:20,140 --> 01:13:21,140
it.

995
01:13:21,140 --> 01:13:22,740
Or put a breakpoint and run it and run it.

996
01:13:22,740 --> 01:13:25,720
So we're finishing up with class now.

997
01:13:25,720 --> 01:13:33,300
We're gonna pick up on Wednesday diving into how can we track environment as we run JavaScript

998
01:13:33,580 --> 01:13:35,580
code.

999
01:13:35,580 --> 01:13:37,900
Feel free to drop by office hours.

1000
01:13:37,900 --> 01:13:39,620
Otherwise, have a good week.

1001
01:18:33,300 --> 01:18:34,300
Bye.

1002
01:18:34,300 --> 01:18:35,300
Bye.

1003
01:18:35,300 --> 01:18:36,300
Bye.

1004
01:18:36,300 --> 01:18:37,300
Bye.

1005
01:18:37,300 --> 01:18:37,300


1006
01:19:03,300 --> 01:19:04,300
Bye.

1007
01:19:04,300 --> 01:19:05,300
Bye.

1008
01:19:05,300 --> 01:19:05,300


1009
01:19:33,300 --> 01:19:34,300
Bye.

1010
01:19:34,300 --> 01:19:35,300
Bye.

1011
01:19:35,300 --> 01:19:35,300


