 All right, guys, let's start talking about objects
 We've spent a while covering functions, which is one of the major paradigms of programming
 It's time to cover the other side, the object oriented side, which you're probably much more familiar with in your earlier studies
 Are there any topics for class to discuss before we get into that? Any notes from you guys, anything wrong? The PA didn't have an auto-grader
 That should be fixed
 This is your last Haskell assignment
 So some of you can rejoice
 Some of you might be sad
 Next assignment is on Rust
 Any questions before class? All right
 There's a very high probability Wednesday lecture is canceled
 So keep that in mind
 Still double check, but it's probably 95 plus
 Let's talk about objects
 This lecture is probably my least favorite lecture in the class
 Objects are kind of boring
 So stop me if I'm going too quickly because a lot of this stuff I just want to get through
 But I've tried to make it a bit more exciting and put in some more interesting pieces of it
 So we'll see how that goes
 It's also not a complete snooze pass, but it's not great
 So what we're going to cover, central ideas of object oriented
 What makes object oriented object oriented? How is it different than functional? We're going to look at objects as activation records, which was piloted in Simula in 1962, almost more than 60 years ago
 And then we're going to look at dynamically typed object oriented languages, which is kind of the modern standard
 This is your JavaScript and your Python
 It's a little bit of C++, but it's not what Java and most of C++ is or C or anything else
 So what makes OOO? What is object oriented? We've talked so much about functions and all the different cool things we can do with that
 Throw that out the door
 What is interesting about object oriented? What are some of the things that come to mind when you think of OOO? Yeah
 In capsulation, that I have an object which covers a bunch of different ideas
 It combines all of the different features of a car into an object
 In capsulation, definitely
 What else? Yeah
 A natural way to think about problems
 What do you mean by that? Like thinking of a object instead of a different form
 Yeah, so it's kind of a mirror for real life, where we talk about the table and the table is an object and we can replicate that concept in code as the table having properties in our code
 For sure
 Anything else that makes OOO? All right, I can't
 Let's put it there we go
 What makes OOO? What else comes to mind? Yeah
 Polymorphism where we have like animal and then cat is an animal and dog is an animal
 Definitely
 So different types of objects that share a common feature set, which we will talk about as well today
 So you guys actually hit on basically everything here
 The central concepts that we'll go over, dynamic look up, which is the one that kind of falls into polymorphism but not entirely in capsulation and then subtyping and inheritance, which definitely are this idea of polymorphism
 All right, we'll dive into each of these
 Before we do, what are some examples of objects? Objects that you've used as a developer
 Just some things that you've done
 No wrong answers
 Who wants participation points? Yeah
 Array list
 Yeah, sure
 That's creates objects for you
 What else? Yeah
 You can also use the actual object class itself
 Again, in Java or in Python
 Does C++ have an object class? I don't know if it does
 What are other objects that you've used? They're all over the place
 Yeah
 Yeah
 You guys are thinking very general
 What are some specific objects? Yeah
 A fish object
 Yeah
 It's going backwards, right? Yeah
 An ant object
 All right
 It was crawling around the screen or something
 All right
 Yeah
 Objects could be anything
 They could be the fish
 They could be the ant
 They could be the array list
 They could be the object object
 Some other big ideas
 The file system is an object
 The DOM for your front end is an object
 All the elements on that are objects
 Integers in some languages can be called objects
 All of these things, what they share in common, what makes them an object, is that they receive and send messages
 So we might have some structure of data that's a collection of instance variables and message methods that we can call
 And what we want to do is we want to tell that ant go crawl five units to the right
 We're sending the object a message with some data as well
 So this is the key idea for what makes an object an object
 We can send it messages and then it will do things
 And it might send messages to other objects and then they will do things, etc
 How is this different than the ADTs that we saw in Haskell? Those data types
 Because we could do things like we could create an animal data type, which could be a fish or it could be an ant
 And we could do this
 What's the difference between these two setups? Or what is an A difference? It doesn't have to be the whole picture
 What's something that's different? Yeah
 Yeah, this object is responsible for action
 This data type is just like representing something
 It's just symbolic of structured
 And so in a kind of quippy sentence, we can say that objects are behavioral
 ADTs are structural
 ADTs such as animal equals fish are like a puzzle that you're fitting pieces together
 The structure of the piece matters a lot and where it's going to fit is going to imply what it's going to do
 Objects, on the other hand, much more Bob the builder ask where they just go and do something
 You tell Bob, please go build me a house
 He says, can we build this? Yes, we can
 So behavioral versus structural
 Some terminology that we can get out of the way to start
 And I will do my best to stick to, but this is very much the sort of thing where people criticize PL nerds as being like, wow, you guys suck
 Because you call that a method and that a function
 Why don't you just call them the same thing
 So these are the official names and we should try to use them, but for the most part functions are methods and arguments and parameters
 You know, it's like they have different meanings, but we speak English
 So a selector is the name of a message
 And you can think of that as the method name
 So if I have an object and I want to tell it to move, move is the selector
 Or if I want to remove something from a list, remove is the selector
 You have the message itself
 The message is both the selector and any arguments that you are giving to the object
 So if I want to remove the log, or if I want to move the ant by five steps, move five is the message
 That's all of the information that you need to tell the object what to do
 And then the last part is the method itself
 And the method is the code that is executed when you respond to a message
 So an object might have a method which has all of this code
 It would receive a message that was comprised of the selector and an argument
 And it would execute that code based on that selector and argument
 Any questions on terminology? This is the sort of stuff that makes you really fun at the bar
 All right
 Then let's get into the first OO concept, dynamic lookup
 Let's say we have an object and we want to send it a message
 We would send message with any args
 And the purpose of this is to invoke an operation
 We want to do something
 We want the object specifically to execute message with args
 In small talk, which is a language we will start talking about for this and next lecture, what that means is we are literally sending a message to the object
 The object is kind of just sitting there
 It's like a server waiting for an HTTP request to come in
 As soon as the request arrives, it's going to do something
 In C++, this might look more like calling a member function on the object
 And again, this is where the like pedantic people are, oh, it's the function versus the method that you're executing
 Like sure
 Yeah
 Go read a book
 The method for dynamic lookup is selected dynamically
 This is what makes it dynamic
 If we call a function such as add for three, this function, the compiler knows exactly what it is
 At compile time, we know what function is going to be executed
 We know what method, what lines of code will be executed at compile time
 Object oriented is interesting because now what we're going to do is we're going to say the object gets to decide at runtime what method to run
 Which lines of code should be executed at a dynamic time
 It's not something that's set when we compile our code
 So it's a runtime operation both to find the method to run and to actually run the method
 And it depends on the implementation of the object receiving the message
 So if I send the message remove to a list, that's going to do something different than if I send that same message to a stack
 The object that receives it is going to decide how should I perform this action? How should I remove something from my list? Questions on dynamic work? Yeah
 So why is this done at runtime not compile time? So why can't that also be applied with dynamic work? Why can't this be dynamic or why can't that be static? Yeah, why can't the message like this dynamically or it's the right time operation? Why can't this be a compile time operation? Yeah, let's look at exactly that in three slides, I think, or two slides
 But it's a great question
 Why can't we do this at compile time? And actually before we get to that slide, I might have you guys think for two or three minutes
 Try and come up with an example in Java or Python or any language you want that is object oriented of where you might need to figure this out at runtime
 Before we get there, actually any other questions before we continue on? Okay, so before we start talking about that, let's look at comparing it to overloading
 In Haskell, we were just talking about using type classes so that we could say plus of 3
0 and 2
1 as well as plus for 3 and 2
 We were overloading plus so that we could have multiple algorithms
 Dynamic lookup looks to be the same thing where we're saying I can send the remove message to a list and I can send the remove message to a staff
 So are these the same thing? Give it some time to think
 What might be different about them? What do we think? How many people think yes, these are the same
 How many people think no, these are not the same
 We've got a lot of notes and given that they have different names, one of them is in one of them is in functional, seems reasonable
 So I'll go ahead and give you that
 But now I want to explain
 Why? Yeah, yeah
 Well, the two string is one symbol
 But I think I like exactly where you're going with this
 So your point is if we had 3
2 string, it's very different than pi
2 string
 But I would argue here what we're doing is effectively the same thing that we wanted to do with overloading where we have one symbol, the symbol is two string, that is being used to reference two completely different algorithms
 Here it's probably just the identity function
 And here we have to somehow convert it to an a to s or whatever
 Or i to a, what am I going to say? Yeah
 So all that's the same is the fact that we are reusing the name of the function
 And this actually goes back to our first slide or one of our early slides where we said object oriented is about behavioral things, ADTs were about structural things
 Okay, I think there's a bit of a repeat slide
 But with overloading we use the same symbol to refer to different implementations, think about how we did plus with ints and floats
 With dynamic look up, we aren't exactly doing the same thing
 And here's an example of why
 At the same time it's an example of why we can't do this at compile time
 So consider actually any old language with arrays, c sharp, c++, Java, really anything that has this style of syntax
 What we are doing here is we have two arrays, an array of a and an array of b
 We iterate through zipping them together basically and trying to add the elements at each index, assuming they're the same length and we can actually add what we are saying is send the message of add with this argument array bi to the object array a at i
 And we're going to have to figure out what plus means at runtime
 Why do we have to do this at runtime? Why can't it be compile time? Actually give that a minute of thought or two minutes of thought and talk to someone next to you about why can't we do this at compile time
 Think about maybe the lines that would come right before this, for example, but chat amongst yourselves
 So sometimes you can figure it out at compile time
 But you can't always
 If you know the type, sometimes you can, sometimes you can
 When can you not figure it out at runtime or at compile time? That's the question
 If you know the type
 If you know the type, then you can
 All right
 What did we come up with? What do you guys think? Why can't we do this at compile time? Why do we need to do it at runtime? Any ideas? Yeah
 So there's some list shenanigans of like the indexing at runtime
 Let's assume they're the same length
 But you are on to something
 Yeah
 We don't know that they're actually the list
 Let's say that we do
 But we don't know what's in them
 I agree with you there
 Yeah
 Right
 So maybe these arrays aren't necessarily all the same thing
 However, we're operating in a reasonable language
 If you tried to create an array of lists, an array of ints and floats in Java, what happens? You can
 Right
 That's as far as I know, that's not possible
 But what you can do that is very possible and happens all the time, you can create a class A
 You can create a class B, which is a subtype of A
 So for example, animal and bat is a subtype of animal
 Then we can create a list of A
 And then we can add B's to it
 So our list of animals could have cats in it
 It could have dogs
 It could have bats
 It could have any animal in the list of animals
 And we don't know at compile time what each element is
 It could be that it's an A
 It could be that it's a B
 It could be that it's a C or anything else
 We have to wait till runtime to figure out that index two was a bat
 Index three was a cat
 This is something that we do all the time
 We create these lists of things that we don't really know
 We know something about them
 All the animals, for example, can speak is the classic example
 But we don't know anything else
 Some languages take this to the extreme
 You have something like Python or JavaScript, where your lists are actually very heterogeneous
 And you can add anything to them
 You can have ins or floats
 And you never know until runtime what is that thing
 And even if it is an integer, maybe you've rewritten what plus means for integers halfway through your program
 And so then you need to figure out at that point what you're actually executing
 Questions on this example here
 Yeah
 So your method will still remain the same
 You would actually know at compile time what you're executing
 It would be this if statement to choose what you want to do
 But the compiler would know that's the method that you're going to execute
 Unless you have the if statement it like wrapped around here in which case once again the compiler would know what to do
 Yeah
 So as far as I know, there's no state based dynamic look up, although there is actually an interesting homework question
 And I think I took that one off the homework, but there was a proposal to add something like that to C++ that eventually got rejected
 And so it's not actually implemented
 But the idea of having dynamic look up based on state
 So it is possible
 I don't know of any languages that do it
 Any other questions
 We can talk about other things too if you want
 Anything to distract from objects
 Okay
 So dynamic look up is not overloading overloading the meaning of an operation with some arguments is always the same
 This is taken to the extreme in Haskell where everything is cashed and we can just beta substitute all the time
 That's not necessarily always the case
 But the code to be executed can be resolved at compile time
 So the compiler can do more work dynamic look up on the other hand
 Your object message depends on the arguments and the message and the object
 And you're going to figure this out at runtime
 We don't always have to
 So notably
 If we didn't have this class B and all we were doing was adding a to our list of a
 Then we would always know that we're calling the same version of that function plus because a is always a everything inside of that list will be an a
 It's only when we get to this point of inheritance and sub typing that we need to start considering that we don't know what's going on
 Or if you're in a language like JavaScript or Python where we just never know what's going on
 But something like Java or C++ you're fine here
 You don't need to do any dynamic look up here
 Yeah
 So the meaning of operation args is always the same
 What that means is when we look at a line of code like this
 We always know what function what method what lines of code will be executed right here
 Add with integers will always call the integer add
 The actual lines of code executed will never change
 Whereas in dynamic look up add with three and four might be different depending on what object is receiving the message
 Okay
 What was our second core principle
 Yeah
 In capsulation or abstraction
 The idea here is we want to restrict the access to a program based on an interface
 When you create a new tool you don't let the outside world use all of the little inner workings of the tool you just expose the important pieces
 Why do we do that
 Why do we use encapsulation or abstraction
 Yeah
 So we have two different methods
 Both simplicity and security
 I think two great reasons to use encapsulation
 One, it's simple
 What it means is anybody who's using your tool only has to think about the two different ways that you said you can use it
 They don't have to think about the hundred different methods that exist inside of that object
 And then security what if you have like sensitive information in there that you only want to expose after you've been authorized
 For example, encapsulation can help with that
 So the user of the component has this abstract view
 The object is a black box to them and we just send messages and we expect some results coming out
 And we can only send some types of messages that they've told us we can send
 So that's great
 Specifically, we operate by applying a fixed set of operations provided by the builder of the abstraction
 That's just a fancy way of saying you can only do what they tell you you can do
 You can't try and add strings if there's no API to add strings
 You can't hit the HTTP endpoint that doesn't exist
 Well, you can, but you'll get a 404
 And the nice thing about this is that the builder still has that detailed view
 So we have this duality of the user having a very simple, secure, hopefully view of the world, the tool, the object, but the builder still gets all of the nitty-gritty detail that they need
 So they can operate on the actual representation of the object
 They get to know what's inside of the black box
 But the user never has to worry about it
 Questions on encapsulation or abstraction
 You guys have used this one a lot, for sure
 So you've also probably used subtype
 What is subtype? How many of you have created a subtype before? If you aren't raising your hand, you're lying
 I know it
 What is subtype? Or you're new to CS? How many of you, this is your first CS course? Okay, what I thought
 So you've all used subtype
 What is subtype? Yeah
 So subtype is all about the interface, which ties in with abstraction very nicely
 It's about the external view of the object
 So a point might have an x and a y and a move function, and the colored point might have x, y, move, and a color attribute
 And the subtype is the relationship between two interfaces
 And this little carrot face is the symbol that we use in mathematics to talk about a being a subtype of b
 So if an interface of objects of a objects contains the whole interface of b objects, a objects can be used where b objects are expected
 And that means a is a subtype of b
 So a carrot smiley face b
 Colored points are subtypes of points
 If you were previously using a point, I can substitute in a colored point, and there will be no issues with the interface
 Questions? What do we think? Yeah
 Is this basically inheritance? It's a great question
 Can we get a vote? What do we think? Yes? No
 Can I get some explanations? Someone who said yes, or someone who said no? They do
 And how many of you have written 90% of your code in Java? Well, actually, okay, no, that's what I thought
 Yeah, most of you, many of you, in which case maybe they are
 Strictly speaking, subtyping is number three, inheritance is number four, because they are different to a PL nerd
 Again, when you're out at a fun party, telling everyone about your awesome lectures in 538, you don't need to correct them on the subtyping being super different than inheritance and how they don't mean the same thing at all
 That's so lame that you would think that
 Use a different language
 They are different colloquially, they are often conflated because languages choose to implement them in the same way
 But subtyping is a relationship between interfaces
 Inheritance is about the implementation and reusing code that another place has already defined
 We inherit previously written code
 That's what inheritance is about
 It's not about inheriting an interface
 It's about reusing code
 So you inherit the code and supporting mechanisms
 The primary goal is language, it's a language feature for code reuse
 New objects can be defined without having to rewrite the same algorithms over and over again
 We just get to say, yes, this is how you print this thing and it's the same way that you printed the other thing
 Or this is how you multiply these two things, the same way you did it before
 Okay
 So we know that they're different
 However, does subtyping imply inheritance? What do we think? Got a gut response? Yes? No
 Okay
 You guys got to get faster guts
 Start feeling one way or the other
 Yes or no? Why? What's the reason? Yeah
 So you can be quite sensitive to the way you do many things where you really have some type of experience
 I mean, wherever you do, you can detect things like the use of subtyping, but for inheritance, but that doesn't mean that you have to have to inherit any of the top of the use of service
 Yeah
 So we have said subtyping means you must be able to replace, like replace all your points with colored points, but that doesn't actually mean we need to be using the same move function that the original point class had
 In fact, the whole point of replacing colored point or point with color point is that maybe we have a new move function
 So no
 This doesn't imply sub inheritance
 This slide I've left in because it was the first slide that I ever changed
 The transitions are not great
 So we might have a point with x, y move in a colored point with x, y move in color
 This implies a subtype relationship
 The color point has the same interface as the point plus a little bit
 So color point is a subtype of point
 However, move might be defined on the point as a function of dx, dy, modify this way
 And we could inherit that move
 We could say that the colored point move is equal to the point move
 But we could just as easily say actually when you move colored points, it's chaos and they just go wherever you want
 And now we aren't using any old code
 We aren't reusing code
 That means no inheritance
 So subtyping does not imply inheritance
 Naturally, does inheritance imply subtyping? Does it go the other way? Let's do another gut check
 Be faster this time
 How many people say yes? It does imply subtype
 How many people say no? Does not
 All right
 Way more you participated
 I appreciate that
 But still equally split
 50-50
 Can I get an argument either way? Yes, no, why? So no, because what if we only inherit one specific function? Seems reasonable
 Do any languages do that? Yes
 There are languages that do that, but they don't call it inheritance
 What languages? Yeah, definitely
 In JavaScript, we can just use some other totally random function that has already been written
 That's inheriting code, definitely not implying a subtype
 I would say there are actually languages that do this explicitly, though
 What language explicitly has inheritance without subtype? Or languages? I guess we already covered JavaScript
 Python, same way
 Have any of you done private inheritance in C++? You can inherit the class, but inherit it privately so that you don't actually expose any of the inherited features
 Why might you want to do that? Yeah
 Maybe we need it for our own internal use
 We still want those features
 It's just the user shouldn't be able to use them
 Yeah, definitely
 Why do we care about all these? Why are we using objects in a world? Oh, yeah, yeah
 That question, yeah
 Well, it could be methods or it could be state, right? So the user, we might do private inheritance where we just want to modify the API, for example
 We want the same idea of the API, but we want to edit it a little bit
 We need to add in a new parameter to our function that's very similar to the old one
 So we reuse the old code, but we get to add our own parameter and have a new interface
 Yeah
 You'll have to tell me what are access modifiers and Java? Oh, yeah, yeah
 Sure
 No, it's not the same thing
 That having private versus public classing and functions and things of that sort is much more of a encapsulation topic where we might only have a few of our functions be public
 And that's what defines or that's what encapsulation let us do
 And then it ties into the idea of that creates our subtype or our interface, which is about our subtyping
 So they're all connected
 They're definitely all connected
 Any other questions on subtyping and inheritance? And that is the point of this slide here is to say dynamic look of is cool because it lets you do dynamic operations
 Great
 We will talk more about that next week
 But these other three abstraction subtyping and inheritance tie together where they all work in the same area to make your code organized to have an interface so that you can extend concepts with components and you can reuse code without having to just copy paste everything
 So all of that this whole abstraction subtyping and inheritance
 The reason why we do this is to write clean code
 We don't want to write bad code that other people can't read
 So it's a small factor in why I am here teaching you guys is so that you guys are going to go off and write code
 As a consultant I work with other people's code
 It is very much in my interest that you guys write good code so that when I have to come and read it, it's going to look nice
 It's going to be understandable
 It will be encapsulated in a way that I can actually parse it
 And the interfaces will be clear and all of this good stuff about code
 But it does come at a cost
 And this is actually something that recently got a lot of attention through a news article that I meant to put in the slide day
 But there's this guy who's a big time game engine developer
 He's built like a lot of the unreal stuff way back when talking about how clean code sucks
 Because when you write clean code you add all these levels of abstraction to your code that slow everything down
 And he shows that when you don't write clean code you get 10x or I think it's 14x performance boost in some areas
 So clean code is great because it makes my life easier to read your code but maybe it actually is going to harm you in other ways in terms of the performance
 Always something to think about
 That covers the core concepts of object oriented program
 I'll leave you guys
 Oh actually no this is a perfect time
 I want to do I didn't I didn't make a slide for it
 But I want to do this
 Let's do another one of these
 Take two or three three yeah three minutes chat with someone next to you
 What's the merkeys point what's the weirdest thing that we've talked about today that's like why was it that way what was that thing
 Talk with two or three people around you about this I'll give you three minutes so we'll join back at three twenty five
 Yeah
 Yeah
 All right you guys are quieting down a bit early but that's fine
 Let's chat
 What can you clear up
 Yeah
 Yeah so sub typing actually let's start with inheritance this time inheritance is code reuse
 That's all it is
 It means this function is being reused in a different object object a defines function move object B doesn't redefine function move it just uses object a's version of it
 So that's inheritance just code reuse but without the copy paste
 Sub typing is object a has a specific interface
 It's got an x y and move object B has a slightly different interface x y move and color
 So they have the same ish interface which is to say we can use the object B anywhere object a was being used because they have the same
 They have the same set of exposed features
 So colored point is a sub type of point because color point has all of the same interface features as point does that's what makes it a sub type
 Good
 Yeah
 That's just what the language designers wanted that's what they decided to do in other languages that's not necessarily the case
 Yeah
 So the little operator with the carrot smile thing that flips either way
 So you read it as like well okay I mean I have my own visual of like how to what it means of like it's going into that but yeah so the greater than sign points to the sub type
 And you could have it we could put color point on the left or right as long as you flip it accordingly
 So it's a directionally important operator
 Yeah
 Yeah so in Java we could have point in color point and color point doesn't mention point at all
 Those are not sub types in Java in Java those are not sub types because we can't actually use the point the color point anywhere we would want to use a point
 So mathematically speaking we might say this one has a sub type relationship with that but with respect to the language itself and Java it's not a subject
 Yeah
 So you're playing how it's like I haven't used Java in too long to give that credit
 Yeah
 But implements is only for interfaces which means that you have to define all of your functions in there and extends you get extends is like inheritance plus sub typing
 So you're playing implements might only be sub typing and no inheritance
 So they're kind of separate a little bit
 Is that fair? You guys know more Java than me probably
 Do you have an idea or you think that's fair? Oh okay so there you go
 So you might even get some inheritance sneakily with interfaces
 Yeah
 Yeah
 Yeah
 These two ideas sub typing and inheritance go together
 They are very much like language designers think about them in the same bucket when they're coming up with how they want to handle these things
 So you have to address them together
 You can't just say I'm going to do the sub typing thing
 I'm going to do the inheritance thing and the two people developing those features are ignoring each other
 They're related
 Yeah
 What else came out of the merkeys point? Is sub typing another name for polymorphism? No
 I would say sub typing and inheritance together kind of capture most of the idea of polymorphism
 But neither one alone nor both of them together are the full idea
 But we'll talk more about that in next week's lectures maybe
 Yeah
 Yeah
 So it depends on what you mean by it doesn't mean sending a message literally because it is sending a message to the object
 The object is a collection of data and code like methods
 So you give that information to say do this thing
 Like here's a message
 Here's arguments
 Execute some code inside of this object
 Sometimes that is as explicit as a web server receives an HTTP request or a server just in general receives a remote procedure call an RPC
 So sometimes it does literally look like sending it a message inside of your like kind of single program Java code
 It still is basically sending a message
 But it looks very similar to everything else that's going on because it's all just one thing
 Yeah
 There is no dynamic look up in Haskell as far as I know
 I'm pretty certain that that's true
 Certainly not in standard Haskell
 But you might be able to do something weird
 I don't know
 I'll look into that
 But it's not like the typical way that functions get resolved
 All right
 Let's talk about objects as activation records
 So we talked about activation records as activation records at the start of class like way back when with JavaScript
 Now what we're thinking is what if like turn back the time it's it's 1960 people have just started doing functions like this is cool
 We can have the same code executed multiple times without having to rewrite it all the time
 We're no longer working with assembly
 So let's now also create this idea of an object that's wrapping some information
 So we might create a point class where we have some functions defined inside of that class
 And all that we're doing is when we create a point we create an activation record where we have these two functions defined inside of that activation record
 Then when we call point equals we go look up inside of the activation record
 So all that we are doing is returning a pointer from our activation record
 Or and pointer points to the activation record itself
 So it might look something like this
 We would create a new point with one dot zero and two dot five a new point with you know two dot zero two point five
 And these points just like before where we have our kind of box like activation record the point points to an activation record
 And that activation record has its access link just like before and it also has these functions defined where point one dot equals is the code for equals
 What do you guys think about this is this reasonable
 What could be some issues with it or inefficiencies yeah
 Yeah definitely we're kind of like duplicating all of this storage here that equals and distance that that should be per class not per object right
 Unless you want it per object in which case maybe you do have it there but definitely if you wanted it per class you would want to abstract that away
 What else do we think any other thoughts about activation records for objects
 This is pretty reasonable it might be inefficient and you know you might want to do some extra things here but we can create our own like fake classes and fake objects in JavaScript by doing this or in Python
 I actually just wrote some code earlier today that was creating like a fake class that had state but really it was just wrapping a single function for me
 So it didn't really want to be a class this approach works and it's basically what the state of the art was for you know 30 years
 So Simula 1962 developed in Norway of all places and it's the first object oriented language
 It didn't talk about objects so it didn't know what it had done but everyone coming after attributes their object oriented style to Simula
 Simula had classes where that's how you created the activation record the objects were just instances of the class you could access the variables and functions inside of your object with dot notation
 So if you ever wondered where this style came from it's 1962 and it was memory managed they had garbage collections to clean up your activation records
 A lot of the same stuff that we do today 60 years ago
 Simula also had derived classes so we've talked about sub typing and inheritance
 Simula you could create a class a and then you would prefix the next class that you wanted to be a sub type of a
 And all that that meant was that you would just in the internal representation you concatenate the previous class with the current class
 So your point is concatenated to your colored point and you just stick them together in memory and say it's a point but it's got this extra feel
 A simple approach functional but not functional
 So here we had inheritance and sub typing together they were very much the same exact thing you could not inherit without sub typing
 And this is where we started say D is a sub class of B
 B is a super class of D
 Your colored point would look just like your point but you're just stacking on another feature for it
 And you could override the equals and all that would happen we wouldn't get rid of the point equals we would just add another closure for the colored point equals
 And that's similar in a nutshell
 The point of similar was to create these activation records and show that we could have some structure to the data and functions living together
 So we had classes objects sub typing and inheritance but we didn't have encapsulation there was no way of making public versus private distinction we couldn't reference super or self so we couldn't actually talk about our own features
 Both of those both encapsulation and super and self are very important to actually writing like clean code
 So there's steps to go but the base structure was here from 1962
 Simulow was used for like physics simulations apparently that was its primary purpose but it got revived like 10 years after just for being a general purpose language for whatever reason
 All right I've got one more history lesson language to chat about before we end for the day
 Oh and I don't have office hours this week by the way no office hours this week I will make it up to you at some point probably shortly before the midterm
 That's when everybody wants them anyway right
 So let's look at a slightly different feature of object oriented the dynamic side because the static side is really cool and we've talked a lot about that but dynamics are really cool as well small talk object oriented language where everything is an object
 This was the pilot of the idea that like everything should be one thing
 Linux was coming out and they're like everything should be a file except for a few things that we don't want to be a file
 And then they redid Linux with plan nine where they said no literally everything is a file and nobody wanted to use it
 Small talk is like that they said literally everything should be an object even the classes themselves
 And the reason for that is to address that notion of self we can talk about the class as an object and reference it inside of the object
 Everything is a message to an object and this definitely popularized objects it also had the first idea of a tablet the dine a book which is what that caption says if you can't read it was developed or it was prototype in the seventies by Alan Kay I believe as a language specific device
 It was for early learners so elementary school middle school to teach them how to program in small talk
 So it was intended for non programmers this was not like an industry language and the syntax was really weird and was actually built into the editor
 So you were kind of working with these blocks I think I've you know it'd be something like this that's your editor
 Actually I have a let me see this was just on the front page of hack and use this was the small talk editor and you're you're literally like clicking on the things that you want to talk about and edit
 So a very different approach to programming in general
 The same stuff here is before whatever small talk small talk small talk chat
 The objects themselves the points had class information so they were a point the super class they could reference they could talk about the point has a super class of the object and then it had class variables instance variables everything that you're kind of used to in objects and it's all stored in tabular form
 The actual syntax here is extremely unimportant but also really weird
 They use mixed fix selectors so when you wanted to get the value x from a point you'd say point space x when you wanted to set x and y on a point you would say point x colon five y colon three
 This is a small talk code
 How do you read that? It's more vertical lines than anything else and yet this language yeah so I mean you can kind of tab through these it kind of makes sense it it was also the number three language on the developer survey as being the favorite language that developers were working with in 2022
 So it's done some weird things but it's also got some things right mostly slides will probably come back to but the important one is that in summaries all of small talk went into scratch
 So many of you are probably familiar with scratch that is small talk well it's a dialect of small talk built on what's called squeak actually is the underlying language there
 But yeah so I mean it went from being this early education tabular language to actually a kind of successful early education tabular language
 That is all for today I will get back to you on Wednesday lecture to see if that's actually happening but don't count on it
 So some beautiful means we can be changed
 So if we try to do this it would be an error
 Yeah so for example in JavaScript we were using the immutable error list
 So that's right so the immutable list in JavaScript doesn't let you actually change the list
 So whenever you do an operation you get a completely new list back
 So you don't have to actually write like C++ code just describe what you would do
 So we would create a shape class that would have a rotate function and we would create a you know you just describe what you're doing you don't have to actually do it
 If I just throw you a talk it I don't know if you write actual code that's also fine
 That will make it easier to represent what you're trying to do
 I mean yes and no right like JavaScript and Python it doesn't and private inheritance it doesn't we can't
 you you you