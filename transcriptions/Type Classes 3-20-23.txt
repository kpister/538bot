 Welcome students
 Today we will explore the fascinating world of type classes in Haskell
 This is GPT4
 In case you were not aware over spring break, it launched or it was released
 And it's slightly a closed access, but if you have any fun ideas for what you want to do with GPT4, come let me know
 I have access
 So welcome back from spring break
 Let's talk about a few things
 How's the mic volume, by the way? Is it too loud? Is it good? Good? Okay
 So updates in the world, GPT4, this is awesome
 We have no idea what it is because they won't tell us
 They released a paper about GPT4 in which they said literally nothing about what GPT4 is other than that it's really powerful
 They said here are the results
 Basically they got rid of the first three sections of the paper and just showed what it can do
 So we don't know if it's huge, if it's small, if it was trained on a lot of data
 Who knows
 But regardless, very exciting because the things that it can do are spectacular
 In particular, the creativity
 So fun to mess around with
 Anyway, that was my spring break
 Now we can take a 30 seconds, everyone say what they did on their spring break maybe
 Go around the class
 No
 The midterm and in general your grades are up and online
 If there are any issues, please let me know
 I have posted the solutions
 I have posted the specific grades for each question
 So you know exactly where points were taken off and why? If you have any issues, let me know soon, not at the end of the semester
 I think the class average was a 61 out of 90 or something like that
 It's about a 70% 71%
 This is the overall distribution
 That's a pretty standard bell curve
 So maybe it's a little bit lower of an average than I was hoping, but it's roughly where I was expecting it to be
 So that's good
 I have a new plan for grade percentages
 It goes something like this
 16 assignments
 This is what we said at the start of class
 So nothing changed there
 8 programming, 8 written
 These will make up 64% of your grade
 Each programming assignment, each written assignment, are 4% of your grade
 There will be two midterms
 You've already taken one of them that are each worth 10% per total of 20%
 Then the take home final is like a short paper of sorts
 You'll work in groups
 I'll tell you all about it at the end of the semester
 That will be worth 10%
 And it will be more like a homework assignment than the midterm that you took last week
 Participation is still five points
 bonuses, extra credit remain the same
 If you add up all these numbers, you might wonder, this is out of 99
 Everyone gets a point for free
 So Canvas overall grade, where you see my grade right now is 84%
 That is using these weights
 So that should be up to date with all of the assignments that you've done except homework 4, which we're working on with this weighting scale
 Now, one of the things that's been dropped is the idea of best 2 out of 3 for the midterm
 I told everyone that that was the plan at the start of semester
 And if that is something that's concerning for you, come talk with me in office hours or like schedule of meeting
 And we can talk about how to specifically weight points
 But my hunch is everyone's doing quite well on programming assignments and homeworks
 So the fact that those are worth more will hopefully kind of solve everything for you
 Yeah, grades, questions on grades and weighting
 Yeah
 So 90 and a 93 and above guaranteed to be a 90 and a 87 and above guaranteed to be a B
 You know, that that's kind of the pattern
 And then it might be a little bit lower than that depending on how the class is doing
 So it could be that 90 and above is an a depending on how things are going
 Yeah, yeah, yeah, most of the lecture is not on slides though
 It's going to be on blackboard, but I'll upload these slides to canvas
 Yeah
 Any other questions on grades or midterms stuff
 All right, always feel free to ask questions on Piazza homework and PA five are released
 They came out last night or yesterday afternoon
 Go ahead and get started after today's lecture
 You will have most of the materials to do them
 The PA is in Haskell
 The homework is also in Haskell
 Finally, most exciting to me, perhaps least exciting to you
 My wife is having a baby next week
 The due date is literally next week
 So I fully intend to be here Monday and Wednesday and teaching you guys about object oriented programming
 However, these things are not exactly what you plan
 So I'll keep you posted on Piazza if anything changes
 Otherwise expect normal, but verify before you show up to class
 Yeah
 And miss out on object oriented programming
 No way
 Yeah, no, Haskell was passed up in the name list unfortunately
 So anyway, those are the notes for today
 Now it's time to talk about Haskell
 All right, let's turn this guy off
 Put this up
 Put these on
 All right
 What is the type of plus in Haskell? A seemingly simple question
 We can do an expression like this, three plus five
 What's the results of three plus five in Haskell? Yeah
 The number eight
 It's eight
 Excellent
 And it's an integer
 All right
 So what is two point two plus three point? Yeah
 Yeah, five point two ish
 Depending on how floating point is being represented
 But probably pretty much exactly five point two
 So what is plus? What's the type of plus? We were able to add two integers here and two floats here
 Yeah
 Is it like a type four? A type what? Like a type four or like a union of types? Right
 So what idea is saying, okay, maybe it's it's this function that takes two different types of types
 And it can handle integers one way and it can handle floats a different way
 I think that's a great potential way of solving this problem
 But let's see
 So that's one solution for how we would implement it
 Is that we would have some pattern matching on types
 Well, let's actually take a step back from this question here
 And think about a slightly different question, which is that we might want to write a function square x
 Right
 Square is a function that takes in a parameter x returns x times x
 How are we going to solve this? What's the type of square? We can say
 So these two problems suffer from the same overall condition, which is that we want to be able to pass in integers and we want to be able to pass in floats
 But one thing that we've said about Haskell before is that it's extremely strict
 It doesn't let you do weird random things with types
 It's got its rules and it sticks by them and you have to follow them
 So what can we do? We've said that plus can pattern match on types
 But how would you actually write code for that? Yeah
 If you have an idea
 Yeah
 Well, I guess like without the square one you could do like case x and then I don't know how to check things in Haskell
 If there is like type of and then you would check for like n to whatever and then check for love and then you would give the versions of the form
 Something of this sort, right? We could say if x is an int, do whatever, if x is a float, do whatever
 This is almost exactly what you would do if you were writing Python code
 In fact, I wrote code like this just yesterday where based on the type of the input, do one thing, type of the input, do a different thing
 What's wrong with this in like fundamentally what's wrong with this in Haskell? It's exactly that
 Haskell is all about it's statically strict typing
 This is doing runtime type checking
 So we're still going to be left with the problem of what is the type of x at compile time
 And we can't handle things dynamically based on their type
 We need to handle everything statically based on its type
 So, okay, we can't do something like this
 Yeah
 Yeah, so we can have square int is x
 And we can use the Haskell primitives here
 There's molt int x x square float x x
 We could write two different functions
 This one uses the primitive float to multiply two floats together
 And the type of square f is float to float
 Square int uses the int multiply
 And the type of square int is int int
 Now, anywhere we want to square a number, we go in and we say use the int version if we're working with ints, use the float version if we're working with floats
 Yeah
 No, no, because the type of square, so square itself, we have not solved
 Square, we still don't know the type of
 But we've created two new functions that have very explicit typing
 So square int is int to int
 Square float is float to float
 You can't pass an integer to square float and you can't pass a float to square int
 Yeah
 That's what we'll build to
 But we won't get there yet
 So this is one approach that we can take
 And this is exactly what you do in Java, in C++
 You define your function five different times based on the five different types of inputs that you want to be able to pass to
 Which is cool except look, these are doing the same exact thing
 It's just a different operation
 So wouldn't it be nice if they could both be just one square function and it just knows how to handle ints and floats
 In order to accomplish that, we can look at the similarities between these
 Square int and square float
 What do they kind of boil down to if you wanted to create a one layer abstraction over them
 How would you change these functions so that they're more similar
 Yeah
 So we're only working with multiplication
 So we only need to handle multiplication generically
 How would we do that? It sounds like you're on the right path
 If we don't need all of the numeric operations, we just need mold
 Right
 So if we had a specific multiply operation for each of the types that we wanted to multiply, then we could kind of look up the right way to multiply the type that we're working with
 In code, what that means is these functions boil down to operation xx
 x is our input such as 3 or 2
2
 The operation is either going to be mold float or mold int
 But in order to know what operation do we want to do, we're going to have that be a parameter of our function itself
 So we're going to redefine square to be square up x
 Square is now a new function that takes two parameters, the first of which is an operation
 The second is a value
 So then how do we actually use this function? How would we square 2
2? What would we do? Go for it
 Yeah
 Yeah
 Square and mold float
 Square mold float 2
2
 And so what we're saying is, here's the function that I want you to use in order to square these numbers
 Here's the input I want you to operate on
 And here's the operation to run
 Questions
 Yeah
 That's right
 We do still need mold float mold int
 These things need to exist so that we can
 So we know how to actually multiply two floating numbers together or add two integers together
 Yeah
 Is there a way to specify that we only want to be able to pass in mold float or mold int? Yeah
 So this is an interesting question
 We've called this function square up x equals blah blah blah
 What happens when I call that line of code? What happens? How many people say six? How many people say nine? How many people say type error? Okay
 Most people are sitting on six, which is actually what will happen here
 We have done nothing to specify that this has to be multiplying things together or anything of that sort
 In fact, what is the type of square? If we had to square is of what type? Give me the first parameter type
 Yeah
 Yeah
 Tao one
 Tao one
 Anything more? Okay
 I like it
 It's Tao one to Tao two to Tao three
 What do we know about these types? And in particular, we're allowed to look at how we're using this function
 Yeah
 T two and T three are the same
 I like it
 What else do we know? Yeah
 Almost
 Exactly
 So Tao one is Tao two to Tao two to Tao two
 We know this because of how we're using it
 Multi float is float float float plus int is into int to int
 This is our type
 We would actually write this and GHC will tell you that it is A to A to A to A to A
 So long as you provide a function that is A to A to A and you provide an input of A, this code will run and it will give you something of type A
 So we could also pass in something like square concat or more specifically because concat has a slightly different meaning plus plus, which is how we add two lists together and then we get a list back
 We could also square using the concat nation operation with a list of strings
 There's nothing stopping us from doing this
 So we've kind of solved our problem but we almost went too far off the deep end
 We're now we're saying, okay, we have this generic square function but it's kind of funky where we're running into some extra cases that we aren't supposed to be able to do
 And what that's going to lead to is that we get less generic types later on when we want to use the results of square
 For example, if we wanted to square square of four, something of this sort where we wanted to or add to the results of squaring a number
 We want some more guarantees about the fact that what's coming out of square not only was it being multiplied together but we can then add to it or we can divide, we can subtract
 In fact, there's more to squaring a number than just operating twice on that number
 Okay
 Where have you seen something like this before? This pattern look familiar from C or C++ Python? Because you might have actually you've almost certainly used it in other classes
 A function that takes an operation that tells you how to do something in that function
 Yeah
 So in Python, we can have sorted list of objects where the key is a lambda x x one for example
 So sorted is a function that takes a list of objects of anything and then you can pass it a function that tells you how to compare the objects inside of that list so that you can sort based on the key of a dictionary or the values of a dictionary or if the object has a height because it's representing a person you could sort based on the height
 Same thing goes for q sort in C or C++
 You pass it a function pointer where you say here's the way to sort these two objects or the types of objects that are in this list
 So this shows up this sort of pattern shows up quite often, not just in Haskell
 Questions? We can take a pause
 Alright, well I like where we've gotten to here square op x is equal to op x x but now I want to solve for the second case where I want to be able to let's not do square square
 We should be able to say z is equal to three
 So we can add square z equals add square z
 Alright, our function takes a parameter z and it will add the square of z to the square of z
 Nothing too crazy
 Now z here we know wants to be some type of numeric value
 We're going to be able to add things and square things so we have to add and multiply
 We could be subtracting in the future as well
 Before we do how would we write add? What would add look like? So it takes two different values, right? So we aren't like double, it's not double but add should take two different input values
 x y but is it just that it's equal to plus x y? What needs to be changed? How can we make it in line with square? Yeah, we're going to have an operation still
 So add takes an operation and it takes two values and then it will pass those two values into the operation
 Notice how similar in their abstract form square and add are
 Okay, but now we want to be able to do something like this
 And this was where we come into this notion of what do we want to be able to square? What do we want to be able to add? What do we want to be able to subtract? We want to be able to do these things on numeric values
 And those numeric values might be two or three point three or they might be three over four, it might be rational, things of that sort
 And what we can try and specify is that all of those different types will be able to be added and will be able to be squared and will be able to be subtracted and they will be responsible for telling us how to do that
 The way that we can keep track of this so that we don't have to, for example, have function here take actually
 How would we rewrite function to use this operation notation? What would you do? What would we need to do based on how we've written it out so far? Yeah
 What does opera present here? A function that does what? So start, let's start by looking at square and add
 We are using square and add up here but we need to rewrite how we are using square and add so it's in line with our current definition of how square and add should be used
 So first of all add doesn't just take an x and a y, it takes an up
 What should we pass as the up? Plus, what plus? Yeah
 And how do we know what type we're using for square? Part of the up, which up? Yeah
 So, okay
 I like where this is going
 We want to be able to say this square is operating on maybe integers, maybe floats
 We want to either add in to those squares or floats to those squares depending on what we're doing
 But we don't really know that yet
 We can't know that yet
 How can we get a value for plus? Yeah
 We can't do anything at runtime
 This is all static
 The compiler has to figure it out
 What did we do over here? When we had the specific thing that we wanted to do in order to make it generic, we said it's not our problem as the function
 It's your problem as the developer
 You need to tell me how to add these two things together or how to multiply these two things
 We're going to do that same process here
 And we're going to say our function now needs to take a plus op
 And I'm going to run out of space here
 Our function should take a plus op
 That is, the person who then calls our function needs to tell our function how should we add two things? Yeah
 It can, to some extent, and it does to some extent with type classes, which is where we will get to
 But we need to build to how can we do all of this? So, okay, we've got plus op and plus op
 This is part of add
 What do we do with square? What's our first or our second parameter to add? Yeah
 Yeah
 Can we pass z? Square looks like this
 It needs two parameters
 Yeah
 That's going to be the whole problem
 Square is the whole problem
 All right
 And so it comes together
 Our function fn now takes three different parameters
 And the goal is that the person calling our function tells us how to add, tells us how to multiply, and tells us what they want us to do those things
 And then when we use add, we pass in the plus op
 And when we use square, we pass in the multi op
 So a final call of using this function, we might say function plus int multi int four
 And now we're telling the function
 Here are the useful functions that you will need to use to compute everything inside of your function
 Yeah
 So, yes, we need to have plus op multi int this style of function defined for every type of function we might want to call fn with
 If you wanted to call fn with strings, you need to have a way to add strings and multiply strings
 And if you came up with a way to do that, then it would be perfectly valid for you to call function with strings
 Yeah
 Why would you need a way to add strings when you can pass any function in there that operates in terms as long as it matches whatever type is the thing
 Yeah
 So why do we need a way to add strings if we could just pass in any function here
 And so long as it works with all the types, we'll be fine
 That's totally fine
 Your add string could be something that just takes the first string and returns back the first string
 And it doesn't actually actually add anything together
 Similarly, we could pass a different version of plus int that subtracts two ints
 And there's actually nothing that this function fn can do about that
 That's on you, the developer, to write code so that it's in line with how the code is supposed to be used
 But we can mitigate it
 Because when we look at something like this, this is great
 But what if we also wanted to subtract things? And what if we're nesting? And we have 10 functions deep into this thing
 And we don't want to keep track of all of these pluses and minuses and multints and multfloats
 So what we can do and what Haskell has done is create what are called type classes
 And a type class, so type class
 Roughly speaking, a type class is a set of operations for a type to implement to be part of that type class
 The type class is a set of operations
 For example, the numeric type class
 What operations exist in the numeric type class? What do you want to be able to do with numbers? Regardless of if they're floats or if they're integers or if they're rational or something else
 We want to be able to do arithmetic
 Add, multiply, subtract, divide, what else? Yeah, modulus, maybe
 Can you do modulus with floating point? Sure
 You can come up with your own version
 But is there like a mathematically? Yeah, so those things
 The numeric type class also has a from int, I believe, or is it to int? I forget which one it is
 Where you can always convert something from an integer into a float
 And that can be useful as default values
 All right, so a type class is a set of operations
 What that means is that now we can say instead of function that takes these two different distinct functions that say here's how to plus, here's how to multiply, we can take instead a type class
 And then we can take a type class
 And when we pass in to our function, we pass in the int type class, the int implementation of the type class
 So that then inside of our code, we know that we're doing int addition, int multiplication
 Yeah
 So it's just like, if we pass in the int implementation, they come back and develop things like all the other things that we would have passed in memorize
 Yeah, so let's build it
 Because I think that's the best way to actually see what's going on
 And we're only going to use Haskell that we already know
 We're going to create a new data type
 And this new data type is going to be a numeric data type
 And this data type will be generic for some type A
 It's parameterized on A
 And it will have a single constructor make numeric dictionary
 Okay, actually, I want this to be on one line
 So it's not confusing
 Let's go
 Okay, so this is the constructor for our type class
 And then in addition, it will take a function from A to A to A
 And for now, we'll keep things simple
 We'll just have two functions, one that represents plus, and one that represents multiply
 So we've created a data type that for any given type will store two ways to operate on that type
 The first one is meant to represent plus
 The second one is meant to represent multiply
 If we wanted to create a numeric integer implementation, we would say D int
 So a dictionary of D num
 Sorry
 A dictionary for the numeric type class for ints, the implementation for ints would be make numeric dictionary with what two functions passed as the parameters
 Yeah, Dan
 Plus int, multint
 And the purpose of this piece right here is to store these two functions in what is called a dictionary for the integer implementation of the numeric type class
 Yeah
 Is that the name of the name of the variable? So we could have called that anything
 That's to some extent convention, but loose
 It's a variable
 Yeah
 Yeah
 Yeah
 So this is not really Python
 Well, it almost actually is Python dictionaries with a key and a value in that we can give these specific names
 So we can give the plus function the specific name of this plus symbol
 And we can give the multiply function the second parameter, the specific name of the multiply symbol
 We don't need to, but we could do that
 How do we rewrite square and add to use this new structure where instead of passing in an operation, we want to be able to accept one of these dictionaries that will tell us how to square and how to, or how to multiply and how to add two things together
 What would we do to square? So our goal is instead of taking up, we're taking this or the floating point version of it
 How could we do that? I'm happy to sit in wait
 I know you've got an answer
 Just for me, how many people feel like they have an idea, but just don't want to say, because that's okay
 I'm not going to call on you
 I'm just, do you have an idea or am I off here on needing to explain more? All right, looks like we need to explain more
 Let's start by saying how I want to use this
 So if I were to square an integer, my new way of squaring integers instead of passing an up, will actually look pretty similar in that I will square them by doing dNumInt3
 So this is how I will use square
 I will also use it like this
 Sorry, no, I will not use it like that
 I will use it like that
 Add will be used like this
 Okay
 So here's how we're going to actually end up using our functions, square and add
 Now the question is, how can we rewrite them? Okay
 Go for it
 So what are we going to do right now? I love this idea
 So we're taking a parameter num, which represents our numeric type class
 And that numeric type class has stored in it the multiply function
 So we're going to access that multiply function for the numeric type class of whichever one were passed, whether it's the float or the int, and then we pass in xx
 This isn't quite Haskell syntax, but the idea is exactly what we want to do
 So I'm going to turn it into a slightly cleaner Haskell way of writing that
 But if we take a data type such as this, we can break apart the information that's given to us
 And we can pattern match on make num dictionary with plus and multiply, plus and multiply the two parts of the dictionary
 And then x is equal to multiply xx
 So the information that we are given is one of these dictionaries, which holds two values in it
 It holds a plus function and a multiply function
 We then use the multiply function with xx
 In order for our linter to be happy, we then erase the p and use an underscore
 So we don't get a blue squiggle in vsk
 Okay, we've got an idea of how to do square
 How do we do add? Yeah
 Yeah, pxy
 Yeah, so we do essentially the same thing that we were doing with the square function
 But this time we want the plus to come out
 And we're going to add x and y together using the plus from the dictionary
 Question
 Yeah
 So the wonderful thing about square and add is that they're still generic
 They work with either integers or floats
 And depending on what you give it, which dictionary you provide to it, it will do integer addition or floating point addition
 All right
 Two more questions before we get to the kind of real thing that people do
 What is the type of square? Yeah
 Where do I write this? I want you guys to be able to see
 Um, squares of type, you said num a
 It takes something of type num a
 That is one of these dictionaries up here
 It takes something of type a
 And then it returns something of type a
 Similarly, add is what? So, someone knew what's add? Yeah
 Num a to a to a to a
 One more
 Because our addition function took two parameters x and y
 Yeah
 But it looks very similar
 That's right
 This piece here
 Num a
 Is this type that we have defined up here
 Which means it's going to be like what d num int
 For example, is of type num int
 D num float is of type num float
 Which means they fit into those slots
 Okay
 The last step
 Re-write function or f n
 I don't want to erase anything
 So we'll do it over here
 What does function look like? Yeah
 So, if you are creating your entire setup, then yes, there's nothing stopping us from adding another function here
 For example
 But if we do that, then d num int needs to implement that function
 D num float will also need to implement that function
 All of our places that we use those dictionaries need to be ready to accept that other function as well
 So, yes, but no
 So, you can't call other things in dictionaries like the staff of the beforehand or future entries or set all you know f ones
 Oh, sure
 So, if we had the multiple uses plus for our implementation
 We could define multiply in terms of plus if we wanted to
 Yeah
 That is definitely possible
 And we'll do that on Wednesday
 Yeah
 Right
 Yeah
 We started with two different definitions of square where we had square int square float
 And now we're kind of at the same place where we have to come up with an integer dictionary and a float dictionary
 But where I would challenge you is that we didn't have to also create add int and add float
 So, this scales extremely well with the number of functions that use your given types
 But it doesn't scale as well with the number of actual types that you want to use
 Each type that you have has to implement all of the functions
 But then each function only needs to be implemented once
 Yeah
 So, the question of adding as better like other functions would that be easier to have like a dictionary for every operation and the key is the number type? That way you can get you got one out of other functions within add all the types
 I'm not quite sure I felt let's let's talk about that after though maybe because it sounds interesting but I'm not quite sure I got it all
 Let's go to function though unless there are other questions
 I'm happy to answer other questions
 But otherwise let's try and answer this
 Yeah
 But I like this
 For when we had the operations as our the parameters that we were taking to square and add
 Because this is exactly what we want to do where we want to get our dictionary
 And then we want to add using the plus version of our type and multiply using the multiply version of our type
 But what's the what does add take these days now that we've updated it add is taking a dictionary itself right
 So, how would you update it
 And let's use fewer characters just because I don't want to write them all we can just call that parameter D
 And then add takes the parameter D which will be a dictionary and square takes that same parameter D and the other square takes that same parameter D
 So, what we get get in the end is a function that takes a single implementation for example for ints or for floats
 And then it's going to add using that implementation and it's going to multiply using that implementation
 And now we're guaranteed that the thing that we are doing and what we're coming back with is going to stay using the same implementation throughout the entire piece
 We aren't somehow going to transform into strings halfway through and try and add strings together or something
 We're using the integer dictionary
 So, all the stuff that's happening in here is for integers or we're using the float dictionary so everything in there is for floats
 And because our function is high level we don't actually care about the dictionary itself that's up to add and square to figure out
 So, there was a question earlier in class why can't the compiler do this for me? And in truth it can and it does and that's what we're going to go into on Wednesday is how can we infer all of this and create a type class object that works very nicely
 Working with dictionaries I think makes it more clear what is going on there
 Last time I taught this I tried the other way around it didn't work as well
 Hopefully this time it works better
 I have here a review worksheet which I had meant to do all semester but now we're starting
 It is completely optional so I'm not grading these
 I don't want to look at what you write on them but the goal is that you guys get more practice because in the reviews earlier as well people are saying more practice is better
 So, take some of these, pass them around and I'm going to be wandering around and chatting with you guys about the problems to make sure that they make sense and help where they don't
 Yeah, where do you want it? I can do that
 Give me a minute at the start of this
 Yep
 Does anybody still need a sheet? I'm asking you to create a dictionary
 You'll start by saying here is the collection of data
 If you have information that my dictionary stores then you're going to figure out how can I actually use that information and you go from there
 I'm posting one of these on to Canvas as we speak
 For question number two there are men and you should not need men and max in for question number one
 Under the review folder on Canvas there is now this PDF labeled as review number one or review one
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
 Thank you
