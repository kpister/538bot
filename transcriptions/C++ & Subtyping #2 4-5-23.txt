 Thank you
 All right, guys
 Let's keep going
 These are my notes and updates for the day
 She's got a kind of Bernie Sanders look, I would say
 You know, like the scrunch face
 Earlier today, I put shampoo and tried to use it as face wash
 So I'm in a good place
 Any notes from class, from you guys
 Anything that I can address, anything going wrong
 Homeworks, programming assignments, questions, before we start talking, C++
 All right, then what we're going to be doing today is we're going to be talking about subtyping
 But slides are kind of boring, so let's start with some code
 How is that color scheme wise? Should I make it light? Is dark fine here? Font wise, how are we doing? Font size is okay
 Everyone in the back agrees? All right
 I had a chance to look over the survey results that you guys sent in for me, which I appreciate
 And many of you requested that we have groups formed at the starter class to kind of chat about class problems with
 So right now, find someone next to you
 Choose them as your partner
 I'll give you like 30 seconds or a minute
 You can move your seat if there's nobody's next to you, but find someone that you can talk to because we're going to be talking about a lot of questions I want you to have someone to discuss with
 So find a partner, sit next to somebody
 You can have two partners if you want
 You can be, you know, larger than two groups if you want, but find somebody
 Subtyping
 Oh, no, right now you're just finding a partner
 So if you found a partner, you're done
 Ask them about how their Tuesday was
 All right
 Now that you have a partner, I want you to start chatting about programming with that partner
 We have some C++ code here
 I want you to ignore the fact that this is C++ and think about it in a mathematical sense
 We have two classes
 Each of these classes has a function
 Great
 I have a question for you
 That question is, is class B a subtype of class A? Okay
 Discuss with your partner
 Come to agreement
 Okay
 Okay
 Yeah
 For Rust, Rust has like RustLang
com or something or RustLang
org has a great like step by step
 Here's how to get Rust
 It shouldn't be a problem even on Windows
 It's definitely easier on Mac, or if you have a virtual environment or virtual
 Right? Well, no, or just for Linux or something
 But yeah
 All right
 What do we think? We have two options
 Yes or no? It is a subtype or is not a subtype
 Okay
 How many people say, yes, it is a subtype
 We're ignoring the fact that this is C++
 We're talking mathematically based on our definition of subtype
 Is this a subtype? Yes
 No
 All right
 Can we explain why? Okay
 Who wants to back up either side of that answer? Yes or no? Because we had disagreement
 What do we think? Yeah
 Rudy
 The classes aren't so no because the classes aren't related to each other in any way
 They just look very similar
 Okay
 What else? Okay
 We have a call for B
 Which means that we could replace any of our A's with B's because A we can remove B we can remove
 Okay
 We've had an argumentれない any other suggestions
 Yeah
 No, because if you had a method that requires a class A you couldn't pass a class B
 Why couldn't you pass a class B? Ah
 Ignore C++
 Ignore the fact that this is C++
 If we just live in a world of math where we say an A is an object that has a function called the move and a B is an object that has a function called the move
 Yeah
 Rudy can
 We did spend a lot of lectures on type checking
 I'm not saying we are getting rid of it in C++ that C++ doesn't have type checking
 I'm using this code here as an analogy for what we could write as pseudo code
 So I'd rather show you real code than say if we lived in a world where we created class C the thing is it's going to look the same
 Class A that has and I'm just going to write Python instead can line up
 Python basically is pseudo code anyway
 I have two classes they each have a function remove the self you can ignore that's Python
 You had an idea
 Yeah
 Yeah
 As soon as you have the right features you become part of the class that's reasonable
 Yeah
 What is the definition of sub typing? Yeah
 Yeah
 Yeah
 Yeah
 That's the definition of sub type
 The C++ language designers decided that you needed to do this
 The Python designers said no that doesn't matter
 So long as I can call the same functions on the object this is a sub type of that
 Yeah
 Questions on that
 Yeah
 Yeah
 So why would we want to do this approach instead of this approach
 I think the benefits of this are that you can prevent a lot of errors
 So if you are not sub type and you're trying to treat it as a sub type maybe you're going to run into some problems
 The advantages of Python and JavaScript and languages of this style is they're more expressive
 You can do more things
 I can treat two objects that have no real relationship to each other as the same thing so long as they define the same interface
 Or at least part of the same interface that I care about
 So it's expressiveness versus kind of safety
 There's another question
 Someone else had that
 Other question
 Okay, we're going to make it a bit harder
 With example number two more classes is class B a sub type of class a discuss with your partner or partners
 Okay, what do we think? Two answers
 Yes or no
 How many people say yes? B is a sub type of a
 How many people say no? B is not a sub type of a
 Okay, I mean we have almost everyone saying yes here
 Why? Yeah
 B defines the same interface as a
 It's actually very similar to our previous problem
 I've just kind of added into other functions that look identical
 Their function signatures are the same
 Okay, cool
 So yes, we still have a sub typing relationship, which I have informally defined there
 Let's get a little bit more company
 Oh, no
 All right, I'm just going to delete these
 Is that going to mess up all my coloring? It'll be fine
 We don't need function implementations anyway
 Okay
 All right, in case you can't spot the difference because not much has changed
 It's just a single character
 This character here has changed from the previous example
 Once more, chat with your neighbor
 Is be a sub type of a
 Okay
 Okay
 Yeah, that's actually a bit of a
 So if we had normal C++ with the colon public a
 So saying that B is a subclass of a
 Then you don't need to include the virtual keyword on the subclass
 In fact, you can't include the virtual keyword in the subclass
 So that's why it's not there
 But we can kind of just ignore the virtual part now
 Okay
 What do we think? Yes or no? How many people say yes? How many people say no? How many people say maybe it depends? Okay
 I'd like some explanation
 We had a very confident yes in the bag
 Do you care to explain? We can use virtual functions
 Wait, wait, wait, why can't we use equals and clone? No, no, so virtual functions can actually have an implementation
 If we look at, for example, and this is kind of on me, I've left the virtual keyword in here
 It doesn't need to be in here
 But we can define, in fact, it's very common to define the implementation of a virtual function in C++
 They aren't exactly similar to abstract functions in Java or interface functions in Java
 So the interface of A is still actually equals clone and remove
 It is all three of those functions
 So then we had some no and we had some it depends, which was a sneaky final answer
 Why no? Yeah
 Right
 So we have a difference in our interface
 We've changed one of the important methods of the A interface in our B definition of it
 That would make B not a subtype of A unless B is a subtype of A
 And that's where the it depends because if we have the ability, which in C++ we do, if we have the ability to cast a B pointer to be an A pointer, then suddenly we are good to be subtype
 So mathematically speaking, we're not really a subtype here
 In C++ we kind of get away with it because we can convert a B into an A
 And then once we can convert a B into an A, the fact that this is a B doesn't matter anymore
 So we can turn that thing into an A
 So B will be a subtype of A provided B is a subtype of A
 A bit of a, oh there's a word for this
 It's like a technology or something
 Okay, so this one works so long as we say public A
 Once we bring C++ back into the actual discussion, now we are still a subtype
 Because we're saying we can convert this B pointer into an A pointer
 I have one more of these, I think
 And then we're going to look at some slides instead
 Okay, once again, only one character has changed
 This one right here
 That is now a B as a parameter to the equals function instead of an A as a parameter to the equals function
 Discuss with your partner is B a subtype of A
 Okay, what do we think? Yes, no, it depends
 How many people say yes? B is a subtype of A
 How many people say no? B is not a subtype of A
 How many people say it depends? Okay, we're pretty decisive
 Almost everybody said yes or no
 Why yes? Why no? Or why it depends? What do we think? Yeah, go for it
 Yes, or maybe yes
 So because B is inheriting from A, let's ignore inheritance
 So we aren't actually going to like copy A's methods here
 I've just included this, the public A so that we could get around this clone
 So that clone is no longer an issue
 But what about three equals? No inheritance
 Don't have an inheritance
 I love this explanation
 If we try to give, if we try to call it equals with an A object, if we're using an A as the base object, that's fine
 But if we try and pass an A object to a B equals function, we're going to run into issues
 So if we have some function that takes an A, and then it compares, it says that parameter A equals a new A
 Then we create an A pointer and call the function with A, nothing goes wrong
 But when we create a B object and pass B is the parameter, then we're going to be using B's equals function here, which expects a B type object
 But we're giving it an A type object
 That's not going to work
 So no, we can't do this
 We are not a subtype here
 Even if we have all of, you know, our, our, we're saying that B is a subtype of A so that we can do the clone, we can't cast an A to be a B, we can always cast a B to the an A
 If we go all the way into C++ and say, okay, we have all of the features, all the subtyping inheritance, then yes, technically B is still a subtype of A here, because B is going to have two versions of equals
 It's going to have its version of equals that takes B object and it will create a copy or keeps a copy of A's version of equals
 So that if we tried to do code like this, it would call A's version of equal
 Okay, questions on any of the code that we've talked about, any of the features so far? Yeah
 So we wouldn't run into a similar issue with clone
 Exactly
 We don't need to actually duplicate clone inside of B
 There's one version of clone for the B object
 And that version returns a B
 There is no clone that returns A inside of B because we have the ability to convert a B into an A if we need to
 Other questions? This stuff can be quite confusing
 So we're going to be going over it the second time with slides and hopefully that will help solidify
 So what is subtyping? Subtyping is the relationship between two interfaces
 We're not talking about copying code or anything of that sort, that's inheritance
 We're saying that if an interface A contains all of an interface B, then A is a subtype of B
 And the interface is just the messages that the object understands
 So what we've been doing are like ongoing example is this colored point is a subtype of the point
 Okay
 Talk to your neighbor
 Come to consensus here
 A or B
 Who defines subtyping? All right
 What do we think? Developers
 The kind of everyday developer or language designers
 Language designers
 This is the sort of thing that C++ has decided how subtyping works
 It's not using the kind of mathematical version
 And that's fine
 Python does something different
 JavaScript does something different
 So JavaScript, for example, says every object implicitly has an interface
 That interface is whatever you've given it
 You've said you can map on this object or that object has a color property
 So it's got the x, y move for a point or x, y move color for the colored point
 Colored point doesn't need to explicitly say it is a subtype of point
 It just is a subtype of point because the interface says so
 And in JavaScript, that has no relationship to inheritance
 Colored point doesn't need to copy any of the code from point
 Could be doing its own thing entirely
 On the other hand, C++, it's very much built into the syntax of the language that we have this colon as we define a class to say class B is a subtype of class A
 Which is great in terms of easily inheriting code from other places, but it's a little bit more constricted
 Now we've answered this to some extent already
 If I want to go over it real quick again is implementing the same functions enough in C++
 If we have colored point which has move and color and point which has move is colored point a subclass or subtype of point in C++
 Yes? No? No, it's not
 C++, you have to specify colored point is a subclass of point
 So subtyping is explicit
 We say A is a subtype of B if A has a public base class B
 Any questions on this piece? Yes
 How would we change this code so that color point is a subtype of point in C++? What would we do? Can someone actually we can just type it out? What would we do? How do we change our code over here? Yeah? Collin point
 Almost it's just missing one small thing we need to say that it's publicly inheriting
 So that's all we have to do
 Now color point is a subtype of point
 Cool? Yeah? Oh no, you're totally right
 Yep, let's fix that
 No, that's a typo in the slides
 Thank you
 Thank you for pointing that out
 Right
 Other questions? All right
 Cool
 So in C++ what is the actual interface? In JavaScript the interface was just what the object said the interface was
 In C++ we have this complicated compiler that we have to wrangle
 And everything comes down to the memory layout of the objects and the memory layout of the V table
 And to be a subtype we have to match our memory layouts between objects and between the V table
 And we have to be guaranteed that that's true by the compiler
 Otherwise we're going to run into all sorts of problems
 So we get all of the compatibility from the inheritance from specifying colon public a or colon public point
 Okay
 But what does it really mean? Again, we've to some extent covered this
 What we're saying is that colored point has a bigger interface than point
 The set of colored points is more constrained
 It's smaller than the set of all points
 Cool
 In case that means something to you
 I feel like this is one of those topics that we talk about a lot
 And so you're very familiar with it in some sense but seeing it in other ways can sometimes be helpful as well
 Yeah
 No, no
 Okay
 Yeah
 So colored points is smaller here
 This is representing the set of points
 The set of all points is every x, y point
 And then it's also the set of all colored points
 These colored points are points similar to natural numbers are a subset of integers
 So if we drew a similar diagram for natural numbers and integers, you would have a larger whatever square rectangle
 So you would, for the integers and a smaller one for the natural numbers
 The natural numbers are a subtype of integer
 Two PL nerds, what we say is s is a subtype of t
 If any term of type s can be used in the context where type t is expected
 So we're saying, do I erase it over here? It's this piece
 B is a subtype of a if we can use a b where we were previously using a b
 It's very much connected to runtime
 We have compile time checks to say is this a subtype of that if it's not then we're going to raise an error
 But the only reason we would raise that error at compile time is because you might get that error at runtime if we didn't
 And when we want to talk about this kind of formulaically or mathematically, we use a very simple shorthand notation
 I forget what it's what the name of it is
 It's like a judgment bar or something like that
 I should double check
 But this bar is effectively if the above then below if he is of type s and s is a subtype of t then he is of type t
 If he is a colored point and colored points are a subtype of points, then he is a point
 Question
 You see this style of notation in all over the place in PL for theorem proving and what not
 Now we're getting back into example two
 Can we override clone as follows? We have our a with equals and clone and b with equals and clone but b returns a b in its clone
 Yes or no chat with your partner for 10 seconds or 15 seconds come to consensus
 What do you think? Yes, it is okay to override clone in this way
 No, it is not okay to override clone in this way
 We have some disagreement
 Why? Yes, why yes, why no? Yes
 So we can't change the return value with overriding
 Why not? Why what would go wrong? So we aren't really overriding the function
 We have a different type
 But is it okay that we have a different type? A lot of you said yes
 Why did you say yes? Yes
 Yes
 We know b is a subtype of a because we have b colon public a
 We've told the compiler b is a subtype of a
 That means the compiler is going to make sure all of our b objects look identical to a objects with a little bit extra
 So when we have this clone that's giving us back a b, if we needed it to be an a, we could have it be an a
 So this is actually going to be valid
 In any case we want to clone an a, we could clone a b and upcast it to be an a
 So specifically if we created an a pointer that is a b object, we could call that clone without any issue
 We would get a b pointer back and we could turn it into an a
 Questions here
 So how many equals functions or how many clone functions did b have? Well, just the one
 Yeah, we just have one equal one clone function
 We've successfully overridden clone
 Oh, and the title of this slide is important
 This is called return covariance
 Let's take a second to look at that
 What do we know about the type and be types and what's the relationship between and be in this code snippet? B is a subtype of a
 What is the type of b's clone function? Easy participation points
 What's the type of b's clone function? B pointer
 It's a function so it needs more than just b pointer
 It's giving us back a b pointer
 What's the full type? Yeah
 So void
 We could either put it as parentheses
 That's what a Haskell people would do
 Or we could do something else
 What do I want to say? I want to say generic
 Let's just
 No, no, we'll call it
 We'll call it void
 So void to a b pointer
 That's what our clone function is
 We take in no parameters
 We return a b pointer
 What is the type of a's clone? This one's even easier participation points
 Yeah
 void to a pointer
 Now we have just said it's okay to override in this case
 So that means we've maintained our sub typing relationship
 Which means that our function clone inside of b is going to be a subtype of our function clone inside of a
 Because if it weren't a subtype, then we would then b itself would not be a subtype of a
 We would be breaking that relationship
 So return covariance says that if b is a subtype of a, a function that returns b is a subtype of a function that returns a
 If we ignore the arguments more generally, we say let's not use a
 x to b is a subtype of x to this is what's called return covariance
 No, they don't have to be pointers
 This is for any
 Any type b, any type a, any type x
 So b pointer is a subtype of a pointer
 Therefore void to b pointer is a subtype of void to a pointer
 We call this covariance specifically because we look at the direction of our sub typing relationship
 b flows to a, b flows to a
 Co means with
 So we are going with the original sub typing relationship
 What about the arguments? argument covariance
 What we're saying here is if b is a subtype of a, then is it true that b to x and a to x is this true? is b to x a subtype of a to x
 That's what we are going to be figuring out here
 Yes or no, talk to your neighbor
 What do you think? Okay, what do we think? I'll cut you short
 Yes or no? Yes
 Yes, it is a, yes, it is a subtype
 Yes, it is valid
 We are overriding
 No, it's not a subtype
 Why? Everyone's saying no
 Yes
 Exactly
 Just like the code that we saw earlier, equals inside of b is expecting a b
 But we might have given it an a because previously with a's equals, we were giving it a's
 So that's not going to work
 We can't cast an a to be a b
 It only goes the other way
 So here's kind of the code example that goes along with that
 And a little explanation
 But this is what we saw earlier with example three of our initial code
 So we do not have argument covariance
 b to a is, or b to x is not a subtype of a to x
 But a to x is a subtype of a to x
 Right? If we had left equals alone and just said that it takes an a, that was fine
 So, and it kind of makes a lot of sense that if we said a to x, we would be a valid subtype of a to x
 Now we're good
 What about the other way around though? That's the last potential piece of this puzzle
 If we have b to x, could it be possible that b to x is a super type of a to x? If b is a subtype of a
 Let's jump back to some code real quick
 Okay
 So we're going to have shape and circle is a subtype of shape
 And then we are going to have equals here takes a circle equals here takes a shape
 So b is a subtype of a to ignore that
 Well, we want to ask is is equals here a subtype of equals there? Can we use b's equals anywhere we would use a's equals? Chat with your neighbor
 You guys know the drill
 Yeah, let me take a look
 I don't know
 So in that one, it was saying assume that c is another subclass of b
 Then you create like c version of the thing and a b version of the thing
 And you're trying to pass the c version to the b's equals
 Yeah, would this be an example of contravariance? What is that? Okay, what do we think? Yes, no, maybe
 How many people say yes? This is valid subtype
 How many people say no? This is not a valid subtype
 How many people say maybe? I don't know
 Okay, we got we got a little bit of all three
 Somebody convinced me one way or the other
 Yeah, go for it
 I know, right? I'm doing that all day
 I feel like you're on the right path though
 So if we were using this equals function, which is circle to rule, we want to use another equals function
 So we're going to be passing a circle to it
 Can we pass a circle to this equals function? Yeah, that's fine
 We can cast a circle to be a shape without any issue
 So this is a valid subtype
 So we do know that b to x is a subtype or is a supertype, sorry, I mean, I'm doing it all the time
 B to x is a supertype of a to x
 If b is a subtype of a
 In this case, we actually have a flip of the operator here
 B is a subtype of a, but b to x is a supertype of a to x
 This is what we call contravariance
 Previously, we had covariance
 Now we have contravariance
 It's against the previous way
 And now some slides to talk about that
 So this is for the return values
 We say if b is a subtype of a, then x to b is a subtype of x to a
 For example, x to color point is a subtype of x to point
 And then the flip side of this, the contravariance for arguments, if b is a subtype of a, then a to x is a subtype of b to x
 Notice I flipped the order in which we talk about a and b
 Okay
 Now to relieve a lot of Piazza questions, the homework assignment, problem one, is all about contravariant argument method specialization
 Specifically, it's asking if we added contravariance to, or contravariant method specialization to c++, what happens? C++ does not implement this
 This is a rule that the language deciders decided to skip
 They have return type covariance, but they don't have argument method specialization with contravariance
 So if we added this to c++, what changes? Does it break anything? Is it okay? That's what the first homework assignment question is about
 There are always a lot of questions about it
 So hopefully that will help a little bit
 You'll be asked to consider the real world of what c++ actually looks like without contravariance and the fake world where it does
 Except that homework problem was written in 2017 and c++ added contravariant method specialization
 So if you are working with a c++ 23 compiler and you then add in the proper flag to allow contravariant method specialization, this no longer holds, or the programming assignment, no, the homework assignment doesn't make any sense anymore
 Ignore that, pretend it's 2017, you're listening to all those good classics
 Anyway, so that's this fall note
 Oh yeah, questions on either covariance or contravariance
 Yeah
 So anywhere we could pass in a circle, we can accept a shape
 Anywhere we were previously passing a circle, we can write a new function that accepts a generic shape because we can convert that circle into a shape
 That's what this is saying
 Other questions on contravariance and covariance
 Yeah, great question
 So in c++ before 2023, and I think even in 2023, I'm not super up to date on this, but I think what you need to do is you have to specify a new keyword override
 And I think this is how you turn it on
 So I'm pretty sure everything still actually holds, but it's a good caveat
 But what happens here in c++ without contravariant method specialization? What does B look like? Because B needs to be a subtype of A
 We've said that B is a subtype of A
 That means the compiler is going to make sure B is a subtype of A
 So what do we have to do? Yeah
 We will just copy the method from A
 And B is going to have two versions of equals
 It's going to have equals that takes a shape, and it's going to have equals that takes a circle
 So that's how we'll get around that so that B is still a valid subtype of A
 We'll just copy the old version
 Other questions? Yeah, overloading versus overriding
 Overriding means that we only have one version of it
 If this equals is overriding, that equals
 That means that B has one version of the equals
 It's gotten rid of the other
 Overloading is when we have two versions of a function or multiple versions of a function that accept different types or that return different types
 So here in C++, we do overload equals
 And it can either take a shape or a shape
 Other questions? All right
 Let's keep going
 I don't think these slides are actually super important
 It's basically once again reiterating what we've talked about where we're talking about this subtype of relationship
 Feel free to use them as review slides when you're looking at this later
 Okay
 Let's do a subtype circle or a subtype indictment
 If we have, circle is a subtype of shape
 What do we know about the relationships between all of these functions? I've already drawn in the errors
 I hit most of the information
 I forgot to get rid of the errors
 If we know how many of you have excellent memories, I guess we'll test it right now
 Okay
 Circle is a subtype of shape
 Circle is a subtype of shape
 What do we say about what we have circle to circle? How does this relate to circle to shape? Yeah
 Circle is a subtype of circle to shape
 Why? Return type covariance
 The return type is what's changed
 We are covariant, meaning we go the same direction
 So circle is a subtype of shape
 Therefore, this one is a subtype of flow weight
 That's the same
 That's kind of confusing
 Alright
 Let's do another one
 If we have shape goes to circle and circle goes to circle
 What's the relationship between these two? Yeah
 This is a subtype of that
 Yeah
 Why? Because of argument controversies
 So our argument is what's changed
 And this is a subtype of that
 But arguments follow the contrarvarian path
 So this is a subtype of that, which means that this whole thing is a subtype of that
 So it's the same upside down
 Alright
 What about circle to shape and shape to circle? What do we think of this one? Yeah
 No relationship between these
 I think that's probably fair
 I haven't actually given it any thought
 So return type, this is a subtype of that
 So that would imply that this would be a subtype of this
 Is that true here? So here we have this is a subtype of that
 But we are contrarvarian, which means we flip it
 So actually I think it's safe to say that we have that slightly face this time
 And it actually is
 You would be doing something pretty funky if you were writing to go like that
 I would not recommend it
 Wait
 To go back to the circle or this, you know, whatever you want to call it, we can relate all of these in some form
 So shape to circle is a subtype of circle to circle
 What's changed is the parameter or the argument
 Then circle to circle is a subtype of circle to shape
 And so here we should see what I've just said
 Circle to shape the bottom one is a subtype of our shape to circle
 I can't even read it
 Shape to circle is a subtype of circle
 Yeah
 Our subtype is transitive, definitely
 Yeah
 In mathematics
 Not necessarily in any given programming image
 Yeah
 Other questions on our little example
 Okay
 This can be hard
 Java really messed this up when they defined what they wanted to do for a race
 They made arrays covariant and that breaks type and memory
 Any idea why we're having
 Yeah
 We can have multiple types where we can have different types of variables in and array
 Is that what you said? I don't think you can
 Or can you give me an example
 If a is a subtype of B, you can have an array of B
 No, I think we actually want that
 I think I would argue that that's actually a useful use case that we should
 Let's talk about the array itself
 If a is a subtype of B, or c is a subtype of S, should a list of c be a subtype of a list of S
 You might say why would you want to do that? That's like a ridiculous thing to do
 But it's actually definitely not
 So for example, we could have a string list is a subtype of an object list
 Why would you want to do this? What if you want to write a generic shuffle in Java? Your function doesn't care about what is actually in the list, whether it's objects or strings or cats or anything
 You just want to reorder the elements
 So you could write your function type to say it just takes a list of objects
 And then I can shuffle with any different type of array
 It could be a list of strings, a list of circles, a list of cats, whatever
 But then what goes wrong? If we have this style of effect, this is very similar to what we've done in functional program, with our parametric types and Java saw that and they were jealous and they messed it up
 They were like, well, that would be cool to do in our language
 Oops
 So if we create a list of dogs, for example, and then we also have a list of animals, and we say that list of animals equal to that list of dogs
 That would be okay because we've just upcast our list of dogs, which is a subtype of our list of animals
 So our list of animals is actually a list of dogs, but it's treated as a list of animals
 So we should be able to add any type of animal to it
 In particular, we should be able to add a cat to it
 But then if we try and get the first element of our dog list, it's a cat
 Substitute any other types that are not, you know, Java class types, and you run into a lot of issues here
 We could create a list of objects and set that list of objects equal to any other list that you create
 And then we could add any element to that list that we wanted, and we mess up our type safety and memory safety of our originals
 We place a lot of trust in the subtype, and when it goes wrong, it can really break things
 But we want to be able to use this subtype
 So Java has fixed this by adding generic, so a lot of other languages are following suit
 But we place a lot of trust in the actual subtype
 And what that leads to is what's called often duck type
 Where you say, yeah, this is kind of a subtype of that
 And I'm going to pretend that it is a subtype of that
 And that's especially in languages like JavaScript and Python, where you just say the interface works
 So it's a subtype
 I'm going to treat that, you know, treat the dog as a duck, treat the pig as an outlet, because it could work
 I can call that function, so why not? All right, this is all I have on subtyping
 This week we talked about statically type of Victorian languages of C++ with virtual functions, and then we kind of dove into subtyping
 Next week we get pretty funky with continuations, and like that sort of stuff
 So it'll be a fun week
 See you on Monday
 you you you you you you you you you you you you you