1
00:00:00,000 --> 00:00:27,000
Hopefully that doesn't keep happening.

2
00:00:27,000 --> 00:00:51,000
Thank you.

3
00:00:51,000 --> 00:01:19,000
Thank you.

4
00:01:19,000 --> 00:01:25,280
All right, guys.

5
00:01:25,280 --> 00:01:27,600
Let's go ahead and get started.

6
00:01:27,600 --> 00:01:30,400
So to start off, we got some notes.

7
00:01:30,400 --> 00:01:35,520
The early deadline for the first homework and programming assignment are tomorrow.

8
00:01:35,520 --> 00:01:40,520
So that is if you want 10% bonus points, submit by tomorrow night.

9
00:01:40,520 --> 00:01:46,640
Otherwise, the normal deadline is this Sunday night at 11.59 p.m.

10
00:01:46,640 --> 00:01:48,840
So get working on those.

11
00:01:48,840 --> 00:01:51,120
I have office hours after class today.

12
00:01:51,120 --> 00:01:55,520
If you're having any trouble setting things up or have questions, feel free to stop by.

13
00:01:55,520 --> 00:01:59,160
I also have a chess board in there if you want to just sit and play chess for a little

14
00:01:59,160 --> 00:02:00,160
bit.

15
00:02:00,160 --> 00:02:01,160
Recordings.

16
00:02:01,160 --> 00:02:04,760
I missed on Monday, I forgot to set up Zoom.

17
00:02:04,760 --> 00:02:07,720
But hopefully I've contacted the department.

18
00:02:07,720 --> 00:02:09,540
That thing looks like it's on.

19
00:02:09,540 --> 00:02:12,660
I see myself in the camera over here.

20
00:02:12,660 --> 00:02:18,000
So hopefully everything will be official and through Canvas going forward.

21
00:02:18,160 --> 00:02:20,320
So use those for what you will.

22
00:02:20,320 --> 00:02:25,680
If it turns out that you guys prefer watching recordings online, that's fine.

23
00:02:25,680 --> 00:02:27,800
We'll have a little bit more of a sparse classroom.

24
00:02:27,800 --> 00:02:32,520
For the people who do show up, just come sit closer to the front and we'll have more fun.

25
00:02:32,520 --> 00:02:33,920
Okay.

26
00:02:33,920 --> 00:02:34,920
Those are my notes.

27
00:02:34,920 --> 00:02:36,920
Are there any notes from you guys?

28
00:02:36,920 --> 00:02:38,880
Anything that's not working?

29
00:02:38,880 --> 00:02:41,840
Any questions before we dive into lecture?

30
00:02:41,840 --> 00:02:42,840
Yeah?

31
00:02:42,840 --> 00:02:54,400
Is the early deadline just literally however many days beforehand and it's still midnight?

32
00:02:54,400 --> 00:02:55,400
Yes, it's still midnight.

33
00:02:55,400 --> 00:02:56,400
Yeah.

34
00:02:56,400 --> 00:02:57,400
Yep.

35
00:02:57,400 --> 00:03:00,640
The early deadline is at midnight or 11.59 p.m.

36
00:03:00,640 --> 00:03:01,640
Yeah?

37
00:03:01,640 --> 00:03:07,200
What's the name of the written assignment?

38
00:03:07,200 --> 00:03:08,200
Yeah.

39
00:03:08,200 --> 00:03:09,800
So grade scope is a little tricky.

40
00:03:09,800 --> 00:03:14,160
So the question was, if we are submitting the written assignment as a group, which you

41
00:03:14,160 --> 00:03:19,520
should definitely be submitting as a group, you need at least one group member.

42
00:03:19,520 --> 00:03:21,360
What's the process for that?

43
00:03:21,360 --> 00:03:27,560
After you submit as one person from the group, you can go to the submission and add your

44
00:03:27,560 --> 00:03:30,200
teammates to that submission.

45
00:03:30,200 --> 00:03:35,600
So one submission per group for the entire group, one submission.

46
00:03:35,600 --> 00:03:37,480
Add your teammates.

47
00:03:37,480 --> 00:03:41,320
Also select where the problem is in your submission.

48
00:03:41,320 --> 00:03:42,960
So it will say, like, where is problem one?

49
00:03:42,960 --> 00:03:45,720
And you highlight the area that is problem one.

50
00:03:45,720 --> 00:03:46,720
Yeah.

51
00:03:46,720 --> 00:03:47,720
That's all on grade scope.

52
00:03:47,720 --> 00:03:48,720
Yeah?

53
00:03:48,720 --> 00:04:01,800
Can we submit just the PA early or just the homework early?

54
00:04:01,800 --> 00:04:03,160
And do you still get the extra credit?

55
00:04:03,160 --> 00:04:04,160
Yes.

56
00:04:04,160 --> 00:04:07,080
The extra credit is tied to the individual assignment.

57
00:04:07,080 --> 00:04:11,080
So if you submit the PA early, you get 10% bonus points on the PA.

58
00:04:11,080 --> 00:04:15,840
If you submit the homework early, you get 10% bonus points on the homework.

59
00:04:15,840 --> 00:04:18,680
They're separate pieces.

60
00:04:18,680 --> 00:04:20,600
Yep.

61
00:04:20,600 --> 00:04:25,340
Anything else?

62
00:04:25,340 --> 00:04:29,100
As we get into a rhythm with it, these will be very comfortable.

63
00:04:29,100 --> 00:04:31,760
It's the same thing every time.

64
00:04:31,760 --> 00:04:35,080
All right.

65
00:04:35,080 --> 00:04:42,240
In that case, let's get back into JavaScript.

66
00:04:42,240 --> 00:04:43,680
First class functions.

67
00:04:43,680 --> 00:04:44,680
What are they?

68
00:04:44,680 --> 00:04:50,080
Who can give me the three points of what makes a first class function all at once somebody

69
00:04:50,080 --> 00:04:53,460
who didn't answer the same question yesterday?

70
00:04:53,460 --> 00:04:55,280
What is first class functions?

71
00:04:55,280 --> 00:04:56,280
What does it mean?

72
00:04:56,280 --> 00:04:57,280
Yeah.

73
00:04:57,280 --> 00:04:58,280
Go for it.

74
00:04:58,280 --> 00:05:08,920
Yeah.

75
00:05:08,920 --> 00:05:15,440
So is it using functions to create scopes for the variables inside of it?

76
00:05:15,440 --> 00:05:19,560
That's one of the things that first class functions allows us to do.

77
00:05:19,560 --> 00:05:24,920
So it's a capability of first class functions, but it's not necessarily what they are.

78
00:05:24,920 --> 00:05:25,920
Yeah?

79
00:05:25,920 --> 00:05:40,880
So it's the three things of the function can be defined in any scope, they can be passed

80
00:05:40,880 --> 00:05:47,360
to other functions as values, and they can be returned from functions as values.

81
00:05:47,360 --> 00:05:53,160
To say it in one tagline, first class functions means functions are values.

82
00:05:53,160 --> 00:05:55,360
They're just normal values.

83
00:05:55,360 --> 00:06:01,440
Just like you say let X equal 3, you can say let X equal a function.

84
00:06:01,440 --> 00:06:03,280
All right.

85
00:06:03,280 --> 00:06:10,240
So then that leads to a little bit of a pretty natural question coming after that.

86
00:06:10,240 --> 00:06:14,600
Are these functions that we're working with the same thing as function pointers that you

87
00:06:14,600 --> 00:06:17,600
might have seen in other languages like C?

88
00:06:17,600 --> 00:06:23,880
Where you can, for example, call sort with a comparison function.

89
00:06:23,880 --> 00:06:29,760
Where you tell the sort function how to sort the things in your list.

90
00:06:29,760 --> 00:06:31,540
That's using a function pointer.

91
00:06:31,540 --> 00:06:36,920
So are the functions that we're working with, these first class functions in JavaScript,

92
00:06:36,920 --> 00:06:38,920
are they just function pointers?

93
00:06:38,920 --> 00:06:44,600
This is one that I do want you to take a minute, chat with your peers, whoever's next to you,

94
00:06:44,600 --> 00:06:46,800
yes or no, and why.

95
00:06:46,800 --> 00:06:47,840
What makes it the same?

96
00:06:47,840 --> 00:06:50,000
What makes it different?

97
00:06:50,000 --> 00:06:52,920
So take a minute or two to chat.

98
00:07:52,920 --> 00:08:03,880
All right.

99
00:08:03,880 --> 00:08:07,320
Sounds like conversation is settling down.

100
00:08:07,320 --> 00:08:09,600
Let's get a quick class poll.

101
00:08:09,600 --> 00:08:12,680
How many people are in the yes camp?

102
00:08:12,680 --> 00:08:18,420
These are just like the function pointers that you would see in, for example, C.

103
00:08:18,420 --> 00:08:21,300
What about how many people are in the no camp?

104
00:08:21,300 --> 00:08:23,900
Saying these are not just function pointers.

105
00:08:23,900 --> 00:08:24,900
Something else is going on here.

106
00:08:24,900 --> 00:08:25,900
Okay.

107
00:08:25,900 --> 00:08:29,260
So large majority of the class is saying no.

108
00:08:29,260 --> 00:08:31,060
Someone explain why.

109
00:08:31,060 --> 00:08:33,180
What else is happening here?

110
00:08:33,180 --> 00:08:34,180
Yeah.

111
00:08:34,180 --> 00:08:37,180
Go for it.

112
00:08:37,180 --> 00:08:56,580
Yeah, so C definitely does not let youï¿½ or at least most implementations of C do not

113
00:08:56,580 --> 00:09:01,140
let you define your functions in any scope.

114
00:09:01,140 --> 00:09:04,200
That's our first requirement for a first class function.

115
00:09:04,200 --> 00:09:08,160
So it's true C doesn't have first class functions.

116
00:09:08,160 --> 00:09:13,440
But C does let you still pass around these functions.

117
00:09:13,440 --> 00:09:18,640
And some implementations of C actually do let you define them in any scope.

118
00:09:18,640 --> 00:09:24,420
There still might be something different between a function pointer by itself being able to

119
00:09:24,420 --> 00:09:30,280
define the function anywhere and pass it around and what we're doing in JavaScript.

120
00:09:30,280 --> 00:09:33,360
There's another little piece that's happening in here.

121
00:09:33,520 --> 00:09:39,360
And we saw it yesterday with the expressive code a little bit.

122
00:09:39,360 --> 00:09:40,360
What else is going on?

123
00:09:40,360 --> 00:09:41,360
Yeah.

124
00:09:41,360 --> 00:09:42,360
Yeah.

125
00:09:42,360 --> 00:09:43,360
Yeah.

126
00:09:43,360 --> 00:09:56,600
So the function has access to variables that were around when it was defined.

127
00:09:56,600 --> 00:10:02,840
That's kind of like the English way to describe the idea of a closure.

128
00:10:02,840 --> 00:10:07,480
These functions in JavaScript are not just pointers.

129
00:10:07,480 --> 00:10:13,680
They are function code, which is what you have in C, for example, with a function pointer.

130
00:10:13,680 --> 00:10:15,840
And they also have environment.

131
00:10:15,840 --> 00:10:22,640
That is the variables that are around when the function is being defined.

132
00:10:22,640 --> 00:10:27,960
And these closures are things that we are going to deep dive into in a few lectures

133
00:10:27,960 --> 00:10:33,760
when we kind of come back to JavaScript later in, I think, late February.

134
00:10:33,760 --> 00:10:39,880
But for now, the important idea is that functions in JavaScript capture environment.

135
00:10:39,880 --> 00:10:41,600
Traditional function pointers don't.

136
00:10:41,600 --> 00:10:51,400
So you could have first class functions in some other languages and not have closures.

137
00:10:51,400 --> 00:10:57,920
JavaScript has a specific form of first class function called a closure, where we have code

138
00:10:58,120 --> 00:11:02,040
and we have environment going along with it.

139
00:11:02,040 --> 00:11:05,400
All right.

140
00:11:05,400 --> 00:11:10,920
Since it's one thing to see the slides and another thing to see code, let's dive into

141
00:11:10,920 --> 00:11:23,840
what that might actually look like.

142
00:11:23,840 --> 00:11:30,200
And you guys will have to let me know when it's the right size to read.

143
00:11:30,200 --> 00:11:33,800
How's that?

144
00:11:33,800 --> 00:11:35,800
Readable?

145
00:11:35,800 --> 00:11:36,800
All the way in the back?

146
00:11:36,800 --> 00:11:37,800
You guys can read it?

147
00:11:37,800 --> 00:11:38,800
Yep.

148
00:11:38,800 --> 00:11:40,800
Anybody want it larger?

149
00:11:40,800 --> 00:11:41,800
No.

150
00:11:41,800 --> 00:11:42,800
Okay.

151
00:11:42,800 --> 00:11:49,480
So, last time we had a function called add 42, which what it did was it took an element

152
00:11:49,480 --> 00:11:53,720
as a parameter and it returned the element plus 42.

153
00:11:53,720 --> 00:11:55,280
Nothing too special.

154
00:11:55,280 --> 00:12:01,960
But maybe we want to make a function that generically creates other add functions for

155
00:12:01,960 --> 00:12:02,960
us.

156
00:12:02,960 --> 00:12:06,360
What if we wanted an add 43 and an add 44?

157
00:12:06,360 --> 00:12:12,720
It's kind of arbitrary, definitely contrived for this example, but this type of idea exists

158
00:12:12,720 --> 00:12:14,580
all over the place.

159
00:12:14,580 --> 00:12:20,120
So what we might have is a function called make add function, and the purpose of this

160
00:12:20,120 --> 00:12:23,900
function is to return another function.

161
00:12:23,900 --> 00:12:29,600
That's one of our primary features of first class functions, is that they can be returned.

162
00:12:29,600 --> 00:12:35,820
So we're creating a function that returns another function, and importantly, we're going

163
00:12:35,820 --> 00:12:43,200
to reference a variable that does not exist inside of our scope of this function, but

164
00:12:43,200 --> 00:12:48,160
exists from the outer scope of the function that created it.

165
00:12:48,160 --> 00:12:54,240
This offset variable comes from the make add function, not the inner function that

166
00:12:54,240 --> 00:12:56,840
we're returning.

167
00:12:56,840 --> 00:13:03,240
So let's use it and see what happens.

168
00:13:03,240 --> 00:13:08,840
We can create an add 42, where we say this is equal to make add function with the value

169
00:13:08,840 --> 00:13:14,760
42, and a sub 42, where we are make add function with negative 42.

170
00:13:14,760 --> 00:13:19,800
Now when we call add 42 of 1, what are we going to get?

171
00:13:19,800 --> 00:13:23,480
Do I have copilot on?

172
00:13:23,480 --> 00:13:24,480
I do.

173
00:13:24,480 --> 00:13:25,480
That's okay.

174
00:13:25,480 --> 00:13:26,480
Turn that back off.

175
00:13:26,480 --> 00:13:29,880
I was coding earlier.

176
00:13:29,880 --> 00:13:31,440
What are we going to get here?

177
00:13:31,440 --> 00:13:32,440
43.

178
00:13:32,440 --> 00:13:33,440
Yeah.

179
00:13:33,440 --> 00:13:37,160
I think that's a fair...

180
00:13:37,160 --> 00:13:42,320
Like a reasonable assumption that we're adding 1 to add 42.

181
00:13:42,320 --> 00:13:50,360
Add 42 is this inner function here, where this x will have the value 1, and then when

182
00:13:50,360 --> 00:13:56,960
we try and look up offset, we will see that offset was 42, which was the value we were

183
00:13:56,960 --> 00:13:57,960
given.

184
00:13:57,960 --> 00:14:02,200
If we add 42 to 42, what do we get?

185
00:14:02,200 --> 00:14:03,200
84.

186
00:14:03,200 --> 00:14:04,200
Definitely.

187
00:14:04,200 --> 00:14:10,360
Same thing happens, where we're looking up the value of offset each time.

188
00:14:10,360 --> 00:14:11,800
It hasn't changed.

189
00:14:11,800 --> 00:14:13,680
We haven't updated anything.

190
00:14:13,680 --> 00:14:17,640
It's still the same value of 42.

191
00:14:17,640 --> 00:14:26,360
Just to kind of finish this, what's sub 42, 1?

192
00:14:26,360 --> 00:14:27,360
Negative 41.

193
00:14:27,360 --> 00:14:28,480
Yeah, definitely.

194
00:14:28,480 --> 00:14:35,800
This time, when we look up the value of offset, offset within the context of sub 42 is negative

195
00:14:35,800 --> 00:14:36,840
42.

196
00:14:36,840 --> 00:14:40,440
We have two different offset values.

197
00:14:40,440 --> 00:14:45,360
There's an offset that's just for this value, and there's an offset that's just for that

198
00:14:45,360 --> 00:14:47,880
value.

199
00:14:47,880 --> 00:14:54,200
And we're going to go into the mechanics of that in a future lecture.

200
00:14:54,200 --> 00:15:01,480
This one, all on the same page, that that would be 0.

201
00:15:01,480 --> 00:15:06,760
Any questions on what we've done here?

202
00:15:06,760 --> 00:15:22,520
All right, then let's make it a bit more complicated.

203
00:15:22,520 --> 00:15:27,440
See if I can get some questions out of you guys.

204
00:15:27,440 --> 00:15:30,200
These programs, once again, are all on Canvas.

205
00:15:30,200 --> 00:15:32,120
I think they weren't last time I said that.

206
00:15:32,120 --> 00:15:33,400
This time, I've double checked.

207
00:15:33,400 --> 00:15:36,880
They really should be on Canvas now.

208
00:15:36,880 --> 00:15:42,040
If they aren't, let me know, and I will try again to upload them.

209
00:15:42,040 --> 00:15:45,720
Now we're going to create a new function called f.

210
00:15:45,720 --> 00:15:47,440
Takes a parameter x.

211
00:15:47,440 --> 00:15:49,600
Then we're gonna say let y equal x.

212
00:15:49,600 --> 00:15:50,600
Okay?

213
00:15:50,600 --> 00:15:54,960
And then we're going to return a new function that's not named.

214
00:15:54,960 --> 00:15:55,960
That's fine.

215
00:15:55,960 --> 00:16:05,820
It takes a parameter z, and it assigns y equals y plus z, and then returns y.

216
00:16:05,820 --> 00:16:11,280
We call h equals f of 5.

217
00:16:11,280 --> 00:16:17,400
And then we console.log h of 3.

218
00:16:17,400 --> 00:16:19,280
Take a second.

219
00:16:19,280 --> 00:16:20,960
Think to yourself.

220
00:16:20,960 --> 00:16:26,880
First of all, what is the value of h?

221
00:16:26,880 --> 00:16:30,760
And then what will this first line print?

222
00:16:30,760 --> 00:16:34,400
So think it over to yourself for a second here.

223
00:16:34,400 --> 00:17:00,920
Try and come up with an answer.

224
00:17:00,920 --> 00:17:04,400
Who feels like they have an idea of what h is?

225
00:17:04,400 --> 00:17:07,720
Okay.

226
00:17:07,720 --> 00:17:08,720
Not too many of you.

227
00:17:08,720 --> 00:17:10,440
So I'm gonna give you a little bit more time.

228
00:17:10,440 --> 00:17:12,480
Chat with somebody next to you.

229
00:17:12,480 --> 00:17:33,920
See if you guys can come to a consensus on what h is.

230
00:18:03,920 --> 00:18:12,480
All right.

231
00:18:12,480 --> 00:18:15,640
How many people now feel like they know what h is?

232
00:18:15,640 --> 00:18:17,960
Feel a little bit more comfortable with it?

233
00:18:17,960 --> 00:18:19,240
A decent number more.

234
00:18:19,240 --> 00:18:20,240
Still not everyone, though.

235
00:18:20,240 --> 00:18:22,760
So let's figure it out.

236
00:18:22,760 --> 00:18:23,760
What is h?

237
00:18:23,760 --> 00:18:25,400
Who's got an answer?

238
00:18:25,400 --> 00:18:26,400
Yeah?

239
00:18:26,400 --> 00:18:28,000
Is it 8?

240
00:18:28,000 --> 00:18:29,000
Is it 8?

241
00:18:29,000 --> 00:18:31,320
Is h equal to 8?

242
00:18:31,760 --> 00:18:33,920
Ah.

243
00:18:33,920 --> 00:18:35,640
This one, I'm on board.

244
00:18:35,640 --> 00:18:38,500
I think this next one is 8.

245
00:18:38,500 --> 00:18:39,680
Someone else.

246
00:18:39,680 --> 00:18:41,680
What is h here?

247
00:18:41,680 --> 00:18:43,560
Yeah.

248
00:18:43,560 --> 00:18:45,040
h is a function.

249
00:18:45,040 --> 00:18:46,040
Which function is it?

250
00:18:46,040 --> 00:18:48,040
We have two functions here.

251
00:18:48,040 --> 00:18:49,040
Yeah.

252
00:18:49,040 --> 00:19:00,960
Yeah, it's this inner function, and very specifically, it's this inner function

253
00:19:00,960 --> 00:19:07,320
code in addition to the environment that says y is 5.

254
00:19:07,320 --> 00:19:09,120
Yeah.

255
00:19:09,120 --> 00:19:12,040
So that's h itself.

256
00:19:12,040 --> 00:19:13,120
The value of h.

257
00:19:13,120 --> 00:19:18,280
Then when we call h of 3, h is a function with environment.

258
00:19:18,280 --> 00:19:19,280
It's a closure.

259
00:19:19,280 --> 00:19:20,760
It's this function.

260
00:19:20,760 --> 00:19:25,560
So when we call h of 3, we say z is equal to 3.

261
00:19:25,560 --> 00:19:27,600
We will get the value 8 back out.

262
00:19:27,600 --> 00:19:28,600
Cool.

263
00:19:29,240 --> 00:19:31,040
We're good to go here.

264
00:19:31,040 --> 00:19:32,520
h is a function.

265
00:19:32,520 --> 00:19:34,640
The value here is 3.

266
00:19:34,640 --> 00:19:37,120
Now what's the value of the second line?

267
00:19:37,120 --> 00:19:38,120
Yeah.

268
00:19:38,120 --> 00:19:40,120
All the way in the back.

269
00:19:40,120 --> 00:19:41,120
12.

270
00:19:41,120 --> 00:19:44,120
Why is it 12?

271
00:19:44,120 --> 00:19:48,400
Yeah, definitely.

272
00:19:48,400 --> 00:19:52,480
So y has been updated by the previous line of code.

273
00:19:52,480 --> 00:19:55,440
y is saved in this line.

274
00:19:55,440 --> 00:20:01,080
When we say y plus equals z, we've actually updated the context.

275
00:20:01,080 --> 00:20:06,120
We've updated the environment so that now y is equal to 8.

276
00:20:06,120 --> 00:20:10,160
When we call it a second time with the value 4, we're adding 4 to 8.

277
00:20:10,160 --> 00:20:11,160
We get 12.

278
00:20:11,160 --> 00:20:14,160
That's what's returned.

279
00:20:14,160 --> 00:20:16,200
Okay.

280
00:20:16,200 --> 00:20:19,360
Let's do it one more time.

281
00:20:19,360 --> 00:20:33,200
With j equals f of 5, what is j?

282
00:20:33,200 --> 00:20:34,200
It's a function.

283
00:20:34,200 --> 00:20:35,200
Yep.

284
00:20:35,200 --> 00:20:36,200
Just like before.

285
00:20:36,200 --> 00:20:37,200
j is a function.

286
00:20:37,200 --> 00:20:39,160
And it's got y equals 5.

287
00:20:39,160 --> 00:20:41,400
The context y equals 5.

288
00:20:41,400 --> 00:20:46,520
When we call j of 3, what do we get?

289
00:20:46,520 --> 00:20:52,720
Do we get 8 or do we get 15?

290
00:20:52,720 --> 00:20:54,880
How many people vote 8?

291
00:20:54,880 --> 00:20:56,240
How many people vote 15?

292
00:20:56,240 --> 00:20:57,240
All right.

293
00:20:57,240 --> 00:20:58,880
We hardly even have to ask.

294
00:20:58,880 --> 00:20:59,880
Yeah.

295
00:20:59,880 --> 00:21:01,640
Everyone there that I saw said 8.

296
00:21:01,640 --> 00:21:04,200
We've created new context, new environment.

297
00:21:04,200 --> 00:21:05,400
That's what we're updating.

298
00:21:05,400 --> 00:21:11,300
So similarly, when we call j of 4, we're gonna end up with 12.

299
00:21:11,300 --> 00:21:12,720
Now the question is...

300
00:21:12,720 --> 00:21:15,640
What happens with this print?

301
00:21:15,640 --> 00:21:27,360
Is h equal to j?

302
00:21:27,360 --> 00:21:30,840
How many people are gonna vote yes?

303
00:21:30,840 --> 00:21:33,680
How many people are gonna vote no?

304
00:21:33,680 --> 00:21:36,640
How many people are gonna vote it depends?

305
00:21:36,640 --> 00:21:41,240
That was a trick.

306
00:21:41,240 --> 00:21:42,240
No.

307
00:21:42,240 --> 00:21:44,920
The answer here is no.

308
00:21:44,920 --> 00:21:48,220
So these two are not equivalent.

309
00:21:48,220 --> 00:21:52,560
And under no circumstance are they actually equivalent.

310
00:21:52,560 --> 00:21:58,920
Except to us as high-level reasoning beings observing the code, we can say they look very

311
00:21:58,920 --> 00:22:00,100
similar.

312
00:22:00,100 --> 00:22:03,440
They have the same code representing them.

313
00:22:03,440 --> 00:22:05,720
They currently have the same state.

314
00:22:05,720 --> 00:22:07,040
But they are not equivalent.

315
00:22:07,040 --> 00:22:09,320
They point to two different spaces in memory.

316
00:22:09,320 --> 00:22:11,760
They have two different representations.

317
00:22:11,760 --> 00:22:12,760
They are not equal.

318
00:22:12,760 --> 00:22:13,760
Yeah?

319
00:22:13,760 --> 00:22:21,320
Will we check if they have the same representation in JavaScript?

320
00:22:21,320 --> 00:22:22,320
Yeah.

321
00:22:22,320 --> 00:22:25,440
So could we make it so that these...

322
00:22:25,440 --> 00:22:28,800
This would be true.

323
00:22:28,800 --> 00:22:29,800
Yes and no.

324
00:22:29,800 --> 00:22:36,080
We could turn h and j into kind of objects that we could then write our own equals method

325
00:22:36,080 --> 00:22:41,920
for, where we would be checking to say, is the current state of these things equivalent?

326
00:22:41,920 --> 00:22:45,360
And do they then also have the same code?

327
00:22:45,360 --> 00:22:50,320
But as it stands with just them being functions, no, we can't, I don't think.

328
00:22:50,320 --> 00:22:51,320
Yeah?

329
00:22:51,320 --> 00:22:55,760
What is being compared?

330
00:22:55,760 --> 00:22:56,760
What is being compared?

331
00:22:56,760 --> 00:22:57,760
Or...

332
00:22:57,760 --> 00:22:58,760
What does it look at?

333
00:22:58,760 --> 00:23:02,260
That's a good question.

334
00:23:02,260 --> 00:23:03,260
I don't know.

335
00:23:03,260 --> 00:23:06,860
My hunch here is that it's looking at its location in memory.

336
00:23:06,860 --> 00:23:10,300
But I don't actually have a perfect answer for that.

337
00:23:10,300 --> 00:23:11,300
Yeah.

338
00:23:11,300 --> 00:23:12,300
Yeah?

339
00:23:12,300 --> 00:23:13,300
Presumably.

340
00:23:13,300 --> 00:23:14,300
Yeah.

341
00:23:14,300 --> 00:23:20,420
Like, where are these things pointing to in memory?

342
00:23:20,420 --> 00:23:26,220
I don't want to say that with 100% certainty, but that's the common approach here.

343
00:23:26,220 --> 00:23:28,980
It could also be runtime dependent.

344
00:23:28,980 --> 00:23:30,460
So node might do one thing.

345
00:23:30,460 --> 00:23:32,780
V8 might do a different thing.

346
00:23:32,780 --> 00:23:36,660
Something of the sort.

347
00:23:36,660 --> 00:23:37,660
Other questions here?

348
00:23:37,660 --> 00:23:38,660
We've discussed before that JavaScript functions don't return pointers.

349
00:23:38,660 --> 00:23:49,980
So will it really be comparing pointers?

350
00:23:49,980 --> 00:23:52,180
We've discussed before they don't return pointers?

351
00:23:52,180 --> 00:23:53,180
What do you mean?

352
00:23:53,180 --> 00:23:56,180
There was a question about pointers and functions.

353
00:23:56,180 --> 00:23:57,180
Yeah, yeah.

354
00:23:58,140 --> 00:24:07,540
So there's a difference between a pointer being a function pointer and being a pointer.

355
00:24:07,540 --> 00:24:15,900
So H and J effectively are pointers to memory, where they have code and environment information

356
00:24:15,900 --> 00:24:17,380
stored.

357
00:24:17,380 --> 00:24:19,260
That's what makes a closure.

358
00:24:19,260 --> 00:24:23,540
It's a pointer to a tuple of code and environment.

359
00:24:23,540 --> 00:24:26,660
It's not a pointer to just function code.

360
00:24:26,660 --> 00:24:28,140
That's kind of the difference there.

361
00:24:28,140 --> 00:24:29,140
Yeah.

362
00:24:29,140 --> 00:24:35,140
Would it still be a closure if it didn't update the state of Y, but it just, like,

363
00:24:35,140 --> 00:24:37,140
captured it when you passed in the value?

364
00:24:37,140 --> 00:24:39,140
So, like, it would have its own state, maybe?

365
00:24:39,140 --> 00:24:40,140
Yeah.

366
00:24:40,140 --> 00:24:46,140
So would this still be a closure if we kind of weren't doing any of this fancy Y and X

367
00:24:46,140 --> 00:24:47,140
stuff?

368
00:24:47,140 --> 00:24:48,140
Yeah.

369
00:24:48,140 --> 00:24:49,140
It definitely still is.

370
00:24:49,140 --> 00:24:56,140
Well, I meant, like, if JavaScript worked differently, where instead of it updating

371
00:24:56,620 --> 00:25:00,620
something in the scope above it, like, it just, it didn't, like, actually update it.

372
00:25:00,620 --> 00:25:05,620
So, like, if you called the first time with H or 3 and give 8, and then the second call

373
00:25:05,620 --> 00:25:07,620
would give 9, would that still be a closure?

374
00:25:07,620 --> 00:25:08,620
Yeah.

375
00:25:08,620 --> 00:25:09,620
Yeah.

376
00:25:09,620 --> 00:25:13,620
So that is still a closure, even if we aren't, even if we don't have an updatable environment.

377
00:25:13,620 --> 00:25:15,120
We still store it in environment.

378
00:25:15,120 --> 00:25:20,620
We still have that Y offset, or offset, or whatever.

379
00:25:20,620 --> 00:25:21,620
Yeah.

380
00:25:22,100 --> 00:25:28,100
Are we updating X when...

381
00:25:28,100 --> 00:25:29,100
Yeah.

382
00:25:29,100 --> 00:25:33,380
So, like, does X here change?

383
00:25:33,380 --> 00:25:35,200
My hunch is no.

384
00:25:35,200 --> 00:25:39,500
If X were an object, then potentially, yeah.

385
00:25:39,500 --> 00:25:42,540
Where these two would actually be pointing to the same object.

386
00:25:42,540 --> 00:25:48,940
But because X in this case is just, like, an integer of 5, it shouldn't be updated.

387
00:25:48,940 --> 00:25:54,860
We could test that just by putting a console log X, but I'll leave that to you guys to

388
00:25:54,860 --> 00:25:57,700
test yourself.

389
00:25:57,700 --> 00:26:00,060
I believe it is no, though.

390
00:26:00,060 --> 00:26:04,740
It is not changing.

391
00:26:04,740 --> 00:26:11,500
Any other questions?

392
00:26:11,500 --> 00:26:15,380
We'll spend a lot of time on this and, like, draw a lot of diagrams.

393
00:26:15,380 --> 00:26:20,660
So even if it's not crystal clear right now, hopefully within a few weeks, it will be.

394
00:26:20,660 --> 00:26:21,660
Yeah?

395
00:26:21,660 --> 00:26:22,660
Yeah.

396
00:26:22,660 --> 00:26:26,420
An example of how to do this before it goes away?

397
00:26:26,420 --> 00:26:27,420
Yeah.

398
00:26:27,420 --> 00:26:30,060
So why would you ever want to do this?

399
00:26:30,060 --> 00:26:31,060
That's fair.

400
00:26:31,060 --> 00:26:32,780
I do this all the time.

401
00:26:32,780 --> 00:26:37,940
Let me show you an example at the end of class of, like, actual code where I do this.

402
00:26:37,940 --> 00:26:48,820
Because it is extremely helpful to be able to, like, generate functions algorithmically.

403
00:26:48,820 --> 00:26:54,540
Or as part of your code and not have to write all of your functions yourself.

404
00:26:54,540 --> 00:27:00,380
So this idea that we want over in the first one...

405
00:27:00,380 --> 00:27:05,580
We're creating new functions every time we call make add function.

406
00:27:05,580 --> 00:27:13,100
So that I don't have to write a new add 42 function and then an add 43 function, et cetera.

407
00:27:13,100 --> 00:27:17,380
You'll often find it's the case that when you write a function, you've wanted to write

408
00:27:17,380 --> 00:27:19,420
the same thing other times.

409
00:27:19,420 --> 00:27:22,220
Or a similar thing with different state.

410
00:27:22,220 --> 00:27:24,860
And so that is exactly what this does.

411
00:27:24,860 --> 00:27:30,460
So I will search briefly at the end of class for some Python code that does something very

412
00:27:30,460 --> 00:27:31,700
similar.

413
00:27:31,700 --> 00:27:34,380
If I don't find something, I'll post on Piazza.

414
00:27:34,420 --> 00:27:36,700
Because you'll definitely want to use this.

415
00:27:36,700 --> 00:27:39,420
It'll come in handy a lot.

416
00:27:39,420 --> 00:27:44,460
All right.

417
00:27:44,460 --> 00:27:55,380
Let's get back to those slides.

418
00:27:55,380 --> 00:27:59,180
So another thing that we can use functions for is...

419
00:27:59,180 --> 00:28:05,180
We talked about scoping, where we wanted to hide our variables inside of a scope and

420
00:28:05,180 --> 00:28:08,960
not allow them to leak out to the outside scope.

421
00:28:08,960 --> 00:28:14,020
More broadly, we can use them to create modules inside of our code.

422
00:28:14,020 --> 00:28:20,980
We can represent whole chunks of our code as wrapped inside of functions that we then

423
00:28:20,980 --> 00:28:23,480
allow things to be exported from.

424
00:28:23,480 --> 00:28:27,620
So that other people can import them and use them.

425
00:28:27,620 --> 00:28:33,860
This is good for hiding information if you want to have, like, secret values inside of

426
00:28:33,860 --> 00:28:40,100
your module that you don't want other libraries to be able to access.

427
00:28:40,100 --> 00:28:46,320
It's also really useful for, like, this idea of exporting only a few functions.

428
00:28:46,320 --> 00:28:52,880
You can have a very simple exterior API, even though your interior is quite complicated

429
00:28:52,880 --> 00:28:57,320
by only exporting a few functions.

430
00:28:57,320 --> 00:29:01,940
So modules were not a part of JavaScript originally.

431
00:29:01,940 --> 00:29:05,940
But people could pretend to use them.

432
00:29:05,940 --> 00:29:11,600
I don't think this example is particularly illuminating, so I'm actually gonna skip it.

433
00:29:11,600 --> 00:29:16,380
But the module code is online, if you want to take a look.

434
00:29:16,380 --> 00:29:18,620
All right.

435
00:29:18,620 --> 00:29:21,400
So that's first class functions in JavaScript.

436
00:29:21,400 --> 00:29:25,220
There were three core ideas that JavaScript...

437
00:29:25,220 --> 00:29:27,500
We were gonna use JavaScript to show.

438
00:29:27,500 --> 00:29:29,300
One of them was these first class functions.

439
00:29:29,300 --> 00:29:34,820
Now we'll dive into objects, and then we'll cover flexibility at the very end.

440
00:29:34,820 --> 00:29:36,420
Okay.

441
00:29:36,420 --> 00:29:41,060
What are JavaScript objects?

442
00:29:41,060 --> 00:29:48,940
Simply, they are maps of names to values.

443
00:29:48,940 --> 00:29:55,440
All that an object is is a collection of property names and the value that those property

444
00:29:55,440 --> 00:29:57,400
names point to.

445
00:29:57,400 --> 00:30:04,520
So if you've used dictionaries in Python, exact same thing.

446
00:30:04,520 --> 00:30:12,600
We create them with what's called literal notation, where we can use these curly braces

447
00:30:12,700 --> 00:30:13,700
to say...

448
00:30:13,700 --> 00:30:15,420
Like, create an object.

449
00:30:15,420 --> 00:30:20,860
X is the name of the value that points to 3.

450
00:30:20,860 --> 00:30:24,060
Y points to root.

451
00:30:24,060 --> 00:30:28,380
And then you can access them by just doing .x.

452
00:30:28,380 --> 00:30:35,700
Or if you like dictionary style, you can do closing brackets with the property that you

453
00:30:35,700 --> 00:30:39,740
want.

454
00:30:39,740 --> 00:30:44,160
So that's objects in a nutshell.

455
00:30:44,160 --> 00:30:47,680
They're just maps from key to value.

456
00:30:47,680 --> 00:30:53,720
And because functions are just like values, we can have functions on our objects just

457
00:30:53,720 --> 00:30:56,160
as any other value would be.

458
00:30:56,160 --> 00:30:59,520
We could have a function...

459
00:30:59,520 --> 00:31:12,700
Object.f is a function that references the object itself.

460
00:31:12,700 --> 00:31:22,500
Any questions on objects at a first pass?

461
00:31:22,500 --> 00:31:27,740
I did want to clarify one thing I mentioned in class on Monday.

462
00:31:27,740 --> 00:31:30,080
I had talked about how...

463
00:31:30,080 --> 00:31:40,860
Actually, it might just be easier to show in code.

464
00:31:40,860 --> 00:31:49,380
So we mentioned that we could have our arrow syntax...

465
00:31:49,380 --> 00:31:53,920
This is a function that returns the value 3.

466
00:31:53,920 --> 00:31:57,460
And then I said...

467
00:31:57,460 --> 00:32:00,880
This is a function that returns an object.

468
00:32:00,880 --> 00:32:05,680
That was a slight mistake on my part.

469
00:32:05,680 --> 00:32:14,040
This is a function that returns an object with the property x pointing to 3.

470
00:32:14,040 --> 00:32:21,400
And just to clarify, this here, without the named parameter, this is a function that will

471
00:32:21,400 --> 00:32:23,560
execute the value 3.

472
00:32:23,560 --> 00:32:25,160
So it's not actually returning an object.

473
00:32:25,160 --> 00:32:26,680
It's not returning anything.

474
00:32:26,680 --> 00:32:29,240
It's just executing the value 3.

475
00:32:29,240 --> 00:32:30,800
Whatever that means.

476
00:32:30,800 --> 00:32:36,840
So we could put a console.log 3, for example, and it will execute that inner chunk of code.

477
00:32:36,840 --> 00:32:43,640
But without object syntax, we will not create the object to be returned.

478
00:32:43,640 --> 00:32:48,040
So it was a mistake fixing that for clarity.

479
00:32:48,040 --> 00:32:50,320
Okay.

480
00:32:50,320 --> 00:32:56,200
Back to the slides.

481
00:32:56,200 --> 00:32:59,560
All right.

482
00:32:59,560 --> 00:33:02,780
So we're doing something kind of neat here, though.

483
00:33:02,780 --> 00:33:04,640
We're using this.

484
00:33:04,640 --> 00:33:12,200
And you have probably used this in your other languages in Java or self in Python.

485
00:33:12,200 --> 00:33:16,280
C++ as well.

486
00:33:16,280 --> 00:33:18,920
What this actually is...

487
00:33:18,920 --> 00:33:21,760
It's coming from another language called self.

488
00:33:21,760 --> 00:33:27,200
Which is kind of funny that they have self now in Python instead of this.

489
00:33:27,200 --> 00:33:28,200
Which...

490
00:33:28,200 --> 00:33:29,200
Anyway.

491
00:33:29,200 --> 00:33:33,780
Self is from the early 90s or late 80s.

492
00:33:33,780 --> 00:33:36,480
Coming from Smalltalk, which is from the 70s.

493
00:33:36,480 --> 00:33:39,840
So from far away back there.

494
00:33:39,840 --> 00:33:44,040
We'll talk more about that when we get to object oriented programming.

495
00:33:44,040 --> 00:33:50,240
But intuitively, this is representing the object that we are currently talking about.

496
00:33:50,240 --> 00:34:01,320
So when we do this.x inside of the function assigned to the object obj, this represents

497
00:34:01,320 --> 00:34:02,640
that obj.

498
00:34:02,640 --> 00:34:04,720
The O-B-J.

499
00:34:04,720 --> 00:34:07,600
So we can reference our self.

500
00:34:07,600 --> 00:34:10,200
All right.

501
00:34:10,200 --> 00:34:24,800
We can take a quick look into receivers.

502
00:34:24,800 --> 00:34:27,880
So not too crazy.

503
00:34:27,880 --> 00:34:33,700
We can create an object using object syntax of these curly braces.

504
00:34:33,700 --> 00:34:37,380
We have three keys.

505
00:34:37,380 --> 00:34:40,580
The x, x root, f.

506
00:34:40,580 --> 00:34:45,460
They're all just initialized the same way, with comma in between any given value.

507
00:34:45,460 --> 00:34:53,540
And inside of our function f, we can reference the object that we have created.

508
00:34:53,540 --> 00:35:00,100
So if we ask what the value of x is here, it is what?

509
00:35:00,100 --> 00:35:01,100
1337.

510
00:35:01,100 --> 00:35:02,100
Right.

511
00:35:02,100 --> 00:35:07,980
Because we've defined it to be 1337 up above.

512
00:35:07,980 --> 00:35:21,780
If we call f of 3, what does this print out?

513
00:35:21,780 --> 00:35:25,860
Does it print out a function?

514
00:35:25,860 --> 00:35:28,900
So we're executing f, right?

515
00:35:28,900 --> 00:35:30,420
With the value 3.

516
00:35:30,420 --> 00:35:34,220
F itself is a function.

517
00:35:34,220 --> 00:35:42,100
But when we execute f, we will get the returned value of whatever this statement is.

518
00:35:42,100 --> 00:35:44,100
1341.

519
00:35:44,100 --> 00:35:46,100
Oops.

520
00:35:46,100 --> 00:35:48,100
1341.

521
00:35:48,100 --> 00:35:52,520
And why is that?

522
00:35:52,520 --> 00:35:57,640
Because we are incrementing the value of x.

523
00:35:57,640 --> 00:36:00,660
And then we're requesting what is the value of x.

524
00:36:00,660 --> 00:36:03,160
And then we add whatever was passed to it.

525
00:36:03,160 --> 00:36:05,960
The value of x was initially 1337.

526
00:36:05,960 --> 00:36:11,360
We increment it, making it 1330 what?

527
00:36:11,360 --> 00:36:12,840
8.

528
00:36:12,840 --> 00:36:18,540
And then we add 3 to 1338 for 1341.

529
00:36:18,540 --> 00:36:21,560
So finally, what is the last value here?

530
00:36:21,600 --> 00:36:22,600
10.

531
00:36:22,600 --> 00:36:23,600
Definitely.

532
00:36:23,600 --> 00:36:24,600
We didn't change that.

533
00:36:24,600 --> 00:36:29,320
It's the same as it's been from the start.

534
00:36:29,320 --> 00:36:31,240
So this is pretty powerful.

535
00:36:31,240 --> 00:36:38,720
But by which I mean the concept of this is pretty powerful.

536
00:36:38,720 --> 00:36:53,260
Being able to be self-referential is important for objects.

537
00:36:53,260 --> 00:37:12,940
Any questions with the receiver?

538
00:37:12,940 --> 00:37:13,940
I'm sorry.

539
00:37:13,940 --> 00:37:16,220
This started right as the drilling started.

540
00:37:16,220 --> 00:37:17,220
What was that?

541
00:37:17,220 --> 00:37:18,220
A little bit louder?

542
00:37:18,220 --> 00:37:19,220
Yeah.

543
00:37:19,220 --> 00:37:20,220
Yeah.

544
00:37:20,220 --> 00:37:25,540
So it helps update object state.

545
00:37:25,540 --> 00:37:29,620
The keyword this helps update object state.

546
00:37:29,620 --> 00:37:33,500
It also just helps reference object state.

547
00:37:33,500 --> 00:37:36,620
Maybe we just need to know what the value of x is.

548
00:37:36,620 --> 00:37:42,380
And without this, we don't really know.

549
00:37:42,380 --> 00:37:51,180
We could try and get around it by always having a second parameter to our functions.

550
00:37:51,180 --> 00:37:59,340
And then we could call obj of f of obj comma 3, for example.

551
00:37:59,340 --> 00:38:10,780
And then we'd be passing ourself to our function so that we could reference ourself's value.

552
00:38:10,780 --> 00:38:14,900
And if you're familiar with Python, you will say, hey, that looks like Python, because

553
00:38:14,900 --> 00:38:17,420
that's exactly what you're doing.

554
00:38:17,420 --> 00:38:23,220
But because you do it every time you make a function call, Python says we can just get

555
00:38:23,220 --> 00:38:26,020
rid of that object being passed in.

556
00:38:26,020 --> 00:38:29,500
Since you're doing it anyway, we'll do it under the hood for you.

557
00:38:29,500 --> 00:38:32,460
But this is exactly what you do in Python.

558
00:38:32,460 --> 00:38:42,500
And similar thing happening in JavaScript.

559
00:38:42,500 --> 00:38:59,860
Any other questions, confusions, notes?

560
00:38:59,860 --> 00:39:05,060
So we could create a function called obj.

561
00:39:05,060 --> 00:39:07,980
And it would not take any parameters.

562
00:39:07,980 --> 00:39:15,140
And it would return a function that takes a y.

563
00:39:15,140 --> 00:39:24,740
And inside of here, we could say this is equal to 10 and x equals 1337.

564
00:39:24,740 --> 00:39:30,940
And then we return x plus y.

565
00:39:30,940 --> 00:39:31,940
And we say x++.

566
00:39:31,940 --> 00:39:35,780
Is that what you're thinking?

567
00:39:35,780 --> 00:39:36,780
Yeah.

568
00:39:36,780 --> 00:39:40,780
How different are these two snippets of code?

569
00:39:40,780 --> 00:39:50,460
Yeah, so precisely.

570
00:39:50,460 --> 00:39:53,500
So we can no longer reference...

571
00:39:53,540 --> 00:40:04,420
So if we create O1 equals obj, and we can call this fun obj, maybe.

572
00:40:04,420 --> 00:40:09,900
We've actually obfuscated or hidden our values.

573
00:40:09,900 --> 00:40:18,300
If we wanted to reference x on our fun version of this object, we can't.

574
00:40:18,300 --> 00:40:21,980
We've made it secret.

575
00:40:21,980 --> 00:40:25,500
This is actually precisely where the idea of modules comes in.

576
00:40:25,500 --> 00:40:32,980
Where we've created a function to export, and it's hidden some state for us.

577
00:40:32,980 --> 00:40:35,820
So yeah.

578
00:40:35,820 --> 00:40:38,000
But similar.

579
00:40:38,000 --> 00:40:40,100
Definitely similar concepts.

580
00:40:40,100 --> 00:40:46,300
That we're returning some value that we want to work with that captures state.

581
00:40:46,300 --> 00:40:49,300
Definitely similar concepts.

582
00:40:49,460 --> 00:40:50,460
Yeah?

583
00:40:50,460 --> 00:40:57,900
Do they work similar to classes, then?

584
00:40:57,900 --> 00:41:03,540
What an excellent question.

585
00:41:03,540 --> 00:41:07,140
Where did that go?

586
00:41:07,140 --> 00:41:09,140
Keynote decided it had had enough.

587
00:41:09,140 --> 00:41:11,380
Give me a second here.

588
00:41:11,380 --> 00:41:15,620
There we go.

589
00:41:15,620 --> 00:41:20,100
So I thought JavaScript had classes.

590
00:41:20,100 --> 00:41:21,100
It does.

591
00:41:21,100 --> 00:41:22,100
Currently.

592
00:41:22,100 --> 00:41:23,980
It didn't before.

593
00:41:23,980 --> 00:41:26,300
So classes are something that are pretty convenient.

594
00:41:26,300 --> 00:41:32,580
You've seen them in so many other languages, where we have these templates for our objects.

595
00:41:32,580 --> 00:41:33,580
That we say...

596
00:41:33,580 --> 00:41:36,900
Here's a class of objects that will all look the same.

597
00:41:36,900 --> 00:41:38,980
They will all have the function f.

598
00:41:38,980 --> 00:41:42,300
They will all have the property x.

599
00:41:42,300 --> 00:41:46,940
So I want some way to easily create more of these objects.

600
00:41:46,940 --> 00:41:54,100
Before what you would have to do is instead use functions to create a constructor.

601
00:41:54,100 --> 00:41:58,340
But the key thing is that they're functionally equivalent.

602
00:41:58,340 --> 00:42:05,460
We could either use functions or we could use fancier notation with classes.

603
00:42:05,460 --> 00:42:07,940
So what is a function constructor?

604
00:42:07,940 --> 00:42:09,620
All it is is a function.

605
00:42:09,620 --> 00:42:16,300
But now any time you call that constructor, it is returning an object back to you.

606
00:42:16,300 --> 00:42:18,660
There's no fancy magic here.

607
00:42:18,660 --> 00:42:24,020
That's one of the reasons I actually really like JavaScript, especially in this context.

608
00:42:24,020 --> 00:42:27,920
There is so little magic going on behind the scenes.

609
00:42:27,920 --> 00:42:29,960
Everything is just covered by functions.

610
00:42:29,960 --> 00:42:36,980
We don't need these keywords like class or this unless we want it.

611
00:42:36,980 --> 00:42:41,560
So the one key kind of...

612
00:42:41,560 --> 00:42:45,940
One of the pieces of magic that I don't really like, though, or it's a preference thing,

613
00:42:45,940 --> 00:42:48,420
is this idea of proto.

614
00:42:48,420 --> 00:42:54,980
And proto is something that's going to bind multiple objects together to have similar

615
00:42:54,980 --> 00:42:56,380
properties.

616
00:42:56,380 --> 00:42:58,940
So that we can achieve things like classes.

617
00:42:58,940 --> 00:43:03,220
Where we can say all of the objects created here will have a color.

618
00:43:03,220 --> 00:43:09,180
All of the objects here will have the function f, for example.

619
00:43:09,180 --> 00:43:13,700
It's automatically set for us, so we can play around with it.

620
00:43:13,700 --> 00:43:15,540
And I think let's do exactly that.

621
00:43:15,540 --> 00:43:29,040
Let's play around with classes.

622
00:43:29,040 --> 00:43:36,040
So if all that we had were functions, what we might want to do is we could have a function

623
00:43:36,040 --> 00:43:37,760
car.

624
00:43:37,760 --> 00:43:42,000
And this is a constructor for a car.

625
00:43:42,000 --> 00:43:43,920
It's going to take a make and a model.

626
00:43:43,920 --> 00:43:50,560
It uses the this keyword that we were just looking at to generate an object for us of

627
00:43:50,560 --> 00:43:51,800
type car.

628
00:43:51,800 --> 00:43:55,060
This is the constructor function.

629
00:43:55,060 --> 00:44:03,620
And then we can set for all cars, my suite property is 42.

630
00:44:03,620 --> 00:44:07,180
Then we can create a new car.

631
00:44:07,180 --> 00:44:14,780
And we can execute or look at properties on that car.

632
00:44:14,780 --> 00:44:17,620
So this probably looks somewhat familiar.

633
00:44:17,620 --> 00:44:22,140
Like if you squint at it, it looks like normal object oriented stuff.

634
00:44:22,140 --> 00:44:24,180
But we're using just functions.

635
00:44:24,180 --> 00:44:25,180
And this.

636
00:44:25,180 --> 00:44:29,960
We're using the this still.

637
00:44:29,960 --> 00:44:37,060
One of the, like, under the hood things that's going on, though, is this idea of proto.

638
00:44:37,060 --> 00:44:43,620
And proto is something that's connected between all of the functions, all of the objects created

639
00:44:43,620 --> 00:44:46,220
by the same function.

640
00:44:46,220 --> 00:44:54,340
So F, which was created up above as a car, has a proto property that points to the same

641
00:44:54,340 --> 00:44:58,020
place as the car prototype.

642
00:44:58,020 --> 00:45:06,900
And why that happens is so that when we set some property on a car on the car, like, prototype,

643
00:45:06,900 --> 00:45:12,040
it sets it for all of our cars.

644
00:45:12,040 --> 00:45:17,240
So we can say things like car.prototype.color is black.

645
00:45:17,240 --> 00:45:28,000
This means that all of our cars have a black color.

646
00:45:28,000 --> 00:45:32,320
The way that this works is one of the things that we will also dive into more.

647
00:45:32,320 --> 00:45:36,180
So I don't want to kind of go too deep into it.

648
00:45:36,180 --> 00:45:42,820
But one of the neat things is that we can update and override the proto's value.

649
00:45:42,820 --> 00:45:48,340
So up above, we've said the prototype says all cars have the color black.

650
00:45:48,340 --> 00:45:56,580
However, the T car, the Toyota Corolla, is red.

651
00:45:56,580 --> 00:46:02,260
And that will update that object's version of red or that object's version of color,

652
00:46:02,260 --> 00:46:03,260
but none of the other ones.

653
00:46:03,260 --> 00:46:04,260
Yeah?

654
00:46:04,340 --> 00:46:10,340
So updating that object's color, can you do that before you set all the object's color?

655
00:46:10,340 --> 00:46:16,340
Or does it have to be after?

656
00:46:16,340 --> 00:46:17,340
Yeah.

657
00:46:17,340 --> 00:46:18,340
Yeah.

658
00:46:18,340 --> 00:46:19,340
Great question.

659
00:46:19,340 --> 00:46:27,380
So can we have set this T.color before we're setting the prototype version of the color?

660
00:46:27,380 --> 00:46:31,300
What do you guys think?

661
00:46:31,300 --> 00:46:34,740
Even if you don't know JavaScript, it's fine.

662
00:46:34,740 --> 00:46:35,740
What are your thoughts?

663
00:46:35,740 --> 00:46:37,300
Like, should this work?

664
00:46:37,300 --> 00:46:42,300
Should it not work?

665
00:46:42,300 --> 00:46:50,500
Yeah, so maybe no.

666
00:46:50,500 --> 00:46:54,580
Because then all of the other cars don't have color.

667
00:46:54,580 --> 00:46:57,920
And this object is suddenly, like, the wrong shape.

668
00:46:57,920 --> 00:47:01,880
It has a property that none of the other cars have.

669
00:47:01,880 --> 00:47:04,320
I like the sentiment.

670
00:47:04,320 --> 00:47:08,560
JavaScript says shape doesn't matter.

671
00:47:08,560 --> 00:47:10,120
And it will let you do that.

672
00:47:10,120 --> 00:47:11,120
Yeah.

673
00:47:11,120 --> 00:47:16,800
No, it is kind of funky that we can set properties on this object that no other objects would

674
00:47:16,800 --> 00:47:18,900
have.

675
00:47:18,900 --> 00:47:20,680
But JavaScript wants to be flexible.

676
00:47:20,680 --> 00:47:23,240
It wants to say do whatever you want.

677
00:47:23,240 --> 00:47:25,040
So it will let you do it.

678
00:47:25,040 --> 00:47:37,160
The question, though, that I do have for you is what is T.color here?

679
00:47:37,160 --> 00:47:41,960
What's this?

680
00:47:41,960 --> 00:47:43,080
Do we get red?

681
00:47:43,080 --> 00:47:49,080
Do we get black?

682
00:47:49,080 --> 00:47:58,560
How many people vote red?

683
00:47:58,560 --> 00:48:00,080
How many people vote black?

684
00:48:00,080 --> 00:48:01,840
Wow, okay.

685
00:48:01,840 --> 00:48:02,840
It's pretty split.

686
00:48:02,840 --> 00:48:03,840
50-50.

687
00:48:03,840 --> 00:48:04,840
All right.

688
00:48:04,840 --> 00:48:07,040
I'll hear an argument either way.

689
00:48:07,040 --> 00:48:08,560
Somebody who's voting red.

690
00:48:08,560 --> 00:48:09,560
Why is that?

691
00:48:09,560 --> 00:48:10,560
Yeah?

692
00:48:10,560 --> 00:48:30,920
Yeah, so because the T.color is overriding the prototype's color.

693
00:48:30,920 --> 00:48:32,640
That seems reasonable.

694
00:48:32,640 --> 00:48:33,640
Argument for black.

695
00:48:33,640 --> 00:48:34,640
Yeah?

696
00:48:34,640 --> 00:48:45,680
Yeah, so the prototype hasn't set the color yet.

697
00:48:45,680 --> 00:48:51,000
So once we set the color, then now that's the, like, rule of the land.

698
00:48:51,000 --> 00:48:54,800
All cars are now set to be black.

699
00:48:54,800 --> 00:48:55,800
Another thought?

700
00:48:55,800 --> 00:48:56,800
Yeah?

701
00:48:56,800 --> 00:49:20,440
Yeah, so if we create another car down here, call it A, create an accord, this color is

702
00:49:20,440 --> 00:49:21,440
what?

703
00:49:21,440 --> 00:49:23,440
It'll be black.

704
00:49:23,440 --> 00:49:24,440
Yeah.

705
00:49:24,440 --> 00:49:33,160
So here what's happening is when we look for color on the A object, we're going to

706
00:49:33,160 --> 00:49:39,360
see that A does not actually have a color, and go look to the prototype and say, what's

707
00:49:39,360 --> 00:49:41,240
the prototype say?

708
00:49:41,240 --> 00:49:44,400
And the prototype has color set as black.

709
00:49:44,400 --> 00:49:49,200
So it will print out the value black.

710
00:49:49,200 --> 00:49:53,200
If we do a console.log.

711
00:49:53,200 --> 00:50:04,280
But that's also the key idea for what is the color of T here as being red.

712
00:50:04,280 --> 00:50:11,980
Because when we go to the object, the object T has a color of red.

713
00:50:11,980 --> 00:50:17,120
If it didn't have a color set at all, then it would go to the prototype and say, what's

714
00:50:17,120 --> 00:50:19,540
the color on the prototype?

715
00:50:19,540 --> 00:50:21,600
And the color on the prototype is black.

716
00:50:21,600 --> 00:50:27,420
But because we have it set on the object itself, we're good to go.

717
00:50:27,420 --> 00:50:33,960
And this kind of prototype chasing is used for every property that you try and access

718
00:50:33,960 --> 00:50:36,080
on an object in JavaScript.

719
00:50:36,080 --> 00:50:46,680
So if you try to use T.toString, and let's say that this does not exist, if we try and

720
00:50:46,680 --> 00:50:52,380
print out T.toString, we'll check the object first.

721
00:50:52,380 --> 00:50:54,080
That doesn't have toString.

722
00:50:54,080 --> 00:50:55,760
Then we check the prototype.

723
00:50:55,760 --> 00:50:57,520
That doesn't have toString.

724
00:50:57,520 --> 00:51:00,800
But because it's an object, it has...

725
00:51:00,800 --> 00:51:03,540
The prototype itself has a prototype.

726
00:51:03,540 --> 00:51:07,840
And the prototype of the prototype is the object base class.

727
00:51:07,840 --> 00:51:12,440
And the object base class has a default implementation of toString.

728
00:51:12,440 --> 00:51:14,400
So we use that implementation.

729
00:51:14,400 --> 00:51:20,480
So it's this prototype chaining that looks like inheritance in any other language.

730
00:51:20,480 --> 00:51:21,480
Yeah?

731
00:51:21,480 --> 00:51:26,680
How does this differ from myCreate class?

732
00:51:26,680 --> 00:51:28,040
It doesn't, really.

733
00:51:28,040 --> 00:51:30,760
It's just being set on the...

734
00:51:30,760 --> 00:51:31,760
With different notation.

735
00:51:31,760 --> 00:51:32,760
Yeah.

736
00:51:32,760 --> 00:51:33,760
Question?

737
00:51:33,760 --> 00:51:38,760
So the prototype, is that an object of itself?

738
00:51:38,760 --> 00:51:39,760
Yeah.

739
00:51:39,760 --> 00:51:44,360
So char.prototype here is an object.

740
00:51:44,360 --> 00:51:45,720
When this gets to...

741
00:51:45,720 --> 00:51:50,920
I think it's on the next slide, actually.

742
00:51:50,920 --> 00:51:54,040
No.

743
00:51:54,040 --> 00:51:55,040
It's not.

744
00:51:55,040 --> 00:51:56,040
All right.

745
00:51:56,040 --> 00:51:59,120
In JavaScript, almost everything is an object.

746
00:51:59,120 --> 00:52:04,240
There are a few primitives, such as integers, characters.

747
00:52:04,240 --> 00:52:08,120
But almost everything else is treated the same way as an object.

748
00:52:08,120 --> 00:52:10,960
As a complex object.

749
00:52:10,960 --> 00:52:16,000
And that allows these kind of reuse of ideas for everything.

750
00:52:16,000 --> 00:52:18,000
We don't treat prototypes as special.

751
00:52:18,000 --> 00:52:20,000
They're just like anything else.

752
00:52:20,000 --> 00:52:21,000
Yeah?

753
00:52:21,000 --> 00:52:32,480
Yeah, I'm like 90% sure.

754
00:52:32,480 --> 00:52:34,440
Double check for me.

755
00:52:34,440 --> 00:52:42,560
But I'm 90% sure this is setting it on the prototype itself.

756
00:52:42,560 --> 00:52:51,920
All right.

757
00:52:51,920 --> 00:52:53,800
So why are objects good?

758
00:52:53,800 --> 00:52:59,480
I mean, you've been kind of indoctrinated, as we all are, as computer science majors

759
00:52:59,480 --> 00:53:02,840
or minors or just taking the class.

760
00:53:02,840 --> 00:53:05,900
When you learn programming, you start with object-oriented.

761
00:53:05,900 --> 00:53:07,460
And there's a reason for that.

762
00:53:07,460 --> 00:53:10,960
Because it's really convenient to use to organize your programs.

763
00:53:10,960 --> 00:53:15,120
It's really convenient to reuse parts of your program.

764
00:53:15,120 --> 00:53:19,840
So I don't think it's too necessary to push this point.

765
00:53:19,840 --> 00:53:24,840
It's kind of been pushed in every other class.

766
00:53:24,840 --> 00:53:28,040
So that's objects.

767
00:53:28,040 --> 00:53:33,320
The last little bit of JavaScript is about flexibility.

768
00:53:33,320 --> 00:53:37,720
These were features such as not requiring semicolons.

769
00:53:37,720 --> 00:53:44,880
If you come from C, C++, Java, which is what everyone was writing, you needed semicolons.

770
00:53:44,880 --> 00:53:47,040
JavaScript said, no, you don't.

771
00:53:47,040 --> 00:53:48,160
We can just put that in.

772
00:53:48,160 --> 00:53:50,200
The compiler is pretty smart.

773
00:53:50,200 --> 00:53:53,220
Everyone uses new lines.

774
00:53:53,220 --> 00:53:55,900
Another big one is the idea of casting.

775
00:53:55,900 --> 00:54:03,220
When you try and do string 3 plus 3, should it give you 6?

776
00:54:03,220 --> 00:54:06,380
Should it give you 33?

777
00:54:06,380 --> 00:54:08,460
I don't know.

778
00:54:08,460 --> 00:54:12,260
JavaScript will decide for you what you wanted, though.

779
00:54:12,260 --> 00:54:13,340
And maybe that's helpful.

780
00:54:13,340 --> 00:54:15,440
Maybe it's not.

781
00:54:15,440 --> 00:54:20,760
And then there's this idea of hoisting, where you don't need to declare all of your variables

782
00:54:20,760 --> 00:54:22,740
when you start your function.

783
00:54:22,740 --> 00:54:25,100
And that today sounds kind of ridiculous.

784
00:54:25,100 --> 00:54:26,300
Of course you don't.

785
00:54:26,300 --> 00:54:32,660
But some of you have probably written old C code, just because you have an old C compiler,

786
00:54:32,660 --> 00:54:38,940
where you have to put, like, all of your int x, int y at the start of your function before

787
00:54:38,940 --> 00:54:41,020
you can actually initialize them.

788
00:54:41,020 --> 00:54:45,460
You have your declaration at the top of the function, initialization down below.

789
00:54:45,460 --> 00:54:47,780
So JavaScript said, let's not do that.

790
00:54:47,780 --> 00:54:49,580
That's kind of useless.

791
00:54:49,580 --> 00:54:53,780
We can figure it out ourselves.

792
00:54:53,780 --> 00:54:55,620
Some of the other cool features.

793
00:54:55,620 --> 00:54:58,940
You can evaluate code directly in the interpreter.

794
00:54:58,940 --> 00:55:01,440
There's a function exposed to you called eval.

795
00:55:01,440 --> 00:55:06,820
And if you pass a string, a JavaScript string, to eval, it'll run it.

796
00:55:06,820 --> 00:55:07,820
That's kind of neat.

797
00:55:07,820 --> 00:55:09,860
It's kind of scary, too.

798
00:55:09,860 --> 00:55:10,860
You know?

799
00:55:10,860 --> 00:55:15,580
If you're using eval and somebody else gives you code to run, who knows what they're gonna

800
00:55:15,580 --> 00:55:18,180
do with it?

801
00:55:18,180 --> 00:55:25,580
And this idea that we could say T.color equals red before we had said that the car has a

802
00:55:25,580 --> 00:55:26,860
color.

803
00:55:26,860 --> 00:55:33,620
That's called monkey patching, where we can give variables or give properties to objects,

804
00:55:33,620 --> 00:55:36,220
whatever we want.

805
00:55:36,220 --> 00:55:38,020
And we can do it on anything.

806
00:55:38,020 --> 00:55:45,780
We can override any function that previously existed to do something else.

807
00:55:45,780 --> 00:55:49,780
The issue with that is that you can override any function that previously existed to do

808
00:55:49,780 --> 00:55:51,740
anything else.

809
00:55:51,740 --> 00:55:55,780
So when you're running JavaScript code, you can hope that it's doing what you want it

810
00:55:55,780 --> 00:55:56,780
to do.

811
00:55:56,780 --> 00:56:00,820
And nobody has messed up your objects along the way.

812
00:56:00,820 --> 00:56:03,620
But maybe they did.

813
00:56:03,620 --> 00:56:05,860
All right.

814
00:56:05,860 --> 00:56:10,500
That's a brief bit about language flexibility.

815
00:56:10,500 --> 00:56:18,620
Any questions on that side of things?

816
00:56:18,620 --> 00:56:26,660
A lot of the flexibility now feels commonplace, because we have developed more ergonomic languages

817
00:56:26,660 --> 00:56:28,580
in the last 20 years.

818
00:56:28,580 --> 00:56:32,580
But coming from the 90s, that's kind of radical.

819
00:56:32,580 --> 00:56:37,740
Now, hopefully, I would like to show you a quick video.

820
00:56:37,980 --> 00:56:43,980
This is a funny interlude before we get to something fun.

821
00:56:43,980 --> 00:56:48,500
All right.

822
00:56:48,500 --> 00:56:57,500
I don't want to make it too loud.

823
00:56:57,500 --> 00:57:15,500
Let's make sure that it's using the right sound.

824
00:57:15,500 --> 00:57:23,500
Okay.

825
00:57:23,500 --> 00:57:27,260
This is from, like, 2008, so bear with it.

826
00:57:27,260 --> 00:57:29,260
It's worth it.

827
00:57:29,260 --> 00:57:33,260
Let's talk about Ruby.

828
00:57:33,260 --> 00:57:39,260
In Ruby, if you reference an undefined variable, of course, it name errors, as you would expect.

829
00:57:39,260 --> 00:57:45,260
And if you try to assign B to A with them undefined, of course, it name errors, as you

830
00:57:45,260 --> 00:57:46,260
would expect.

831
00:57:46,260 --> 00:57:50,260
And what happens if you try to assign A to A with A undefined?

832
00:57:50,260 --> 00:57:52,260
Correct.

833
00:57:52,260 --> 00:57:54,260
Nil.

834
00:57:54,260 --> 00:58:00,260
What?

835
00:58:00,260 --> 00:58:04,260
Let's talk about Ruby.

836
00:58:04,260 --> 00:58:08,260
Ruby, unlike some other dynamic languages, does not have bare words, so you cannot just

837
00:58:08,260 --> 00:58:11,260
type words in and have strings come out.

838
00:58:11,260 --> 00:58:16,260
Unless you define a particular method missing that does the right thing.

839
00:58:16,260 --> 00:58:20,260
And then, if you type bare words, suddenly, Ruby supports bare words.

840
00:58:20,260 --> 00:58:24,260
And, in fact, it will even support bare words with bangs in them.

841
00:58:24,260 --> 00:58:26,260
And this is not deserving of Watt.

842
00:58:26,260 --> 00:58:30,260
This is actually a result of how awesome Ruby is.

843
00:58:30,260 --> 00:58:38,260
But if you ever actually do this, then, Watt.

844
00:58:38,260 --> 00:58:44,260
Let's talk about JavaScript.

845
00:58:44,260 --> 00:58:48,260
Does anyone know, in JavaScript, what array plus array is?

846
00:58:48,260 --> 00:58:50,260
Well, let me ask you this first.

847
00:58:50,260 --> 00:58:52,260
What should array plus array be?

848
00:58:52,260 --> 00:58:54,260
Empty array?

849
00:58:54,260 --> 00:58:56,260
I would also accept type error.

850
00:58:56,260 --> 00:58:58,260
That is not what array plus array is.

851
00:58:58,260 --> 00:59:00,260
Wrong.

852
00:59:00,260 --> 00:59:02,260
Wrong.

853
00:59:02,260 --> 00:59:06,260
Array plus array is empty string.

854
00:59:06,260 --> 00:59:08,260
Obviously.

855
00:59:08,260 --> 00:59:10,260
I think that's obvious to everyone.

856
00:59:10,260 --> 00:59:12,260
Now, what would array plus object be?

857
00:59:12,260 --> 00:59:16,260
This should obviously be type error, because those are completely disparate types.

858
00:59:16,260 --> 00:59:18,260
Does anyone know what this is?

859
00:59:18,260 --> 00:59:20,260
No. Close.

860
00:59:20,260 --> 00:59:22,260
No. Far away.

861
00:59:22,260 --> 00:59:24,260
It's object.

862
00:59:24,260 --> 00:59:26,260
Nicely done.

863
00:59:26,260 --> 00:59:30,260
Now, of course, because this is plus, so you can flip the operands and the same thing comes out.

864
00:59:30,260 --> 00:59:32,260
So, if we do...

865
00:59:32,260 --> 00:59:34,260
What? No, that's just an object.

866
00:59:34,260 --> 00:59:44,260
If you do object plus array, you should get exactly the same thing, which, as you can see, you do.

867
00:59:44,260 --> 00:59:48,260
And finally, the only one of these that's actually true is...

868
00:59:48,260 --> 00:59:50,260
Because, you know, you add arrays, you get empty string, that doesn't make sense.

869
00:59:50,260 --> 00:59:56,260
But an object plus an object is actually not a number, technically.

870
00:59:56,260 --> 01:00:00,260
So this one's actually right.

871
01:00:00,260 --> 01:00:02,260
Exactly, right?

872
01:00:02,260 --> 01:00:04,260
What is even going on in this lab?

873
01:00:04,260 --> 01:00:12,260
I don't even understand what person with a brain in their head would think that any of this is a good idea.

874
01:00:12,260 --> 01:00:14,260
Okay, okay.

875
01:00:14,260 --> 01:00:16,260
Enough making fun of languages that suck.

876
01:00:16,260 --> 01:00:18,260
Let's talk about JavaScript.

877
01:00:18,260 --> 01:00:28,260
If I say array.new 16, or just array 16, I get an array of 16 things, which it represents as 16 commas, which is obvious.

878
01:00:28,260 --> 01:00:34,260
And if I then join those with a string, then I get this string 16 times.

879
01:00:34,260 --> 01:00:38,260
This is actually the only line in this entire presentation that's reasonable.

880
01:00:38,260 --> 01:00:42,260
Now, if I take that string and then add a 1 to it, it interprets the 1 as...

881
01:00:42,260 --> 01:00:46,260
Or casts the 1 to a string, and then we get WAP 1 a bunch of times.

882
01:00:46,260 --> 01:00:48,260
Fine.

883
01:00:48,260 --> 01:00:52,260
Does anyone know what will happen if I subtract 1 from the string?

884
01:00:52,260 --> 01:00:54,260
I'm assuming no one does.

885
01:00:54,260 --> 01:00:56,260
I'll give you a hint.

886
01:00:56,260 --> 01:00:58,260
Does this help?

887
01:00:58,260 --> 01:01:00,260
Does anyone know?

888
01:01:01,260 --> 01:01:03,260
Does anyone know?

889
01:01:19,260 --> 01:01:21,260
All right.

890
01:01:21,260 --> 01:01:22,260
Good stuff.

891
01:01:22,260 --> 01:01:24,260
JavaScript makes a lot of sense sometimes.

892
01:01:24,260 --> 01:01:27,260
And other times makes absolutely no sense.

893
01:01:27,260 --> 01:01:31,260
But that's kind of the price we are paying with language flexibility.

894
01:01:31,260 --> 01:01:34,260
You know, it's really cool that you can add strings to numbers.

895
01:01:34,260 --> 01:01:36,260
Or subtract strings from numbers.

896
01:01:36,260 --> 01:01:37,260
Until you do it.

897
01:01:37,260 --> 01:01:38,260
And then you're like...

898
01:01:38,260 --> 01:01:39,260
Why can I do that?

899
01:01:39,260 --> 01:01:42,260
But at least your program didn't crash.

900
01:01:42,260 --> 01:01:43,260
Maybe.

901
01:01:43,260 --> 01:01:46,260
Maybe not.

902
01:01:46,260 --> 01:01:49,260
So the takeaways from JavaScript...

903
01:01:49,260 --> 01:01:51,260
That first class functions are very powerful.

904
01:01:51,260 --> 01:01:55,260
We're going to be using them a lot during this class.

905
01:01:55,260 --> 01:01:57,260
Secondly, language flexibility.

906
01:01:57,260 --> 01:01:59,260
Definitely not free.

907
01:01:59,260 --> 01:02:00,260
It's cool.

908
01:02:00,260 --> 01:02:05,260
The ability to do things that you normally can't do in other languages is great.

909
01:02:05,260 --> 01:02:08,260
But there's always a tradeoff.

910
01:02:08,260 --> 01:02:12,260
And sometimes you shouldn't add two objects and get zero.

911
01:02:12,260 --> 01:02:15,260
Who does that make sense to?

912
01:02:15,260 --> 01:02:19,260
So that is JavaScript.

913
01:02:19,260 --> 01:02:23,260
We are going to take a step away from JavaScript now.

914
01:02:23,260 --> 01:02:30,260
And we're going to go towards what PL people tend to think of when they think of PL.

915
01:02:30,260 --> 01:02:32,260
Which is a bit mathier.

916
01:02:32,260 --> 01:02:37,260
So before we step away from the good language of JavaScript,

917
01:02:37,260 --> 01:02:41,260
and familiar interpreters and things of that sort,

918
01:02:41,260 --> 01:02:45,260
are there any last questions on this area?

919
01:02:45,260 --> 01:02:47,260
Yeah?

920
01:02:48,260 --> 01:02:56,260
Yeah, yeah, yeah.

921
01:02:56,260 --> 01:02:59,260
I'll get one of those at the end of class.

922
01:02:59,260 --> 01:03:04,260
Or on Piazza later.

923
01:03:04,260 --> 01:03:08,260
Although the modules was an example of that as well.

924
01:03:08,260 --> 01:03:12,260
But I kind of skipped over that.

925
01:03:13,260 --> 01:03:21,260
Yeah?

926
01:03:21,260 --> 01:03:25,260
For like the JS code section?

927
01:03:25,260 --> 01:03:26,260
Yeah.

928
01:03:26,260 --> 01:03:28,260
I can make that work.

929
01:03:28,260 --> 01:03:31,260
We can do that.

930
01:03:31,260 --> 01:03:37,260
Let me make a note so I don't forget.

931
01:03:37,260 --> 01:03:44,260
Any other notes, questions?

932
01:03:44,260 --> 01:03:55,260
All right.

933
01:03:55,260 --> 01:04:04,260
In that case...

934
01:04:04,260 --> 01:04:08,260
We're going to start talking about what's called the Lambda Calculus.

935
01:04:08,260 --> 01:04:12,260
It's a language that was invented in the 30s.

936
01:04:12,260 --> 01:04:15,260
1930s.

937
01:04:15,260 --> 01:04:17,260
By Church.

938
01:04:17,260 --> 01:04:20,260
Alonzo Church.

939
01:04:20,260 --> 01:04:22,260
We've just seen the JavaScript functions.

940
01:04:22,260 --> 01:04:26,260
Where we were using them as first class.

941
01:04:26,260 --> 01:04:32,260
The syntax that we were kind of using sometimes was this function with, you know, parameters.

942
01:04:32,260 --> 01:04:33,260
Do something.

943
01:04:33,260 --> 01:04:34,260
We call it...

944
01:04:34,260 --> 01:04:39,260
We did a little bit of arrow function syntax that's doing the same thing.

945
01:04:39,260 --> 01:04:42,260
But looks a little bit different.

946
01:04:42,260 --> 01:04:43,260
All right.

947
01:04:43,260 --> 01:04:46,260
What we're going to start with...

948
01:04:46,260 --> 01:04:50,260
So we heat up a little bit of JavaScript.

949
01:04:50,260 --> 01:04:56,260
And what we get out is Lambda Calculus.

950
01:04:56,260 --> 01:05:01,260
Lambda Calculus is the simplest programming language.

951
01:05:02,260 --> 01:05:04,260
It has one feature.

952
01:05:04,260 --> 01:05:07,260
Functions.

953
01:05:07,260 --> 01:05:08,260
Kind of two features.

954
01:05:08,260 --> 01:05:09,260
It also has variables.

955
01:05:09,260 --> 01:05:11,260
You need variables.

956
01:05:11,260 --> 01:05:15,260
You have to have some sort of state.

957
01:05:15,260 --> 01:05:19,260
But the one real feature of it is functions.

958
01:05:19,260 --> 01:05:25,260
Why we are going to be looking at this is because it really captures the idea of first class functions.

959
01:05:25,260 --> 01:05:28,260
If all you have are functions, functions must be first class.

960
01:05:28,260 --> 01:05:31,260
Nothing else could be first class.

961
01:05:31,260 --> 01:05:36,260
So we're going to see how do variables work in almost every language.

962
01:05:36,260 --> 01:05:38,260
It's very historically important.

963
01:05:38,260 --> 01:05:44,260
It's like the genesis language for that whole family of other languages.

964
01:05:44,260 --> 01:05:47,260
Like Lisp, Scheme, ML, Haskell.

965
01:05:47,260 --> 01:05:52,260
And then it's worked its way into languages like C++.

966
01:05:52,260 --> 01:05:54,260
When you have Lambda expressions.

967
01:05:54,260 --> 01:05:55,260
Or Python.

968
01:05:55,260 --> 01:05:56,260
Or Java.

969
01:05:56,260 --> 01:06:04,260
Every language is now, if it wasn't initially built on Lambda Calculus, it's adding it in.

970
01:06:04,260 --> 01:06:05,260
All right.

971
01:06:05,260 --> 01:06:07,260
So why else?

972
01:06:07,260 --> 01:06:14,260
If you go into programming languages research, or if you read any of the papers in this space,

973
01:06:14,260 --> 01:06:18,260
they almost all, without fail, are talking about Lambda Calculus.

974
01:06:18,260 --> 01:06:20,260
It's just what people like.

975
01:06:20,260 --> 01:06:21,260
Because it's simple.

976
01:06:21,260 --> 01:06:24,260
It allows you to add a simple feature to it.

977
01:06:24,260 --> 01:06:32,260
And reason about the language without all the complexity of everything else.

978
01:06:32,260 --> 01:06:34,260
Also because it's very similar to math.

979
01:06:34,260 --> 01:06:39,260
And so people who are getting into the space are coming often from mathematics.

980
01:06:39,260 --> 01:06:42,260
They like that it's very expression focused.

981
01:06:42,260 --> 01:06:45,260
So that's another reason.

982
01:06:45,260 --> 01:06:54,260
We can also use it as a kind of underlying understanding of how various languages might implement an idea.

983
01:06:54,260 --> 01:07:01,260
So evaluation order in a language like JavaScript is very different than in Haskell.

984
01:07:01,260 --> 01:07:06,260
Lambda Calculus will show that to us very clearly.

985
01:07:06,260 --> 01:07:10,260
With the evaluation strategy.

986
01:07:10,260 --> 01:07:12,260
Additionally, we can study different type systems.

987
01:07:12,260 --> 01:07:15,260
I don't go into that in this class.

988
01:07:15,260 --> 01:07:21,260
But it's very common to talk about types in Lambda Calc.

989
01:07:21,260 --> 01:07:25,260
So that you can have different typed versions.

990
01:07:25,260 --> 01:07:31,260
Like I mentioned, almost every PL paper is built on Lambda Calculus.

991
01:07:31,260 --> 01:07:32,260
It's just the way it is.

992
01:07:32,260 --> 01:07:34,260
A necessary evil if you don't like it.

993
01:07:34,260 --> 01:07:40,260
Or once you understand it, it becomes kind of straightforward.

994
01:07:40,260 --> 01:07:50,260
If you want to do any theoretical or kind of, like, formal proof work, you will be doing it with Lambda Calculus.

995
01:07:50,260 --> 01:07:59,260
So you can study things like various types of semantics in different languages with respect to Lambda Calc.

996
01:07:59,260 --> 01:08:02,260
Okay.

997
01:08:02,260 --> 01:08:07,260
There is reading I'm going to post, I think, later today or later this week.

998
01:08:07,260 --> 01:08:11,260
That I recommend before Monday's lecture.

999
01:08:11,260 --> 01:08:13,260
That you read.

1000
01:08:13,260 --> 01:08:16,260
This is a little bit of a preview of it.

1001
01:08:16,260 --> 01:08:22,260
So we're going to look at the syntax or the grammar of the language.

1002
01:08:22,260 --> 01:08:24,260
What is syntax in general?

1003
01:08:24,260 --> 01:08:30,260
What does it mean for the syntax of Lambda Calculus to be something?

1004
01:08:30,260 --> 01:08:34,260
Like, what are you looking at when you talk about syntax?

1005
01:08:34,260 --> 01:08:41,260
Yeah.

1006
01:08:41,260 --> 01:08:42,260
Yeah.

1007
01:08:42,260 --> 01:08:44,260
How you write the language.

1008
01:08:44,260 --> 01:08:51,260
What specifically, like, what symbols are you using when you are writing the language?

1009
01:08:51,260 --> 01:08:55,260
For example, in math, you might say X plus Y.

1010
01:08:55,260 --> 01:08:58,260
That's, like, syntactically correct.

1011
01:08:58,260 --> 01:09:06,260
If you said something like plus XY, that's not syntactically correct.

1012
01:09:06,260 --> 01:09:09,260
Unless you're in a reverse Polish notation system.

1013
01:09:09,260 --> 01:09:11,260
In which case it would be.

1014
01:09:11,260 --> 01:09:13,260
That's a different language style.

1015
01:09:13,260 --> 01:09:15,260
That's different syntax.

1016
01:09:15,260 --> 01:09:16,260
Okay.

1017
01:09:16,260 --> 01:09:19,260
So syntax, it's about, like, the symbols you're using.

1018
01:09:19,260 --> 01:09:21,260
The order that they're showing up.

1019
01:09:21,260 --> 01:09:23,260
What about the semantics?

1020
01:09:23,260 --> 01:09:26,260
What is the semantics of a language?

1021
01:09:26,260 --> 01:09:27,260
Yeah.

1022
01:09:27,260 --> 01:09:28,260
Yeah.

1023
01:09:28,260 --> 01:09:36,260
Like, how to understand, like, precedence and stuff like that?

1024
01:09:36,260 --> 01:09:37,260
Yeah.

1025
01:09:37,260 --> 01:09:39,260
So, how to understand precedence.

1026
01:09:39,260 --> 01:09:51,260
So, for example, when we do X plus Y times 2, do we evaluate X plus Y first?

1027
01:09:52,260 --> 01:09:56,260
Or do we evaluate Y times 2 first?

1028
01:09:56,260 --> 01:09:59,260
It really decided it was done.

1029
01:09:59,260 --> 01:10:04,260
So, the semantics of the language will tell you which one goes first.

1030
01:10:04,260 --> 01:10:07,260
How do we evaluate this expression?

1031
01:10:07,260 --> 01:10:10,260
What else does it tell you?

1032
01:10:10,260 --> 01:10:11,260
What's it about?

1033
01:10:12,260 --> 01:10:25,260
When you think about semantics, what does that represent?

1034
01:10:25,260 --> 01:10:27,260
Yeah.

1035
01:10:27,260 --> 01:10:28,260
The meaning.

1036
01:10:28,260 --> 01:10:29,260
Yeah.

1037
01:10:29,260 --> 01:10:33,260
The way I associate them is very much semantics is meaning.

1038
01:10:33,260 --> 01:10:35,260
Syntax is form.

1039
01:10:35,260 --> 01:10:38,260
It's what it looks like versus what it represents.

1040
01:10:38,260 --> 01:10:42,260
What it means underneath.

1041
01:10:42,260 --> 01:10:48,260
So, semantics tells you how do you, like, what is the end result?

1042
01:10:48,260 --> 01:10:50,260
What's the meaning?

1043
01:10:50,260 --> 01:10:55,260
How is this thing executed?

1044
01:10:55,260 --> 01:11:00,260
And I think that's probably where we're gonna stop with the slides.

1045
01:11:01,260 --> 01:11:02,260
So, we...

1046
01:11:02,260 --> 01:11:05,260
Because this thing is done.

1047
01:11:05,260 --> 01:11:09,260
We'll try and replug it in, see if that works.

1048
01:11:09,260 --> 01:11:12,260
With week 2, what we are going to be going into...

1049
01:11:12,260 --> 01:11:13,260
Oh, there you go.

1050
01:11:13,260 --> 01:11:14,260
It works.

1051
01:11:14,260 --> 01:11:15,260
We are finishing up anyway, though.

1052
01:11:15,260 --> 01:11:17,260
So, it's not a big deal here.

1053
01:11:17,260 --> 01:11:22,260
With week 2, what we will be looking at is what's the syntax of lambda calc?

1054
01:11:22,260 --> 01:11:25,260
And then what's the semantics of lambda calc?

1055
01:11:26,260 --> 01:11:33,260
The reading that I mentioned is going to be very helpful in understanding what this line means.

1056
01:11:33,260 --> 01:11:39,260
So, if this second line on the screen does not currently make perfect sense to you,

1057
01:11:39,260 --> 01:11:43,260
I recommend reading the chapter that I'm going to upload.

1058
01:11:43,260 --> 01:11:44,260
It'll be like a PDF.

1059
01:11:44,260 --> 01:11:47,260
You know, I'm just gonna scan a book.

1060
01:11:47,260 --> 01:11:52,260
If you do not have a partner for the homework assignment that's due later this week,

1061
01:11:52,260 --> 01:11:57,260
please stick around and find other people who do not have a partner.

1062
01:11:57,260 --> 01:12:03,260
If you have any other questions, feel free to come chat or find me in office hours right after class.

1063
01:12:22,260 --> 01:12:24,260
All right.

1064
01:12:52,260 --> 01:12:53,260
Thank you.

1065
01:13:22,260 --> 01:13:24,260
Thank you.

1066
01:13:52,260 --> 01:13:53,260
Thank you.

1067
01:13:53,260 --> 01:13:54,260
Thank you.

1068
01:14:23,260 --> 01:14:24,260
Thank you.

1069
01:14:24,260 --> 01:14:25,260
Thank you.

1070
01:15:23,260 --> 01:15:24,260
Thank you.

1071
01:15:24,260 --> 01:15:25,260
Thank you.

1072
01:15:52,260 --> 01:15:53,260
Thank you.

1073
01:15:53,260 --> 01:15:54,260
Thank you.

1074
01:15:54,260 --> 01:15:55,260
Thank you.

1075
01:15:55,260 --> 01:15:55,260


1076
01:16:23,260 --> 01:16:24,260
Thank you.

1077
01:16:24,260 --> 01:16:25,260
Thank you.

1078
01:16:25,260 --> 01:16:26,260
Thank you.

1079
01:16:26,260 --> 01:16:27,260
Thank you.

1080
01:16:27,260 --> 01:16:28,260
Thank you.

1081
01:16:28,260 --> 01:16:29,260
Thank you.

1082
01:16:29,260 --> 01:16:30,260
Thank you.

1083
01:16:30,260 --> 01:16:31,260
Thank you.

1084
01:16:31,260 --> 01:16:32,260
Thank you.

1085
01:16:32,260 --> 01:16:35,260
Thank you.

1086
01:16:52,260 --> 01:16:59,260
Thank you.

1087
01:17:22,260 --> 01:17:24,260
Thank you.

1088
01:17:52,260 --> 01:17:54,260
Thank you.

1089
01:18:22,260 --> 01:18:23,260
Thank you.

1090
01:18:23,260 --> 01:18:24,260
Thank you.

1091
01:18:24,260 --> 01:18:25,260
Thank you.

1092
01:18:25,260 --> 01:18:26,260
Thank you.

1093
01:18:26,260 --> 01:18:27,260
Thank you.

1094
01:18:27,260 --> 01:18:27,260


1095
01:18:52,260 --> 01:18:53,260
Thank you.

1096
01:18:53,260 --> 01:18:54,260
Thank you.

1097
01:18:54,260 --> 01:18:55,260
Thank you.

1098
01:18:55,260 --> 01:18:55,260


1099
01:19:22,260 --> 01:19:23,260
Thank you.

1100
01:19:23,260 --> 01:19:24,260
Thank you.

1101
01:19:24,260 --> 01:19:25,260
Thank you.

1102
01:19:25,260 --> 01:19:25,260


1103
01:19:52,260 --> 01:19:53,260
Thank you.

1104
01:19:53,260 --> 01:19:54,260
Thank you.

1105
01:19:54,260 --> 01:19:55,260
Thank you.

1106
01:19:55,260 --> 01:19:55,260


