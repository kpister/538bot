Hopefully that doesn't keep happening.
Thank you.
Thank you.
All right, guys.
Let's go ahead and get started.
So to start off, we got some notes.
The early deadline for the first homework and programming assignment are tomorrow.
So that is if you want 10% bonus points, submit by tomorrow night.
Otherwise, the normal deadline is this Sunday night at 11.59 p.m.
So get working on those.
I have office hours after class today.
If you're having any trouble setting things up or have questions, feel free to stop by.
I also have a chess board in there if you want to just sit and play chess for a little
bit.
Recordings.
I missed on Monday, I forgot to set up Zoom.
But hopefully I've contacted the department.
That thing looks like it's on.
I see myself in the camera over here.
So hopefully everything will be official and through Canvas going forward.
So use those for what you will.
If it turns out that you guys prefer watching recordings online, that's fine.
We'll have a little bit more of a sparse classroom.
For the people who do show up, just come sit closer to the front and we'll have more fun.
Okay.
Those are my notes.
Are there any notes from you guys?
Anything that's not working?
Any questions before we dive into lecture?
Yeah?
Is the early deadline just literally however many days beforehand and it's still midnight?
Yes, it's still midnight.
Yeah.
Yep.
The early deadline is at midnight or 11.59 p.m.
Yeah?
What's the name of the written assignment?
Yeah.
So grade scope is a little tricky.
So the question was, if we are submitting the written assignment as a group, which you
should definitely be submitting as a group, you need at least one group member.
What's the process for that?
After you submit as one person from the group, you can go to the submission and add your
teammates to that submission.
So one submission per group for the entire group, one submission.
Add your teammates.
Also select where the problem is in your submission.
So it will say, like, where is problem one?
And you highlight the area that is problem one.
Yeah.
That's all on grade scope.
Yeah?
Can we submit just the PA early or just the homework early?
And do you still get the extra credit?
Yes.
The extra credit is tied to the individual assignment.
So if you submit the PA early, you get 10% bonus points on the PA.
If you submit the homework early, you get 10% bonus points on the homework.
They're separate pieces.
Yep.
Anything else?
As we get into a rhythm with it, these will be very comfortable.
It's the same thing every time.
All right.
In that case, let's get back into JavaScript.
First class functions.
What are they?
Who can give me the three points of what makes a first class function all at once somebody
who didn't answer the same question yesterday?
What is first class functions?
What does it mean?
Yeah.
Go for it.
Yeah.
So is it using functions to create scopes for the variables inside of it?
That's one of the things that first class functions allows us to do.
So it's a capability of first class functions, but it's not necessarily what they are.
Yeah?
So it's the three things of the function can be defined in any scope, they can be passed
to other functions as values, and they can be returned from functions as values.
To say it in one tagline, first class functions means functions are values.
They're just normal values.
Just like you say let X equal 3, you can say let X equal a function.
All right.
So then that leads to a little bit of a pretty natural question coming after that.
Are these functions that we're working with the same thing as function pointers that you
might have seen in other languages like C?
Where you can, for example, call sort with a comparison function.
Where you tell the sort function how to sort the things in your list.
That's using a function pointer.
So are the functions that we're working with, these first class functions in JavaScript,
are they just function pointers?
This is one that I do want you to take a minute, chat with your peers, whoever's next to you,
yes or no, and why.
What makes it the same?
What makes it different?
So take a minute or two to chat.
All right.
Sounds like conversation is settling down.
Let's get a quick class poll.
How many people are in the yes camp?
These are just like the function pointers that you would see in, for example, C.
What about how many people are in the no camp?
Saying these are not just function pointers.
Something else is going on here.
Okay.
So large majority of the class is saying no.
Someone explain why.
What else is happening here?
Yeah.
Go for it.
Yeah, so C definitely does not let youï¿½ or at least most implementations of C do not
let you define your functions in any scope.
That's our first requirement for a first class function.
So it's true C doesn't have first class functions.
But C does let you still pass around these functions.
And some implementations of C actually do let you define them in any scope.
There still might be something different between a function pointer by itself being able to
define the function anywhere and pass it around and what we're doing in JavaScript.
There's another little piece that's happening in here.
And we saw it yesterday with the expressive code a little bit.
What else is going on?
Yeah.
Yeah.
Yeah.
So the function has access to variables that were around when it was defined.
That's kind of like the English way to describe the idea of a closure.
These functions in JavaScript are not just pointers.
They are function code, which is what you have in C, for example, with a function pointer.
And they also have environment.
That is the variables that are around when the function is being defined.
And these closures are things that we are going to deep dive into in a few lectures
when we kind of come back to JavaScript later in, I think, late February.
But for now, the important idea is that functions in JavaScript capture environment.
Traditional function pointers don't.
So you could have first class functions in some other languages and not have closures.
JavaScript has a specific form of first class function called a closure, where we have code
and we have environment going along with it.
All right.
Since it's one thing to see the slides and another thing to see code, let's dive into
what that might actually look like.
And you guys will have to let me know when it's the right size to read.
How's that?
Readable?
All the way in the back?
You guys can read it?
Yep.
Anybody want it larger?
No.
Okay.
So, last time we had a function called add 42, which what it did was it took an element
as a parameter and it returned the element plus 42.
Nothing too special.
But maybe we want to make a function that generically creates other add functions for
us.
What if we wanted an add 43 and an add 44?
It's kind of arbitrary, definitely contrived for this example, but this type of idea exists
all over the place.
So what we might have is a function called make add function, and the purpose of this
function is to return another function.
That's one of our primary features of first class functions, is that they can be returned.
So we're creating a function that returns another function, and importantly, we're going
to reference a variable that does not exist inside of our scope of this function, but
exists from the outer scope of the function that created it.
This offset variable comes from the make add function, not the inner function that
we're returning.
So let's use it and see what happens.
We can create an add 42, where we say this is equal to make add function with the value
42, and a sub 42, where we are make add function with negative 42.
Now when we call add 42 of 1, what are we going to get?
Do I have copilot on?
I do.
That's okay.
Turn that back off.
I was coding earlier.
What are we going to get here?
43.
Yeah.
I think that's a fair...
Like a reasonable assumption that we're adding 1 to add 42.
Add 42 is this inner function here, where this x will have the value 1, and then when
we try and look up offset, we will see that offset was 42, which was the value we were
given.
If we add 42 to 42, what do we get?
84.
Definitely.
Same thing happens, where we're looking up the value of offset each time.
It hasn't changed.
We haven't updated anything.
It's still the same value of 42.
Just to kind of finish this, what's sub 42, 1?
Negative 41.
Yeah, definitely.
This time, when we look up the value of offset, offset within the context of sub 42 is negative
42.
We have two different offset values.
There's an offset that's just for this value, and there's an offset that's just for that
value.
And we're going to go into the mechanics of that in a future lecture.
This one, all on the same page, that that would be 0.
Any questions on what we've done here?
All right, then let's make it a bit more complicated.
See if I can get some questions out of you guys.
These programs, once again, are all on Canvas.
I think they weren't last time I said that.
This time, I've double checked.
They really should be on Canvas now.
If they aren't, let me know, and I will try again to upload them.
Now we're going to create a new function called f.
Takes a parameter x.
Then we're gonna say let y equal x.
Okay?
And then we're going to return a new function that's not named.
That's fine.
It takes a parameter z, and it assigns y equals y plus z, and then returns y.
We call h equals f of 5.
And then we console.log h of 3.
Take a second.
Think to yourself.
First of all, what is the value of h?
And then what will this first line print?
So think it over to yourself for a second here.
Try and come up with an answer.
Who feels like they have an idea of what h is?
Okay.
Not too many of you.
So I'm gonna give you a little bit more time.
Chat with somebody next to you.
See if you guys can come to a consensus on what h is.
All right.
How many people now feel like they know what h is?
Feel a little bit more comfortable with it?
A decent number more.
Still not everyone, though.
So let's figure it out.
What is h?
Who's got an answer?
Yeah?
Is it 8?
Is it 8?
Is h equal to 8?
Ah.
This one, I'm on board.
I think this next one is 8.
Someone else.
What is h here?
Yeah.
h is a function.
Which function is it?
We have two functions here.
Yeah.
Yeah, it's this inner function, and very specifically, it's this inner function
code in addition to the environment that says y is 5.
Yeah.
So that's h itself.
The value of h.
Then when we call h of 3, h is a function with environment.
It's a closure.
It's this function.
So when we call h of 3, we say z is equal to 3.
We will get the value 8 back out.
Cool.
We're good to go here.
h is a function.
The value here is 3.
Now what's the value of the second line?
Yeah.
All the way in the back.
12.
Why is it 12?
Yeah, definitely.
So y has been updated by the previous line of code.
y is saved in this line.
When we say y plus equals z, we've actually updated the context.
We've updated the environment so that now y is equal to 8.
When we call it a second time with the value 4, we're adding 4 to 8.
We get 12.
That's what's returned.
Okay.
Let's do it one more time.
With j equals f of 5, what is j?
It's a function.
Yep.
Just like before.
j is a function.
And it's got y equals 5.
The context y equals 5.
When we call j of 3, what do we get?
Do we get 8 or do we get 15?
How many people vote 8?
How many people vote 15?
All right.
We hardly even have to ask.
Yeah.
Everyone there that I saw said 8.
We've created new context, new environment.
That's what we're updating.
So similarly, when we call j of 4, we're gonna end up with 12.
Now the question is...
What happens with this print?
Is h equal to j?
How many people are gonna vote yes?
How many people are gonna vote no?
How many people are gonna vote it depends?
That was a trick.
No.
The answer here is no.
So these two are not equivalent.
And under no circumstance are they actually equivalent.
Except to us as high-level reasoning beings observing the code, we can say they look very
similar.
They have the same code representing them.
They currently have the same state.
But they are not equivalent.
They point to two different spaces in memory.
They have two different representations.
They are not equal.
Yeah?
Will we check if they have the same representation in JavaScript?
Yeah.
So could we make it so that these...
This would be true.
Yes and no.
We could turn h and j into kind of objects that we could then write our own equals method
for, where we would be checking to say, is the current state of these things equivalent?
And do they then also have the same code?
But as it stands with just them being functions, no, we can't, I don't think.
Yeah?
What is being compared?
What is being compared?
Or...
What does it look at?
That's a good question.
I don't know.
My hunch here is that it's looking at its location in memory.
But I don't actually have a perfect answer for that.
Yeah.
Yeah?
Presumably.
Yeah.
Like, where are these things pointing to in memory?
I don't want to say that with 100% certainty, but that's the common approach here.
It could also be runtime dependent.
So node might do one thing.
V8 might do a different thing.
Something of the sort.
Other questions here?
We've discussed before that JavaScript functions don't return pointers.
So will it really be comparing pointers?
We've discussed before they don't return pointers?
What do you mean?
There was a question about pointers and functions.
Yeah, yeah.
So there's a difference between a pointer being a function pointer and being a pointer.
So H and J effectively are pointers to memory, where they have code and environment information
stored.
That's what makes a closure.
It's a pointer to a tuple of code and environment.
It's not a pointer to just function code.
That's kind of the difference there.
Yeah.
Would it still be a closure if it didn't update the state of Y, but it just, like,
captured it when you passed in the value?
So, like, it would have its own state, maybe?
Yeah.
So would this still be a closure if we kind of weren't doing any of this fancy Y and X
stuff?
Yeah.
It definitely still is.
Well, I meant, like, if JavaScript worked differently, where instead of it updating
something in the scope above it, like, it just, it didn't, like, actually update it.
So, like, if you called the first time with H or 3 and give 8, and then the second call
would give 9, would that still be a closure?
Yeah.
Yeah.
So that is still a closure, even if we aren't, even if we don't have an updatable environment.
We still store it in environment.
We still have that Y offset, or offset, or whatever.
Yeah.
Are we updating X when...
Yeah.
So, like, does X here change?
My hunch is no.
If X were an object, then potentially, yeah.
Where these two would actually be pointing to the same object.
But because X in this case is just, like, an integer of 5, it shouldn't be updated.
We could test that just by putting a console log X, but I'll leave that to you guys to
test yourself.
I believe it is no, though.
It is not changing.
Any other questions?
We'll spend a lot of time on this and, like, draw a lot of diagrams.
So even if it's not crystal clear right now, hopefully within a few weeks, it will be.
Yeah?
Yeah.
An example of how to do this before it goes away?
Yeah.
So why would you ever want to do this?
That's fair.
I do this all the time.
Let me show you an example at the end of class of, like, actual code where I do this.
Because it is extremely helpful to be able to, like, generate functions algorithmically.
Or as part of your code and not have to write all of your functions yourself.
So this idea that we want over in the first one...
We're creating new functions every time we call make add function.
So that I don't have to write a new add 42 function and then an add 43 function, et cetera.
You'll often find it's the case that when you write a function, you've wanted to write
the same thing other times.
Or a similar thing with different state.
And so that is exactly what this does.
So I will search briefly at the end of class for some Python code that does something very
similar.
If I don't find something, I'll post on Piazza.
Because you'll definitely want to use this.
It'll come in handy a lot.
All right.
Let's get back to those slides.
So another thing that we can use functions for is...
We talked about scoping, where we wanted to hide our variables inside of a scope and
not allow them to leak out to the outside scope.
More broadly, we can use them to create modules inside of our code.
We can represent whole chunks of our code as wrapped inside of functions that we then
allow things to be exported from.
So that other people can import them and use them.
This is good for hiding information if you want to have, like, secret values inside of
your module that you don't want other libraries to be able to access.
It's also really useful for, like, this idea of exporting only a few functions.
You can have a very simple exterior API, even though your interior is quite complicated
by only exporting a few functions.
So modules were not a part of JavaScript originally.
But people could pretend to use them.
I don't think this example is particularly illuminating, so I'm actually gonna skip it.
But the module code is online, if you want to take a look.
All right.
So that's first class functions in JavaScript.
There were three core ideas that JavaScript...
We were gonna use JavaScript to show.
One of them was these first class functions.
Now we'll dive into objects, and then we'll cover flexibility at the very end.
Okay.
What are JavaScript objects?
Simply, they are maps of names to values.
All that an object is is a collection of property names and the value that those property
names point to.
So if you've used dictionaries in Python, exact same thing.
We create them with what's called literal notation, where we can use these curly braces
to say...
Like, create an object.
X is the name of the value that points to 3.
Y points to root.
And then you can access them by just doing .x.
Or if you like dictionary style, you can do closing brackets with the property that you
want.
So that's objects in a nutshell.
They're just maps from key to value.
And because functions are just like values, we can have functions on our objects just
as any other value would be.
We could have a function...
Object.f is a function that references the object itself.
Any questions on objects at a first pass?
I did want to clarify one thing I mentioned in class on Monday.
I had talked about how...
Actually, it might just be easier to show in code.
So we mentioned that we could have our arrow syntax...
This is a function that returns the value 3.
And then I said...
This is a function that returns an object.
That was a slight mistake on my part.
This is a function that returns an object with the property x pointing to 3.
And just to clarify, this here, without the named parameter, this is a function that will
execute the value 3.
So it's not actually returning an object.
It's not returning anything.
It's just executing the value 3.
Whatever that means.
So we could put a console.log 3, for example, and it will execute that inner chunk of code.
But without object syntax, we will not create the object to be returned.
So it was a mistake fixing that for clarity.
Okay.
Back to the slides.
All right.
So we're doing something kind of neat here, though.
We're using this.
And you have probably used this in your other languages in Java or self in Python.
C++ as well.
What this actually is...
It's coming from another language called self.
Which is kind of funny that they have self now in Python instead of this.
Which...
Anyway.
Self is from the early 90s or late 80s.
Coming from Smalltalk, which is from the 70s.
So from far away back there.
We'll talk more about that when we get to object oriented programming.
But intuitively, this is representing the object that we are currently talking about.
So when we do this.x inside of the function assigned to the object obj, this represents
that obj.
The O-B-J.
So we can reference our self.
All right.
We can take a quick look into receivers.
So not too crazy.
We can create an object using object syntax of these curly braces.
We have three keys.
The x, x root, f.
They're all just initialized the same way, with comma in between any given value.
And inside of our function f, we can reference the object that we have created.
So if we ask what the value of x is here, it is what?
1337.
Right.
Because we've defined it to be 1337 up above.
If we call f of 3, what does this print out?
Does it print out a function?
So we're executing f, right?
With the value 3.
F itself is a function.
But when we execute f, we will get the returned value of whatever this statement is.
1341.
Oops.
1341.
And why is that?
Because we are incrementing the value of x.
And then we're requesting what is the value of x.
And then we add whatever was passed to it.
The value of x was initially 1337.
We increment it, making it 1330 what?
8.
And then we add 3 to 1338 for 1341.
So finally, what is the last value here?
10.
Definitely.
We didn't change that.
It's the same as it's been from the start.
So this is pretty powerful.
But by which I mean the concept of this is pretty powerful.
Being able to be self-referential is important for objects.
Any questions with the receiver?
I'm sorry.
This started right as the drilling started.
What was that?
A little bit louder?
Yeah.
Yeah.
So it helps update object state.
The keyword this helps update object state.
It also just helps reference object state.
Maybe we just need to know what the value of x is.
And without this, we don't really know.
We could try and get around it by always having a second parameter to our functions.
And then we could call obj of f of obj comma 3, for example.
And then we'd be passing ourself to our function so that we could reference ourself's value.
And if you're familiar with Python, you will say, hey, that looks like Python, because
that's exactly what you're doing.
But because you do it every time you make a function call, Python says we can just get
rid of that object being passed in.
Since you're doing it anyway, we'll do it under the hood for you.
But this is exactly what you do in Python.
And similar thing happening in JavaScript.
Any other questions, confusions, notes?
So we could create a function called obj.
And it would not take any parameters.
And it would return a function that takes a y.
And inside of here, we could say this is equal to 10 and x equals 1337.
And then we return x plus y.
And we say x++.
Is that what you're thinking?
Yeah.
How different are these two snippets of code?
Yeah, so precisely.
So we can no longer reference...
So if we create O1 equals obj, and we can call this fun obj, maybe.
We've actually obfuscated or hidden our values.
If we wanted to reference x on our fun version of this object, we can't.
We've made it secret.
This is actually precisely where the idea of modules comes in.
Where we've created a function to export, and it's hidden some state for us.
So yeah.
But similar.
Definitely similar concepts.
That we're returning some value that we want to work with that captures state.
Definitely similar concepts.
Yeah?
Do they work similar to classes, then?
What an excellent question.
Where did that go?
Keynote decided it had had enough.
Give me a second here.
There we go.
So I thought JavaScript had classes.
It does.
Currently.
It didn't before.
So classes are something that are pretty convenient.
You've seen them in so many other languages, where we have these templates for our objects.
That we say...
Here's a class of objects that will all look the same.
They will all have the function f.
They will all have the property x.
So I want some way to easily create more of these objects.
Before what you would have to do is instead use functions to create a constructor.
But the key thing is that they're functionally equivalent.
We could either use functions or we could use fancier notation with classes.
So what is a function constructor?
All it is is a function.
But now any time you call that constructor, it is returning an object back to you.
There's no fancy magic here.
That's one of the reasons I actually really like JavaScript, especially in this context.
There is so little magic going on behind the scenes.
Everything is just covered by functions.
We don't need these keywords like class or this unless we want it.
So the one key kind of...
One of the pieces of magic that I don't really like, though, or it's a preference thing,
is this idea of proto.
And proto is something that's going to bind multiple objects together to have similar
properties.
So that we can achieve things like classes.
Where we can say all of the objects created here will have a color.
All of the objects here will have the function f, for example.
It's automatically set for us, so we can play around with it.
And I think let's do exactly that.
Let's play around with classes.
So if all that we had were functions, what we might want to do is we could have a function
car.
And this is a constructor for a car.
It's going to take a make and a model.
It uses the this keyword that we were just looking at to generate an object for us of
type car.
This is the constructor function.
And then we can set for all cars, my suite property is 42.
Then we can create a new car.
And we can execute or look at properties on that car.
So this probably looks somewhat familiar.
Like if you squint at it, it looks like normal object oriented stuff.
But we're using just functions.
And this.
We're using the this still.
One of the, like, under the hood things that's going on, though, is this idea of proto.
And proto is something that's connected between all of the functions, all of the objects created
by the same function.
So F, which was created up above as a car, has a proto property that points to the same
place as the car prototype.
And why that happens is so that when we set some property on a car on the car, like, prototype,
it sets it for all of our cars.
So we can say things like car.prototype.color is black.
This means that all of our cars have a black color.
The way that this works is one of the things that we will also dive into more.
So I don't want to kind of go too deep into it.
But one of the neat things is that we can update and override the proto's value.
So up above, we've said the prototype says all cars have the color black.
However, the T car, the Toyota Corolla, is red.
And that will update that object's version of red or that object's version of color,
but none of the other ones.
Yeah?
So updating that object's color, can you do that before you set all the object's color?
Or does it have to be after?
Yeah.
Yeah.
Great question.
So can we have set this T.color before we're setting the prototype version of the color?
What do you guys think?
Even if you don't know JavaScript, it's fine.
What are your thoughts?
Like, should this work?
Should it not work?
Yeah, so maybe no.
Because then all of the other cars don't have color.
And this object is suddenly, like, the wrong shape.
It has a property that none of the other cars have.
I like the sentiment.
JavaScript says shape doesn't matter.
And it will let you do that.
Yeah.
No, it is kind of funky that we can set properties on this object that no other objects would
have.
But JavaScript wants to be flexible.
It wants to say do whatever you want.
So it will let you do it.
The question, though, that I do have for you is what is T.color here?
What's this?
Do we get red?
Do we get black?
How many people vote red?
How many people vote black?
Wow, okay.
It's pretty split.
50-50.
All right.
I'll hear an argument either way.
Somebody who's voting red.
Why is that?
Yeah?
Yeah, so because the T.color is overriding the prototype's color.
That seems reasonable.
Argument for black.
Yeah?
Yeah, so the prototype hasn't set the color yet.
So once we set the color, then now that's the, like, rule of the land.
All cars are now set to be black.
Another thought?
Yeah?
Yeah, so if we create another car down here, call it A, create an accord, this color is
what?
It'll be black.
Yeah.
So here what's happening is when we look for color on the A object, we're going to
see that A does not actually have a color, and go look to the prototype and say, what's
the prototype say?
And the prototype has color set as black.
So it will print out the value black.
If we do a console.log.
But that's also the key idea for what is the color of T here as being red.
Because when we go to the object, the object T has a color of red.
If it didn't have a color set at all, then it would go to the prototype and say, what's
the color on the prototype?
And the color on the prototype is black.
But because we have it set on the object itself, we're good to go.
And this kind of prototype chasing is used for every property that you try and access
on an object in JavaScript.
So if you try to use T.toString, and let's say that this does not exist, if we try and
print out T.toString, we'll check the object first.
That doesn't have toString.
Then we check the prototype.
That doesn't have toString.
But because it's an object, it has...
The prototype itself has a prototype.
And the prototype of the prototype is the object base class.
And the object base class has a default implementation of toString.
So we use that implementation.
So it's this prototype chaining that looks like inheritance in any other language.
Yeah?
How does this differ from myCreate class?
It doesn't, really.
It's just being set on the...
With different notation.
Yeah.
Question?
So the prototype, is that an object of itself?
Yeah.
So char.prototype here is an object.
When this gets to...
I think it's on the next slide, actually.
No.
It's not.
All right.
In JavaScript, almost everything is an object.
There are a few primitives, such as integers, characters.
But almost everything else is treated the same way as an object.
As a complex object.
And that allows these kind of reuse of ideas for everything.
We don't treat prototypes as special.
They're just like anything else.
Yeah?
Yeah, I'm like 90% sure.
Double check for me.
But I'm 90% sure this is setting it on the prototype itself.
All right.
So why are objects good?
I mean, you've been kind of indoctrinated, as we all are, as computer science majors
or minors or just taking the class.
When you learn programming, you start with object-oriented.
And there's a reason for that.
Because it's really convenient to use to organize your programs.
It's really convenient to reuse parts of your program.
So I don't think it's too necessary to push this point.
It's kind of been pushed in every other class.
So that's objects.
The last little bit of JavaScript is about flexibility.
These were features such as not requiring semicolons.
If you come from C, C++, Java, which is what everyone was writing, you needed semicolons.
JavaScript said, no, you don't.
We can just put that in.
The compiler is pretty smart.
Everyone uses new lines.
Another big one is the idea of casting.
When you try and do string 3 plus 3, should it give you 6?
Should it give you 33?
I don't know.
JavaScript will decide for you what you wanted, though.
And maybe that's helpful.
Maybe it's not.
And then there's this idea of hoisting, where you don't need to declare all of your variables
when you start your function.
And that today sounds kind of ridiculous.
Of course you don't.
But some of you have probably written old C code, just because you have an old C compiler,
where you have to put, like, all of your int x, int y at the start of your function before
you can actually initialize them.
You have your declaration at the top of the function, initialization down below.
So JavaScript said, let's not do that.
That's kind of useless.
We can figure it out ourselves.
Some of the other cool features.
You can evaluate code directly in the interpreter.
There's a function exposed to you called eval.
And if you pass a string, a JavaScript string, to eval, it'll run it.
That's kind of neat.
It's kind of scary, too.
You know?
If you're using eval and somebody else gives you code to run, who knows what they're gonna
do with it?
And this idea that we could say T.color equals red before we had said that the car has a
color.
That's called monkey patching, where we can give variables or give properties to objects,
whatever we want.
And we can do it on anything.
We can override any function that previously existed to do something else.
The issue with that is that you can override any function that previously existed to do
anything else.
So when you're running JavaScript code, you can hope that it's doing what you want it
to do.
And nobody has messed up your objects along the way.
But maybe they did.
All right.
That's a brief bit about language flexibility.
Any questions on that side of things?
A lot of the flexibility now feels commonplace, because we have developed more ergonomic languages
in the last 20 years.
But coming from the 90s, that's kind of radical.
Now, hopefully, I would like to show you a quick video.
This is a funny interlude before we get to something fun.
All right.
I don't want to make it too loud.
Let's make sure that it's using the right sound.
Okay.
This is from, like, 2008, so bear with it.
It's worth it.
Let's talk about Ruby.
In Ruby, if you reference an undefined variable, of course, it name errors, as you would expect.
And if you try to assign B to A with them undefined, of course, it name errors, as you
would expect.
And what happens if you try to assign A to A with A undefined?
Correct.
Nil.
What?
Let's talk about Ruby.
Ruby, unlike some other dynamic languages, does not have bare words, so you cannot just
type words in and have strings come out.
Unless you define a particular method missing that does the right thing.
And then, if you type bare words, suddenly, Ruby supports bare words.
And, in fact, it will even support bare words with bangs in them.
And this is not deserving of Watt.
This is actually a result of how awesome Ruby is.
But if you ever actually do this, then, Watt.
Let's talk about JavaScript.
Does anyone know, in JavaScript, what array plus array is?
Well, let me ask you this first.
What should array plus array be?
Empty array?
I would also accept type error.
That is not what array plus array is.
Wrong.
Wrong.
Array plus array is empty string.
Obviously.
I think that's obvious to everyone.
Now, what would array plus object be?
This should obviously be type error, because those are completely disparate types.
Does anyone know what this is?
No. Close.
No. Far away.
It's object.
Nicely done.
Now, of course, because this is plus, so you can flip the operands and the same thing comes out.
So, if we do...
What? No, that's just an object.
If you do object plus array, you should get exactly the same thing, which, as you can see, you do.
And finally, the only one of these that's actually true is...
Because, you know, you add arrays, you get empty string, that doesn't make sense.
But an object plus an object is actually not a number, technically.
So this one's actually right.
Exactly, right?
What is even going on in this lab?
I don't even understand what person with a brain in their head would think that any of this is a good idea.
Okay, okay.
Enough making fun of languages that suck.
Let's talk about JavaScript.
If I say array.new 16, or just array 16, I get an array of 16 things, which it represents as 16 commas, which is obvious.
And if I then join those with a string, then I get this string 16 times.
This is actually the only line in this entire presentation that's reasonable.
Now, if I take that string and then add a 1 to it, it interprets the 1 as...
Or casts the 1 to a string, and then we get WAP 1 a bunch of times.
Fine.
Does anyone know what will happen if I subtract 1 from the string?
I'm assuming no one does.
I'll give you a hint.
Does this help?
Does anyone know?
Does anyone know?
All right.
Good stuff.
JavaScript makes a lot of sense sometimes.
And other times makes absolutely no sense.
But that's kind of the price we are paying with language flexibility.
You know, it's really cool that you can add strings to numbers.
Or subtract strings from numbers.
Until you do it.
And then you're like...
Why can I do that?
But at least your program didn't crash.
Maybe.
Maybe not.
So the takeaways from JavaScript...
That first class functions are very powerful.
We're going to be using them a lot during this class.
Secondly, language flexibility.
Definitely not free.
It's cool.
The ability to do things that you normally can't do in other languages is great.
But there's always a tradeoff.
And sometimes you shouldn't add two objects and get zero.
Who does that make sense to?
So that is JavaScript.
We are going to take a step away from JavaScript now.
And we're going to go towards what PL people tend to think of when they think of PL.
Which is a bit mathier.
So before we step away from the good language of JavaScript,
and familiar interpreters and things of that sort,
are there any last questions on this area?
Yeah?
Yeah, yeah, yeah.
I'll get one of those at the end of class.
Or on Piazza later.
Although the modules was an example of that as well.
But I kind of skipped over that.
Yeah?
For like the JS code section?
Yeah.
I can make that work.
We can do that.
Let me make a note so I don't forget.
Any other notes, questions?
All right.
In that case...
We're going to start talking about what's called the Lambda Calculus.
It's a language that was invented in the 30s.
1930s.
By Church.
Alonzo Church.
We've just seen the JavaScript functions.
Where we were using them as first class.
The syntax that we were kind of using sometimes was this function with, you know, parameters.
Do something.
We call it...
We did a little bit of arrow function syntax that's doing the same thing.
But looks a little bit different.
All right.
What we're going to start with...
So we heat up a little bit of JavaScript.
And what we get out is Lambda Calculus.
Lambda Calculus is the simplest programming language.
It has one feature.
Functions.
Kind of two features.
It also has variables.
You need variables.
You have to have some sort of state.
But the one real feature of it is functions.
Why we are going to be looking at this is because it really captures the idea of first class functions.
If all you have are functions, functions must be first class.
Nothing else could be first class.
So we're going to see how do variables work in almost every language.
It's very historically important.
It's like the genesis language for that whole family of other languages.
Like Lisp, Scheme, ML, Haskell.
And then it's worked its way into languages like C++.
When you have Lambda expressions.
Or Python.
Or Java.
Every language is now, if it wasn't initially built on Lambda Calculus, it's adding it in.
All right.
So why else?
If you go into programming languages research, or if you read any of the papers in this space,
they almost all, without fail, are talking about Lambda Calculus.
It's just what people like.
Because it's simple.
It allows you to add a simple feature to it.
And reason about the language without all the complexity of everything else.
Also because it's very similar to math.
And so people who are getting into the space are coming often from mathematics.
They like that it's very expression focused.
So that's another reason.
We can also use it as a kind of underlying understanding of how various languages might implement an idea.
So evaluation order in a language like JavaScript is very different than in Haskell.
Lambda Calculus will show that to us very clearly.
With the evaluation strategy.
Additionally, we can study different type systems.
I don't go into that in this class.
But it's very common to talk about types in Lambda Calc.
So that you can have different typed versions.
Like I mentioned, almost every PL paper is built on Lambda Calculus.
It's just the way it is.
A necessary evil if you don't like it.
Or once you understand it, it becomes kind of straightforward.
If you want to do any theoretical or kind of, like, formal proof work, you will be doing it with Lambda Calculus.
So you can study things like various types of semantics in different languages with respect to Lambda Calc.
Okay.
There is reading I'm going to post, I think, later today or later this week.
That I recommend before Monday's lecture.
That you read.
This is a little bit of a preview of it.
So we're going to look at the syntax or the grammar of the language.
What is syntax in general?
What does it mean for the syntax of Lambda Calculus to be something?
Like, what are you looking at when you talk about syntax?
Yeah.
Yeah.
How you write the language.
What specifically, like, what symbols are you using when you are writing the language?
For example, in math, you might say X plus Y.
That's, like, syntactically correct.
If you said something like plus XY, that's not syntactically correct.
Unless you're in a reverse Polish notation system.
In which case it would be.
That's a different language style.
That's different syntax.
Okay.
So syntax, it's about, like, the symbols you're using.
The order that they're showing up.
What about the semantics?
What is the semantics of a language?
Yeah.
Yeah.
Like, how to understand, like, precedence and stuff like that?
Yeah.
So, how to understand precedence.
So, for example, when we do X plus Y times 2, do we evaluate X plus Y first?
Or do we evaluate Y times 2 first?
It really decided it was done.
So, the semantics of the language will tell you which one goes first.
How do we evaluate this expression?
What else does it tell you?
What's it about?
When you think about semantics, what does that represent?
Yeah.
The meaning.
Yeah.
The way I associate them is very much semantics is meaning.
Syntax is form.
It's what it looks like versus what it represents.
What it means underneath.
So, semantics tells you how do you, like, what is the end result?
What's the meaning?
How is this thing executed?
And I think that's probably where we're gonna stop with the slides.
So, we...
Because this thing is done.
We'll try and replug it in, see if that works.
With week 2, what we are going to be going into...
Oh, there you go.
It works.
We are finishing up anyway, though.
So, it's not a big deal here.
With week 2, what we will be looking at is what's the syntax of lambda calc?
And then what's the semantics of lambda calc?
The reading that I mentioned is going to be very helpful in understanding what this line means.
So, if this second line on the screen does not currently make perfect sense to you,
I recommend reading the chapter that I'm going to upload.
It'll be like a PDF.
You know, I'm just gonna scan a book.
If you do not have a partner for the homework assignment that's due later this week,
please stick around and find other people who do not have a partner.
If you have any other questions, feel free to come chat or find me in office hours right after class.
All right.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.

Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.

Thank you.
Thank you.
Thank you.

Thank you.
Thank you.
Thank you.

Thank you.
Thank you.
Thank you.

