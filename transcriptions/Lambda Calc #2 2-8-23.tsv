start	end	text
30000	38620	All right.
38620	41200	Let's get going.
41200	51140	So as I like to do, starting with a little bit of news, is there, like, I sound louder
51140	52140	to myself.
52140	53960	Do I sound louder to you guys?
53960	54960	No?
54960	55960	Maybe that's just me.
55960	57060	All right.
57060	64480	There was an interesting post end of January, so a little bit ago, about Rust in business.
64480	69360	A lot of people ask, like, okay, we're learning these languages, Haskell, Rust, JavaScript
69360	71440	I think is pretty easy to justify.
71440	74680	But do these other languages have an option?
74680	77340	Especially if I'm going to an established company.
77340	79760	And the answer is definitely yes.
79760	83120	So AWS does a lot of Rust.
83120	89520	If you've heard about Lambda, AWS Lambda, that is run entirely on a Rust service called
89520	92080	Firecracker.
92080	99360	Google is using Rust in Android and Chromium, as well as some of their other products.
99360	104760	Huawei is using it for their operating system stuff as well.
104760	107560	Facebook is using Rust for blockchain.
107560	110000	Microsoft is using Rust.
110000	114200	It's just every big company that you know is now using Rust.
114200	121180	They're migrating away from languages like C and C++ and using Rust when they can.
121180	126600	Other kind of also big companies, but maybe less well known, Shopify is huge.
126600	131920	They're using Rust not as a language for their service, but as a language to compile their
131920	133220	other language.
133220	135520	So they use Ruby for everything.
135520	140360	But they need a good Ruby compiler, so they wrote that in Rust.
140360	143640	Then there are, like, a bunch of startups using Rust.
143640	144640	Everybody's using Rust.
144640	146040	Rust all over the place.
146040	147040	Great.
147040	148400	So people are using it.
148400	149720	It's worth learning.
149720	153580	It's also worth learning just because it's fun.
153580	158740	That's the news for the day.
158740	159740	Some notes.
159740	160740	PA2.
160740	164300	There is a deadline extension.
164300	166460	This is just the programming assignment.
166460	168600	Homework is still due at the normal time.
168600	170660	Early deadline is still the same time.
170660	175340	Programming assignment 2 makes use of ideas that we're gonna be talking about next week.
175340	177340	So I'm giving you some more time to do it.
177340	183340	You can probably figure it out, but it'll be easier after Monday's lecture in particular.
183340	184380	Next Monday's lecture.
184380	188380	So one week extension on the hard deadline.
188380	190340	The early deadline is still tomorrow.
190340	194660	So if you want the bonus points, do it this week.
194660	197540	But getting 100% is good.
197540	198540	It's good enough.
198540	200540	So if you want to wait, wait.
200540	202260	Either way is fine.
202260	205340	PA3, though, is still due at the same time.
205340	209060	So we aren't pushing all programming assignments back.
209060	210300	It's just this one assignment.
210300	216180	That means if you don't do PA2 this week, you have to do PA2 and PA3 next week.
216180	218900	PA3 is also JavaScript.
219460	221500	Lastly, programming is hard.
221500	224980	A lot of you might not have worked with JavaScript very much before.
224980	228060	If you're having trouble, come stop by office hours.
228060	231180	Start early so that you know what you're not understanding.
231180	232340	And come ask questions.
232340	233860	We're here to help.
233860	239020	The point of this class is not that I'm trying to teach you how to write perfect JavaScript.
239020	241480	That's the point of the programming assignment.
241480	246140	So I'm not gonna spend lecture time saying here's how we write JavaScript.
246140	248020	That's something that you have to figure out.
248020	251340	And so if you're having a hard time with that, come chat.
251340	255020	Because that's where we can help you.
255020	256020	Those are the notes.
256020	257020	Any other questions...
257020	260980	Or any questions on this stuff?
260980	268380	Before we go to LambdaCalc?
268380	270980	How many people have finished PA2 already?
270980	271980	Okay.
271980	272980	A few.
272980	273980	Not too many.
273980	274980	How many people have started?
274980	275980	Oh, almost everybody.
275980	276980	Great.
276980	280340	Okay.
280340	284580	That's much better than UCSD.
284580	286020	There was a different culture there.
286020	287020	Okay.
287020	291540	So we're going to jump into LambdaCalc again.
291540	293820	We started last time, we looked at syntax.
293820	297420	And we said what does a LambdaCalculus program look like?
297420	301180	And then towards the end of class, we started evaluating those programs.
301180	306580	I want to start right where we left off of saying let's evaluate LambdaCalculus programs.
307180	309620	So we're going to do these three problems.
309620	311380	I believe they're new, right?
311380	312620	We didn't do these three last time.
312620	314140	This is where we ended.
314140	315140	All right.
315140	317660	So take two minutes.
317660	320960	Try and work these out on your own or with somebody next to you.
320960	325660	And then we'll go over them as a class.
385660	397020	All right.
397020	401620	It sounds pretty quiet, so I think that means that you guys are ready to go.
401620	404340	Let's start off with this one.
404340	406460	Who can give me first step?
406460	409460	What do we want to do to start this problem?
409460	411460	Yeah.
412060	415900	Assign 3 to Y.
415900	421500	So we're taking this 3 and we're passing it into the function LambdaY.2.
421500	422620	Y is the parameter.
422620	423940	So we'll have 3.
423940	424940	Sure.
424940	440860	So that's going to look something like LambdaX.2, where Y is equal to 3 of 5, right?
440860	441940	That's what you meant?
441940	450820	So we're going to say Y is equal to 3, and then we get the body of the function returned.
450820	452980	What can we do from here?
452980	454580	Sure.
454580	458500	We can assign 5 to X.
458500	461060	So we do the same process.
461060	462740	Put 5 in for X.
462820	479980	We get 2, where Y is equal to 3 and X is equal to 5.
479980	483380	Any questions on the two steps that we've taken here?
483380	486900	Because we went kind of all at once through it.
486900	487900	Yeah?
487900	498020	Can you explain the order of the Lambda function?
498020	499020	Yeah.
499020	501540	So we took a specific approach here.
501540	504700	We passed 3 in for Y first.
504700	509900	Could we have passed 5 in for X first instead?
509900	511020	I'm seeing a lot of nodding.
511020	512580	Yeah, we could have.
512580	518900	We chose to do 3 goes in for Y, but we could have done it in the other order.
518900	524140	And what would we have gotten if we went that way?
524140	525700	It would have been the same thing.
525700	530780	We would have had different intermediary steps, but we would end up with 2, where Y is 3 and
530780	532700	X is 5.
532700	533940	Yeah.
534860	544180	We'll talk more about order towards the end of class.
544180	546980	Other questions on this part?
546980	549980	All right.
549980	559740	Let's do the other side.
559740	560740	What should we do here?
560740	561740	Yeah?
562740	566740	That second 2, I believe, is a 3 on the 4th.
566740	571740	I believe you.
571740	578740	3 gets passed to the X.
578740	583220	We can look at this whole piece here as a function.
583220	587860	And the 3 is the argument to the outer part of the function, the X.
587980	596780	We get lambda Y dot 2, where X is equal to 3, 5.
596780	603020	What can we do now?
603020	604220	Pass 5 for the Y.
604220	613460	And what we get at the end is we have 2 remaining, and X is equal to 3, Y is 5.
613460	615660	I hate writing 5s.
615780	618100	I don't know why.
618100	619220	OK.
619220	622460	So we get 2, Y is 3, X is 5.
622460	624980	That leaves us with this last question.
624980	627820	Are these two equivalent?
627820	629100	And we can put those up.
635380	637420	Yes?
637420	639580	No?
639580	640300	No.
640300	641820	Why are they not equivalent?
646340	650380	Yeah, the variables are different.
650380	652940	On one side, we had X is 3, Y is 5.
652940	655180	On the other side, Y is 3, X is 5.
655180	656900	Our state is different.
656900	662380	We ended up with the same final expression result, but the state that goes with that
662380	664580	result is different.
664580	670180	This is very similar to in closures, or in JavaScript with closures, where two functions
670180	677180	might look identical, but the state that's going with them is different.
677180	681540	OK.
681540	683000	Let's do another one.
683000	684000	Take a minute.
684000	688180	Do this on your own.
688180	694220	The more of these that you do, the better, more efficient, and easily they will come
694220	695300	to you.
724220	749380	What is state?
749380	754140	What is state?
754140	758300	State is the representation of the environment.
758300	771340	So when we say, like, solve X plus Y, if you don't tell me what X is or what Y is, I can't
771340	773060	solve this problem.
773060	781260	I need some environment, some state, where I say X is 3 and Y is 2 in order to actually
781260	790580	solve for this equation.
790580	792380	That's a way of thinking of it.
792380	797220	You can kind of reframe it as the arguments to the expression.
797220	803940	But think about when you write code and you assign variables to your...
803940	809140	As you're writing code, when you execute, those variables accumulate information over
809140	810140	time.
810140	811140	They update.
811140	816020	That's the state of your program.
816020	818980	Yeah.
818980	822660	OK.
822660	826260	Let's reduce this expression here.
826260	835900	How should we start?
835900	836900	A is 7.
836900	837900	Yeah.
837900	842660	So we'll take this 7 and substitute it in for this parameter A here.
842660	853340	And we'll be left with lambda X dot X plus A of 4, where A is equal to 7.
853340	856220	Great.
856220	859580	What next?
859580	860580	X is 4.
860580	862420	We can pass in this 4 for X.
862420	868660	We'll get X plus A, where our state is A is 7.
868660	870620	And X is 4.
870620	871620	Great.
871620	873580	So when we solve it, we get 11.
873580	881660	When we actually plug in our variables, we get 11.
881660	882660	How did this one go?
882660	884700	Any questions?
884700	890340	Anything arise as you were solving it?
890340	904340	Is it wrong to apply the 4 to the X first, and then 7 to A?
904340	910340	Is it wrong to do 4 goes into X, and then 7 goes into A?
910340	911340	No.
911340	912340	No.
912340	913340	That's totally fine.
913340	914340	That's the way to solve this problem.
914340	915340	Will the 2 always result in the same?
915340	916340	No.
916340	917340	No.
917340	918340	But almost always.
918340	919340	OK.
919340	920340	Yeah.
920340	927300	So 4, you'll be able to recognize when they won't.
927300	931220	So in general, you can always say they will reduce to the same thing.
931220	932220	Yeah.
932220	939380	But we'll cover a case where they don't in the end of class.
939380	943900	So what we could do is we could substitute in the 4 for the X. That's actually the way
943900	945940	I have it in the slides.
945940	950740	7 for the A. Get 11.
950740	955180	All right.
955180	978300	What about this one?
1008300	1021940	I missed a thing here.
1021940	1023340	What should we do first here?
1023340	1024340	Yeah.
1024340	1033820	Why A plus 5 to the X depends on the date that A, one of the A's to a K.
1033820	1036060	Let's cover that second part later.
1036060	1037060	But yes.
1037220	1046020	We're going to apply A plus 5 to X. So we will, following the same algorithm that we've
1046020	1055780	been using, X plus A of 7, where X is equal to A plus 5.
1055780	1060660	All right.
1060660	1063660	Now what do we do?
1064380	1067380	A is 7.
1067380	1068380	All right.
1068380	1075860	So we get X plus A, where X is equal to A plus 5, and A equals 7.
1075860	1079540	Now when we try to solve this, we can say, okay, X is equal to A plus 5.
1079540	1083140	So A plus 5, gosh.
1083140	1085660	Plus A. A is 7.
1085660	1087660	So we get 1419.
1087660	1088660	Yeah.
1088660	1098300	Yeah, so is there no scope?
1098300	1104900	This A here is, like, these guys are clearly connected.
1104900	1107500	But what's the deal with this A?
1107500	1116820	Is that A the same A as this A?
1116820	1118700	Does it need to be evaluated first?
1118700	1124780	Could we have substituted in the 7 first and then maybe avoided this whole headache?
1124780	1141340	If we solve it the alternative way, and we do lambda X dot A plus A dot 7.
1141340	1155300	If we plug in 7 first for A, and we get 7 plus X, and then we sub in our A plus 5 for
1155300	1167860	X, we get a very different answer than what we got before.
1167860	1174860	Instead of 19, which is what we got last time, this time we get 12 plus A.
1174860	1179160	Now there was a previous question about, does order matter?
1179160	1182620	So here we're seeing order made a difference.
1182620	1186100	And my answer before was that it shouldn't make a difference, except in a very specific
1186100	1187100	case.
1187100	1188700	This is not that specific case.
1188700	1191900	Something went wrong here.
1191900	1196420	What we wanted to get, what we should get, is 12 plus A.
1196420	1209300	But in the other method, going the other way, we got 19.
1209300	1213780	A couple of you have already pointed out, maybe this is a scoping issue.
1213780	1221860	Maybe it's because we somehow captured the second A in our inner A. And that's the right
1221860	1222860	intuition.
1222860	1226100	So let's play that out.
1226100	1229620	This is...
1229620	1232780	We kind of already answered that one.
1232780	1238380	So what we find is that substitution is actually a little bit more complicated than what we
1238380	1239380	thought.
1239380	1243420	It's not just that we can take a term as an argument and pass it in.
1243420	1249460	If we do that, we might end up with this case, where we're passing in A plus 5, and then
1249460	1256820	somehow it gets lost inside.
1256820	1266140	We say that in this case, the A has been captured by an inner scope.
1266140	1276080	And we'll come back to the kind of description of this and the notation in a minute.
1276080	1277660	Example to do at home.
1277660	1278660	Example to do at home.
1278860	1286860	All right.
1286860	1288580	I like this other one more.
1288580	1289580	Let's look at this one.
1289580	1294500	So one way to see this same problem is in JavaScript.
1294500	1298580	We might have a function that takes a variable X.
1298580	1308620	And as the first line of that function, we're going to print out the value A plus 5.
1308620	1317240	What is the value of A at the start of that function, when we're printing A plus 5?
1317240	1334900	What's the value of A?
1334900	1335900	Would it work?
1335900	1339940	All right.
1339940	1340940	Fair enough.
1340940	1341940	Yeah.
1341940	1346260	A is undefined at this point.
1346260	1349620	Or maybe it is defined, but, you know, it's, like, defined up...
1349620	1351260	Can you guys see my cursor?
1351260	1352260	No.
1352260	1353380	It's, like, defined up top.
1353380	1354620	So if we said...
1354620	1362620	If we had a...
1362620	1370060	If we have somewhere in an outer scope, let A equal something, then we'll use whatever
1370060	1375860	value that is.
1375860	1383420	When we then create a new function that takes a parameter A, and we log A plus X, and we're
1383420	1391100	calling that with the value A plus 5, what are all of these different values of A?
1391100	1394180	This A here, this A...
1394180	1395180	What's that A?
1395180	1396180	Yeah?
1396180	1410540	This A?
1410540	1411540	Is that the parameter?
1411540	1415860	I mean, it's, like, the argument to this function.
1415860	1418100	Yeah.
1418100	1424980	Yeah, it's the same A that we were initially doing a console log with.
1424980	1433140	It's the outer scoped A. Then we have the A as the parameter.
1433140	1435980	What's the value of that A?
1435980	1437660	I wish these had line numbers.
1437660	1439740	On line 4 from the top.
1439740	1440740	Yeah?
1440740	1443500	The outer scoped A from 5?
1443500	1444500	Yeah.
1444500	1448460	It'll be whatever the result of this expression is.
1448460	1450380	All right?
1450380	1455660	And lastly, what is this A?
1455660	1461020	Yeah.
1461020	1463020	It's the same A that we just talked about.
1463020	1469380	The one before the equal sign, which is equal to the value of this A plus 5.
1469380	1476020	So we have two different A's here, and we don't want to get them mixed up.
1476020	1479700	This inner A is a different A than the outer A.
1480020	1482380	The same goes for lambda calculus.
1482380	1491060	So this function here has its own scope, and this A is equivalent to this A, but not equivalent
1491060	1497940	to this A. This is an outer scoped A that we don't know what its value is.
1497940	1505120	This is a defined A. It's a captured A, or bound A.
1505120	1511320	So we don't want to mix them up.
1511320	1518580	Here's another way to write that same idea.
1518580	1523980	The outer function references an A that it doesn't necessarily define itself.
1523980	1525900	It's from someone else.
1525900	1534300	But then the inner function captures, or binds, the A as its parameter.
1534300	1537900	OK.
1537900	1538900	How can we fix this?
1538900	1539900	Oh, yeah?
1539900	1546780	Can't we just use subscripts and be done with it?
1546780	1547780	How?
1547780	1558820	Yeah, so give this one A1, that one A1, that one A2.
1558820	1561340	Yeah, that's a fine idea.
1561340	1565320	So what happens if we...
1565320	1571640	I wish that this were actual code instead.
1571640	1578080	So using the same A1 and A2 to reference A1 and A2.
1578080	1580080	What happens if we do this?
1580080	1582880	Is that readable?
1582880	1584520	Kind of.
1584520	1587200	That's good enough.
1587200	1591200	So rename them with subscripts.
1591200	1600200	What's gonna happen?
1600240	1602240	Does it solve our problem?
1602240	1610800	Yeah, in fact, A2 is not defined at all.
1610800	1617640	We defined A outside, but A2 nobody's talking about.
1617640	1619260	That's definitely undefined.
1619260	1627920	So we will still run into a different problem when we rename this A to be A2.
1627920	1629160	We've done something illegal.
1629160	1633880	We've changed the name of a variable we don't control.
1633880	1639000	It's definitely fine to call this one A1, because we control that variable.
1639000	1642720	We control all the scoped references of it.
1642720	1644880	This one we don't control.
1644880	1650220	We can't change the name of.
1650220	1651220	Which is...
1651220	1656160	It leads perfectly into how we will fix this problem.
1656160	1660920	So what we're gonna do is we're going to rename our variables.
1660920	1665480	But we have to have a rule about which variables we're allowed to rename.
1665480	1669440	Because we don't want to end up in the situation where we rename a variable that we didn't
1669440	1677000	control and now we can't reference the variable that we wanted to reference.
1677000	1679800	So if we have...
1679800	1685880	This is the same problem that I was showing with JavaScript, but it's just in Haskell
1685880	1687440	instead.
1687440	1688440	Which we haven't covered yet.
1688440	1696600	But the idea is the same, where we say X is equal to A plus 5, and A is 7 in X plus A.
1696600	1701880	So we can do a renaming, a dumb renaming.
1701880	1704760	Or a renaming and then the dumb substitution.
1704760	1705760	Where we say...
1705760	1706760	Okay.
1706760	1708560	This A, we control.
1708560	1715720	We can change that A without changing the outer A.
1715720	1721640	And then once we do the substitution, we get the expected result.
1721640	1728620	All right.
1728620	1734320	So I'm arguing this will work so long as we know what variables we can and which variables
1734320	1739600	we cannot rename.
1739600	1742280	The reason we're going to be doing it this way...
1742440	1743600	Or I guess...
1743600	1746880	What are we exactly doing?
1746880	1754880	First of all, we're talking about a variable being bound if the parameter is within the
1754880	1756480	scope.
1756480	1764240	So when we talk about this A here, this A is bound to this A parameter.
1764240	1774720	This X is bound to this X parameter.
1774720	1779760	Can we always rename bound variables?
1779760	1783280	Yes?
1783280	1786960	No?
1786960	1790960	No?
1790960	1797080	Like ten people voted.
1797080	1806480	Think about JavaScript.
1806480	1812320	Can we always rename X in this function?
1812320	1817360	Or always rename A1 in the other function?
1817360	1819360	Yes?
1819360	1821360	No?
1821360	1822700	Yes!
1822700	1823700	We wrote the code.
1823700	1824880	We get to decide.
1824880	1826700	The parameter name is up to us.
1826700	1829880	So we totally can.
1829880	1831200	These are just placeholders.
1831200	1836480	It's a parameter name.
1836480	1842880	So we specifically say that they are equivalent by an alpha rename.
1842880	1844440	The character is very small there.
1844440	1854120	That is the Greek alpha symbol.
1854120	1864080	So we can rename lambdaX.X plus Y to lambdaZ.Z plus Y.
1864080	1869800	And what we've already started to get at is can we rename everything?
1869800	1873520	We've seen this in JavaScript that we couldn't.
1873520	1876100	So what can't we rename?
1876100	1883120	Can we rename the Y in lambdaX.X plus Y?
1883120	1885760	No.
1885760	1888360	We don't know what it's going to be.
1888360	1895320	Somebody else defined it, and we are just using that value.
1895320	1900360	And what I'm trying to get at here is that you can change the name of your parameters
1900360	1902280	and arguments.
1902280	1913680	You can't change the name of variables in the outer scope.
1913680	1917800	Any questions on this renaming idea?
1917800	1919240	Yeah?
1919240	1941160	Why do we only have access to part of the codebase?
1941160	1943400	Why can't we change the outer A?
1943400	1944400	Yeah?
1944400	1966700	Yeah, so if it's something that's, like, beyond the code, kind of, it's just the string literal
1966700	1969760	that we need to use there, I think that's a fair reason.
1969760	1971520	Why else?
1971520	1974320	Why else might we not have full control?
1974320	1984400	Yeah, definitely.
1984400	1991880	So if we were to be using any external library, any external API or other code, we don't necessarily
1991880	1994400	control that.
1994400	2005880	How many of you have created a file called, like, time.py or math.py in your projects?
2005880	2007120	I feel like that's...
2007120	2011800	I did that when I was, like, first learning how to code and got an error for, like, half
2011800	2017720	an hour trying to figure out what's going on, and it's just because you've overwritten
2017720	2020400	the default library for time.
2020400	2023920	And so Python gets confused, because there's this name conflict.
2023920	2027400	You used time when they've already defined it.
2027400	2030440	It's the same exact fundamental problem.
2030440	2036200	So we operate and write code in very complicated systems.
2036200	2040960	Whether it's an interpreter or just a large codebase that you don't necessarily get to
2040960	2043000	control everything.
2043000	2045220	So this definitely happens.
2045220	2050960	Where you, like, can't control all of your environment.
2050960	2053620	Yeah.
2053620	2056540	Any other questions on renaming?
2056540	2059820	All right.
2059820	2066340	We're gonna get a bit more formal, then.
2066340	2068200	We've covered informal substitution.
2068200	2072100	We have an idea about, okay, we can, like, substitute these things so long as we rename
2072100	2074620	some of them sometimes.
2074620	2077300	Let's do it in a more formal way.
2077300	2080620	So first of all, what is a free variable?
2080620	2083580	We've talked about bound variables.
2083580	2086020	A variable is not bound.
2086020	2087820	Then it is free.
2087820	2091500	So any nonbound variable is a free variable.
2091500	2094980	We had this expression, lambdaX.X plus Y.
2094980	2096820	X was bound.
2096820	2099660	Y is free.
2099660	2119840	I answered the next question there for you.
2119840	2124020	Let's try and solve for these two equations, though.
2124020	2130860	So we want to be able to algorithmically find what are the free variables of an expression.
2130860	2136620	The free variables of the expression X are X.
2136620	2143220	If all that we have is the variable X, we have just, like, nobody's told us anything
2143220	2144220	about it.
2144220	2147680	It is free.
2147680	2169700	What about the free variables of lambdaX.E. Yeah?
2169700	2173680	Is it empty?
2173680	2174680	That's one idea.
2174680	2175680	Yeah?
2175680	2177920	Every variable except for X.
2177920	2179680	Every variable except X.
2179680	2187640	So the, like, all� what would even every variable look like?
2187640	2190600	Something like that minus X.
2190600	2200600	The set of all variables minus X. Yeah?
2200600	2208920	The free variables of E minus X. Okay?
2208920	2211040	Any other candidates?
2211040	2213480	Yeah?
2213480	2219840	Just E. E here is an expression.
2219840	2220840	Not a variable.
2220840	2222080	Just to be clear.
2222080	2224940	But we can leave it up.
2224940	2230320	So the expression E. Any other candidates?
2230320	2237360	So, okay.
2237360	2242200	Let's think about all of these.
2242200	2246520	If we have an expression, we can just choose an expression.
2246520	2253080	So let's use the expression X plus Y. E equals X plus Y.
2253080	2255480	That's been our running example.
2255480	2268040	Are the free variables of lambdaX.X plus Y, is that the empty set?
2268040	2271480	No.
2271480	2275120	We've said that Y is free.
2275120	2283200	So we know Y is free, which means the free variables of this expression can't be empty.
2283200	2285240	So we can't do that one.
2285240	2291360	What about the set of all variables minus the free variable� or minus X?
2291360	2292640	We've captured X.
2292640	2293640	No.
2293640	2294640	Oh, wait.
2294640	2298640	We're looking at�
2298640	2306080	That's okay?
2306080	2308120	Any ideas on this one?
2308120	2314480	No, because E might have bound variables.
2314480	2317080	E might have bound variables.
2317080	2319480	What if we have a different E?
2319480	2335200	We could use lambdaZ.Z plus A. Here, Z is bound.
2335200	2339420	A is free.
2339420	2355200	So when we have the free variables of lambdaX.lambdaZ.Z plus A, it's not actually all variables minus
2355200	2356580	X.
2356580	2357860	We've also captured Z.
2357860	2358860	Yeah?
2358860	2375300	Yeah, so Z is bound in here, but it's not bound out here.
2375300	2377580	Oh, that's fair.
2377580	2378820	Yeah?
2378820	2391380	Z, in the context of this whole function, is still free, if it exists.
2391380	2403820	So this one doesn't actually disprove all variables minus X.
2403820	2407400	Trying to think what a good example would be.
2407400	2416320	I think that there actually might not be a great way of showing that this is not true.
2416320	2422440	What we can look at is then comparing it with this next one.
2422440	2427880	The free variables of E minus X.
2427880	2430800	So here, what we would see is...
2430800	2437720	I'm too low on this, aren't I?
2437720	2443440	What would be an expression that could show that the free variables of E minus X does
2443440	2446440	or does not work?
2446440	2448440	Yeah?
2448440	2450440	Wait.
2450440	2452440	No.
2452440	2454440	Sure.
2454960	2469800	So if we say E is equal to X plus Y, and we look at the free variables of E, this would
2469800	2477160	be equal to the set of X and Y.
2477160	2485120	When we then subtract out X, we will be left with the set Y, which is what we are looking
2485120	2486840	for.
2486840	2493300	So this is the answer I have on my slides.
2493300	2500320	I think this is also somewhat reasonable.
2500320	2504080	The only thing is they aren't, like, defined there.
2504080	2507680	Like, Z is not defined in X plus Y.
2507680	2509900	Or it's not used in X plus Y.
2509900	2511880	That doesn't mean it's not free in X plus Y.
2511880	2518720	That one's thrown me for a bit of a loop.
2518720	2526080	But the simplest set to represent the free variables of lambdaX.E are the free variables
2526080	2530440	of E minus the variable X.
2530440	2549880	That we capture the X from within E. Yeah?
2549880	2558860	So if we have E is X plus Y, the free variables of E, following� actually, I guess we kind
2558860	2559860	of need this one.
2559860	2567480	But following this, we can say that X and Y are both free.
2567480	2572480	Inside of E.
2572480	2576520	So X is only captured as we move out.
2576520	2578520	Exactly.
2578520	2580520	Yeah.
2580520	2588960	So then we work inwards, out.
2588960	2593980	You start at the inside and kind of grow out to your expression.
2593980	2598480	Find what's free and what's not.
2598480	2601720	All right.
2601720	2625240	Doing this last one for application.
2625240	2629640	What are the free variables of E1 applied to E2?
2629640	2635120	Let's give ourselves some examples to see what it should be.
2635120	2641940	We could have lambdaX, X plus Y, and Z, for example.
2641940	2646000	So E1 is lambdaX, X plus Y, E2 is Z.
2646000	2650400	The free variables of E1 are what?
2650400	2653360	Y.
2653360	2658600	So we have FV of E1 equals Y.
2658720	2663520	What are the free variables of E2?
2663520	2674960	Z.
2674960	2680640	And what would we expect to be the free variables of the full expression?
2680640	2682640	Yeah.
2682640	2694120	Yeah, we would think they would be Y and Z.
2694120	2701200	That in this whole part, we don't know what Z is or what Y is.
2701200	2710840	So we have the free variables is equal to, well, here, it's equal to Y, Z, which means
2710840	2720720	if we write it out, that it's equal to the free variables of E1 union free variables
2720720	2728720	of E2.
2729120	2734920	Yeah.
2734920	2755400	Oh, oh, yeah, yeah.
2755400	2756400	Yeah.
2756400	2780200	What are the
2780200	2792480	free variables of this full expression?
2792480	2796580	X and Y.
2796580	2800280	We have this as our equation.
2800280	2803700	It's the union of the two sets.
2803700	2806120	Here we have Y, here we have X.
2806120	2812960	Even though X is bound over here, in the overall expression, X is still free.
2812960	2817160	And that's what's going to end up causing us trouble when we try and do substitution,
2817160	2831080	if we don't do some sort of subscript to say this one's X1.
2831080	2832080	Other questions?
2832080	2833080	Right.
2833080	2834080	That's right.
2834080	2847440	So here, this X and this X are the same.
2847440	2852040	This X is different.
2852040	2860160	Because it's free, yeah.
2860160	2866540	All right.
2866540	2872660	So the last bit of formal stuff that we do here is how can we actually define capture
2872660	2874740	avoiding substitution?
2874740	2883240	That is to say we don't run into our problem with the solution being 19 from earlier.
2883240	2889500	What is the value of X where X is equal to E?
2889500	2892940	Think of yourself as a computer trying to solve these.
2892940	2897140	Or we have to come up with the rules so that a computer could solve these.
2897140	2900300	What's the value of X where X is equal to E?
2900300	2903240	E. I like it.
2903240	2906280	We just replace X with E. That's totally fine.
2906280	2912680	What's the value of Y where X is equal to E?
2912680	2915520	Y if what?
2915520	2917400	Right.
2917400	2921000	It will remain Y so long as Y is not X.
2921000	2924640	If Y were X, then we would use rule one.
2924640	2926320	All right.
2926320	2944280	What about E1 applied to E2 where X is equal to E?
2944280	2969120	Think recursively.
2969120	2997320	We can also do one on the board just to kind of see what happens.
2997320	3009440	So, this is E1 applied to E2 where X is equal to 3.
3009440	3015640	How would we simplify this expression?
3015640	3031200	Yeah, go for it.
3031200	3032200	Is it already simplified?
3032200	3033200	No.
3033200	3037080	No, there's more we can do.
3037080	3040080	I want to substitute in this value of X.
3040080	3044280	How do I do that?
3044280	3047480	Our current two rules, by the way, are just those.
3047480	3048480	Yeah?
3048480	3053920	Is it X where Y equals X?
3053920	3054920	X where Y equals X.
3054920	3055920	Ah!
3055920	3059480	So, you're, like, doing the substitution.
3059480	3062880	So we could, like, kind of continue evaluating.
3062880	3067380	But what I want to do, actually, is just clear up our state.
3067380	3070240	Give all of our Xs the value 3.
3070240	3072300	That's our goal right now.
3072300	3086800	How can we do that?
3086800	3090920	Would it help if you talked to the person next to you?
3090920	3091920	Give it 30 seconds.
3091920	3092960	What can we do here?
3121920	3146940	Okay.
3146940	3149920	What's the, again, algorithmic.
3149920	3155160	Like what your computer is going to do when trying to take the next step here to simplify
3155160	3156160	the state.
3156160	3157160	Yeah.
3157160	3162080	All the way in the back.
3162080	3163080	I'm sorry.
3163080	3166400	What was that?
3166400	3168720	Distribute the definition to each expression.
3168720	3170040	This is the definition?
3170040	3171040	Yeah.
3171040	3178320	So we can say that this is equal to lambda Y dot X, where X is equal to three, applied
3178320	3186360	to lambda Z dot X plus Z, where X is equal to three.
3186360	3190480	We're telling each expression that X is equal to three.
3190480	3195200	Then if we wanted to continue, we can, you know, keep substituting, blah, blah, blah.
3195200	3202320	But we need to be able to actually give X in each of those two contexts the value three.
3202320	3203320	Yeah.
3203320	3210320	I'm a little confused, because I thought we could only substitute bounds, or, like, the
3210320	3217280	bounds are the same, so why are we assigning them to that?
3217280	3218280	Yeah.
3218280	3219280	Let me do that.
3219280	3220280	Yeah.
3220280	3222920	So are these free or bound?
3222920	3232120	Is X free or bound in this expression?
3232120	3233120	Free?
3233280	3234280	Bound?
3235840	3239120	It is actually free.
3239120	3245600	If we look at the free variables of this expression, we would say X is free, X is free, the union
3245600	3248640	of X and X is X.
3248640	3251880	How would we have gotten to a state like this, though?
3251880	3258040	Maybe it's bound in a larger function?
3258040	3262000	It's bound in a larger function, where we've given it value.
3262000	3272400	It's like if we go back to our JavaScript, and we have that outer let A equal.
3272400	3275080	And we've said A is equal to three.
3275080	3279000	Then we know exactly what to do with A. We can substitute it with three.
3279000	3281000	So same thing's happening here.
3281000	3288120	And one way, if we kind of, like, backstep here, we could pretend that there was a lambda
3288120	3295960	X three, right before this step, that we've now substituted in that three for X, and so
3295960	3301720	now we have this state, X equals three.
3301720	3308640	This step here is very similar to what's called an eta reduction, or an eta conversion.
3308640	3310440	But we'll cover that later.
3310440	3311440	Yeah?
3311440	3315720	So we can't bound it into only free variables?
3315720	3317800	We can substitute only free variables.
3318000	3320320	Yeah, so that's right.
3320320	3327480	If we had, let's see, what can I do here?
3327480	3335600	X plus lambda X dot X plus two, it doesn't make any sense anymore, because we're adding
3335600	3337040	a function.
3337040	3341200	But this X here is bound to this X.
3341400	3348800	That means when we substitute X equals three, we don't want to replace this inner X with
3348800	3351000	the value three.
3351000	3353160	Because it's tied to a different parameter.
3353160	3356080	It's scoped to a different parameter.
3356080	3359720	That's just like shadowing in, like, traditional programming.
3359720	3363560	But we haven't gotten to the lambda one yet.
3363560	3367200	We're about to.
3368200	3371520	Okay.
3371520	3380880	So where we are right now is that with two expressions, we can say the X equals E distributes
3380880	3386760	to each expression.
3386760	3392800	Now the question that we have over here is what are we supposed to do if we have lambda
3392800	3398880	X dot E and X is assigned a value?
3398880	3414000	What should we get here with this substitution?
3414000	3424760	The simplest case of this would be lambda X dot X where X is equal to two.
3424760	3439320	What should that reduce to?
3439320	3444200	How many people feel like they have an idea?
3444200	3448000	How many people are confused as to what I'm asking?
3448000	3449560	A few.
3449560	3452000	No, it's fair.
3452000	3453000	It's tricky.
3453000	3456640	Especially, like, there's math notation in computer science.
3456640	3464940	It doesn't happen very often when you're actually, like, coding.
3464940	3467260	But some number of you had an idea.
3467260	3487780	What are you thinking?
3487780	3488780	Go for it.
3488780	3493780	Yeah, it's a bound variable.
3493780	3495600	So can't we just rename it?
3495600	3502820	So what would happen if we say it's equal to ZZ?
3502820	3505220	Does this make it easier?
3505220	3511020	What should this simplify to?
3511020	3515860	Yeah?
3515860	3526960	Does it simplify to Z?
3526960	3534840	So we aren't passing 2 in as a parameter.
3534840	3550580	We have an expression and we have some state as well.
3550580	3552620	We can push state inside the function.
3552620	3553620	Sure.
3553620	3566700	We can get lambdaZ.Z where X is equal to 3 inside of that Z.
3566700	3570380	What does that simplify to?
3570380	3578740	We can use rule number 2.
3578740	3579740	Go for it.
3579740	3584780	Is Z equal to X?
3584780	3585780	No.
3585780	3590300	Z is equal to Z. Z is Z.
3590300	3596260	So it's equal to Z. So we can just get rid of this state.
3596260	3601740	That's the intuitive thing to do when we're trying to substitute X equals 2 in an expression
3601740	3604740	that doesn't use X. We can just ignore X.
3604740	3612100	Right?
3612100	3613740	Does that feel intuitive?
3613740	3614740	Does it...
3614740	3622420	Do you have questions about why we can do that?
3622420	3625700	We're trying to say X is equal to 2, but we aren't using X.
3625700	3631660	So within that scope, we can just ignore the fact that X is equal to 2.
3631660	3646320	What that looks like is saying lambdaX.E, where X is equal to E, is just lambdaX.E.
3646320	3654080	This problem started, by the way, slightly differently with XX.
3654080	3660840	But the point was, because this X is bound to that X parameter, we were able to rename
3660840	3664880	it.
3664880	3668020	Which is why, then, it was very clear that we could do this.
3668020	3673120	We can do it either way, without the rename or with the rename.
3673120	3680640	But the rename kind of makes it a little bit clearer as to why we can do that.
3680640	3681640	Question?
3681640	3682640	Yeah.
3682640	3696880	Yeah, so this X in the outer scope that is equal to E, what if this X is in E1?
3696880	3697880	Yeah.
3697880	3702080	Then it would be bound.
3702080	3708520	And it wouldn't be this X. This X cannot exist inside of the scope E1.
3708520	3717880	Any Xs inside of E1 are bound to this X or another inner X that is binding them.
3717880	3723600	It's never going to be this X. Because that one comes first.
3723600	3728280	It's similar to when you're writing code and you say X is equal to 3.
3728280	3731880	That X is equal to 3, the outer ones aren't.
3731880	3736000	Unless you're, like, doing something weird.
3736000	3738720	All right.
3738720	3742080	Can we get the last one here?
3742080	3753920	What happens lambda Y dot E1 and X is equal to E2?
3753920	3773000	Push it inside.
3773000	3774000	Yeah.
3774000	3794640	Maybe...
3794640	3802740	So what we want to say is that it's lambda Y dot E1 where X is equal to E2.
3802740	3810020	So basically what we've done is we've dropped the lambda Y as part of the consideration.
3810020	3818260	And so then we can take another step based on whatever E1 is where X is equal to E2.
3818260	3823220	That's what we would like to say.
3823220	3828740	But there are some important caveats here.
3828740	3831140	Yeah.
3831340	3833360	Yeah.
3833360	3836060	So can I read what I just wrote?
3836060	3837700	Lambda Y dot E1.
3837700	3845460	The expression lambda Y dot E1 where the state X is equal to E2.
3845460	3854540	On the next line, we have lambda Y dot E1 where the state is X equals E2.
3854540	3861780	So here what I'm saying is that the state is part of this expression only.
3861780	3875720	Here what I'm saying is the state is part of the entire expression.
3875720	3878280	We might have Y in E2.
3878280	3884920	So Y in E2.
3884920	3894480	What would happen if we have Y in E2?
3894480	3899120	So if E2 is equal to exactly, for example, Y.
3899120	3900120	Yeah.
3900120	3901120	Yeah.
3901120	3902120	Yeah.
3902120	3926400	So if E2 is equal to Y, and let's say E1 equals X, then when we perform our replacement based
3926400	3932420	on the state, we would get lambda Y dot Y as our result.
3932420	3939760	Because E1 is X, and X is equal to E2, and E2 is equal to Y.
3939760	3942460	So we would end up with lambda Y dot Y.
3942460	3948800	In which case, we have captured the Y.
3948800	3957760	Because E2 is not being controlled by this Y here.
3957760	3959840	So this Y was free, potentially.
3959840	3963140	Well, I guess, no, it's definitely free here.
3963140	3965880	And then we've accidentally captured it.
3965880	3973320	So if Y is in E2, we have an issue, and we will need to do an alpha rename on this Y.
3973320	3979680	This Y and any Y inside of E1.
3979680	3983640	The other case is defined by this one here.
3983640	3994960	If Y is equal to X, then we would just use this rule instead and drop the state.
3994960	4001320	So our expression is that lambda Y dot E1, where X is equal to E2, is equal to lambda
4001320	4005120	Y dot E1, where X is equal to E2.
4005120	4011240	So long as Y does not equal X, if Y equaled X, we would use this rule here.
4011240	4015200	And so long as Y is not in the free variables of E2.
4015200	4019280	If Y were in the free variables of E2, then we would be capturing the Y.
4019280	4020280	Yeah?
4020280	4021280	Just to clarify, between these last two bullet points, does the E inside of the brackets
4021280	4042280	having a 2 or not make a difference?
4042280	4043280	No.
4043280	4044280	OK.
4044360	4053200	Yeah, it's just to say that these are different E's.
4053200	4054720	These are different E's as well.
4054720	4055720	Those are different E's.
4055720	4056720	Yeah.
4056720	4057720	Yeah?
4057720	4068600	So if Y is in the state of the free variable E2, do you just go with X?
4068600	4071600	If Y is in the state...
4071920	4076920	If Y is in the free variable of E2, then you would just throw away that?
4076920	4077920	Ah, yeah.
4077920	4084600	So what do we do if Y is in E2 here, in the free variables of E2?
4084600	4088360	Then what we need to do is we need to actually alpha rename.
4088360	4095520	That's when we do our renaming of this Y here and any Y in E1.
4095520	4096720	That's the way to solve that.
4096720	4099080	It's not that we just throw away this state.
4099080	4102720	We can't ignore the fact that X equals E2 here.
4102720	4106200	Because we might be using X inside of E1.
4106200	4115320	So we have to actually rename the bound version of Y so that we can do the substitution.
4115320	4118320	Yeah?
4118320	4121320	Yeah.
4121320	4124320	Yeah.
4124560	4126560	Yeah.
4126560	4127560	Yeah.
4127560	4130560	So we need to rewrite the code to do it this way.
4130560	4131560	Yeah.
4131560	4134560	To rename the parameters.
4144560	4145560	Yeah.
4145560	4148560	So let's use this one.
4154560	4157560	Yeah.
4165560	4173800	We have a function and we have a parameter or an argument being passed in to that function.
4173800	4175840	Our first step here is...
4175840	4179440	Well, actually, the first thing we can do is what are the free variables of this whole
4179440	4182440	expression?
4182440	4197880	What are the free variables of a union of...
4197880	4198880	Or...
4198880	4199880	Okay.
4199880	4201440	It's the union of an application.
4201440	4206440	So what are the free variables of the left-hand side of this application?
4206440	4209640	None.
4209640	4210800	It's the empty set.
4211160	4213040	This X here is bound by this X.
4213040	4216400	What are the free variables of the right-hand side of the application?
4216400	4217800	Y.
4217800	4222200	So the free variables of the whole expression are the union of empty set and Y.
4222200	4224200	Which means...
4224200	4225500	Y.
4225500	4236200	When we perform this substitution, what's the first step that we do?
4236600	4239600	Yeah.
4239600	4254600	Set X equal Y.
4254600	4261100	We're gonna pass Y in for the parameter to X.
4261220	4276580	So we're going to get lambda Y dot X, where X is equal to Y.
4276580	4282820	What's our next step?
4282820	4288380	Go for it.
4288380	4291420	How about rename Y in the lambda Y?
4291420	4294340	This Y here.
4294340	4296800	And why do we have to do that?
4296800	4303340	If we take a look at this example here, or this rule here, we are exactly in violation
4303340	4304860	of it.
4304860	4312900	Where we're trying to do lambda Y dot X, where X is equal to Y.
4312900	4318460	And so that means Y is in the free variables of the Y.
4318460	4324340	This Y here is in the free variables of that Y there.
4324340	4332320	And if we don't do the renaming, then we will end up with lambda Y dot Y, where we've captured
4332320	4333580	the Y.
4333580	4341020	We've accidentally bound a free variable that started out free, now it's not free.
4341140	4351020	If we rename this Y to something like Z, how can we simplify this expression?
4351020	4370540	What rule would we use?
4370540	4377420	We'll use the last rule, where we're saying, let's pass this state into the expression
4377420	4381340	instead of looking at it at the whole level.
4381340	4385200	So now we're saying X, where X equals Y.
4385200	4388500	How do we substitute that?
4388500	4391500	What rule do we use?
4391500	4400820	Yeah.
4400820	4406500	We have X, where X equals E. E in this case is Y.
4406500	4408460	So we can do our substitution.
4408460	4412340	We will end up with lambda Z dot Y.
4412340	4422660	Y.
4422660	4428340	So that's Y, the if.
4428340	4431400	Okay.
4431400	4436500	This largely speaking covers these first two rules.
4436500	4442300	We have alpha rename, where we're saying we can rename any bound variable.
4442300	4450300	And we have beta reduction, where we're saying we can actually perform an application.
4450300	4456460	We can pass an argument into a function and then reduce it.
4456460	4463940	The last one here is the eta conversion, which says that if we have a pattern such as lambda
4463940	4472300	X, E of X, that can be reduced to E automatically.
4472300	4477180	I'll leave you to figure out exactly how this works.
4477180	4482620	I would recommend writing it in JavaScript, and then it becomes kind of apparent.
4482620	4485300	But I'm going to stop here.
4485300	4488820	We do have some more lambda calculus to do on Monday.
4488820	4493780	But you are equipped to solve all of the homework assignment problems.
4493780	4497820	Just using basically these first two techniques.
4523780	4548780	Hey, what's up?
4553780	4580780	Hey, what's up?
4580780	4609780	Hey, what's up?
4609780	4638780	Hey, what's up?
4638780	4667780	Hey, what's up?
4667780	4696780	Hey, what's up?
4696780	4725780	Hey, what's up?
4725780	4754780	Hey, what's up?
4754780	4755780	Hey, what's up?
4755780	4755780	
4784780	4785780	Hey, what's up?
4785780	4786780	Hey, what's up?
4786780	4797780	Hey, what's up?
4797780	4811780	Hey, what's up?
